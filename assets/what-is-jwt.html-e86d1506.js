import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as i,c as r,a,b as e,d as l,e as n}from"./app-2feb0630.js";const p={},c=n('<h2 id="_1-什么是jwt" tabindex="-1"><a class="header-anchor" href="#_1-什么是jwt" aria-hidden="true">#</a> 1. 什么是JWT</h2><p>JWT （JSON Web Token） 是目前最流行的跨域认证解决方案，是一种基于 Token 的认证授权机制。 从 JWT 的全称可以看出，JWT 本身也是 Token，一种规范化之后的 JSON 结构的 Token。</p><p>Token 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。</p><p>可以看出，<strong>JWT 更符合设计 RESTful API 时的「Stateless（无状态）」原则</strong> 。</p><p>并且， 使用 Token 认证可以有效避免 CSRF 攻击，因为 Token 一般是存在在 localStorage 中，使用 JWT 进行身份验证的过程中是不会涉及到 Cookie 的。</p><p>下面是 FC 7519 对 JWT 做的较为正式的定义。</p><blockquote><p>JSON Web Token (JWT) is a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted. ——JSON Web Token (JWT)</p></blockquote><blockquote><p>JSON Web Token (JWT) 是一种紧凑、URL 安全的方式，用于表示要在两方之间传输的声明。 JWT 中的声明被编码为 JSON 对象，该对象用作 JSON Web 签名 (JWS) 结构的有效负载或 JSON Web 加密 (JWE) 结构的明文，从而使声明能够进行数字签名或完整性保护使用消息验证代码 (MAC) 和/或加密。 ——JSON网络令牌（JWT）</p></blockquote><h2 id="_2-jwt由哪些部分组成" tabindex="-1"><a class="header-anchor" href="#_2-jwt由哪些部分组成" aria-hidden="true">#</a> 2. JWT由哪些部分组成</h2><p>JWT 本质上就是一组字串，通过（.）切分成三个为 Base64 编码的部分：</p><ul><li><strong>Header</strong> : 描述 JWT 的元数据，定义了生成签名的算法以及 Token 的类型。</li><li><strong>Payload</strong> : 用来存放实际需要传递的数据</li><li><strong>Signature（签名）</strong> ：服务器通过 Payload、Header 和一个密钥(Secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。</li></ul><p>JWT 通常是这样的：aaaa.bbbb.cccc。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202308072037189.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure>',13),d={href:"https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202308072039099.png",target:"_blank",rel:"noopener noreferrer"},u=n(`<figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202308072039099.png" alt="image-20230807203955978" tabindex="0" loading="lazy"><figcaption>image-20230807203955978</figcaption></figure><p>Header 和 Payload 都是 JSON 格式的数据，Signature 由 Payload、Header 和 Secret(密钥)通过特定的计算公式和加密算法得到。</p><p>接下来，具体看一下每一部分</p><p>Header header典型的由两部分组成：token的类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
    &#39;alg&#39;<span class="token operator">:</span> <span class="token string">&quot;HS256&quot;</span><span class="token punctuation">,</span>
    &#39;typ&#39;<span class="token operator">:</span> <span class="token string">&quot;JWT&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，用Base64对这个JSON编码就得到JWT的第一部分</p><ul><li><p>Payload JWT的第二部分是payload，它包含声明（要求）。声明是关于实体(通常是用户)和其他数据的声明。声明有三种类型: registered, public 和 private。</p></li><li><ul><li>Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。</li><li>Public claims : 可以随意定义。</li><li>Private claims : 用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。 下面是一个例子：</li></ul></li></ul><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token punctuation">{</span>
    <span class="token property">&quot;sub&quot;</span><span class="token operator">:</span> &#39;<span class="token number">1234567890</span>&#39;<span class="token punctuation">,</span>
    <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> &#39;Leo&#39;<span class="token punctuation">,</span>
    <span class="token property">&quot;admin&quot;</span><span class="token operator">:</span><span class="token boolean">true</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对<strong>payload</strong>进行<strong>Base64</strong>编码就得到JWT的第二部分</p><p>注意，不要在JWT的payload或header中放置敏感信息，除非它们是加密的。</p><p><strong>Signature</strong></p><blockquote><p>为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。</p></blockquote><blockquote><p>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</p></blockquote><p>签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。</p><p>看一张官网的图就明白了：</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202308072041358.png" alt="image-20230807204120279" tabindex="0" loading="lazy"><figcaption>image-20230807204120279</figcaption></figure><h2 id="_3-json-web-tokens是如何工作的" tabindex="-1"><a class="header-anchor" href="#_3-json-web-tokens是如何工作的" aria-hidden="true">#</a> 3. JSON Web Tokens是如何工作的</h2><p>在认证的时候，当用户用他们的凭证成功登录以后，一个JSON Web Token将会被返回。此后，token就是用户凭证了，你必须非常小心以防止出现安全问题。一般而言，你保存令牌的时候不应该超过你所需要它的时间。</p><p>无论何时用户想要访问受保护的路由或者资源的时候，用户代理（通常是浏览器）都应该带上JWT，典型的，通常放在Authorization header中，用Bearer schema。</p><p>header应该看起来是这样的：</p><blockquote><p><code>Authorization: Bearer</code></p></blockquote><p>服务器上的受保护的路由将会检查Authorization header中的JWT是否有效，如果有效，则用户可以访问受保护的资源。如果JWT包含足够多的必需的数据，那么就可以减少对某些操作的数据库查询的需要，尽管可能并不总是如此。</p><p>如果<code>token</code>是在授权头（<strong>Authorization header</strong>）中发送的，那么跨源资源共享(CORS)将不会成为问题，因为它不使用cookie。</p><h2 id="_4-如何基于-jwt-进行身份验证" tabindex="-1"><a class="header-anchor" href="#_4-如何基于-jwt-进行身份验证" aria-hidden="true">#</a> 4. 如何基于 JWT 进行身份验证</h2><blockquote><p>在基于 Token 进行身份验证的的应用程序中，服务器通过 Payload、Header 和 Secret(密钥)创建Token（令牌）并将 Token 发送给客户端。客户端接收到 Token 之后，会将其保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。</p></blockquote><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202308072045950.png" alt="image-20230807204534879" tabindex="0" loading="lazy"><figcaption>image-20230807204534879</figcaption></figure><p>简化后的步骤如下：</p><ol><li>用户向服务器发送用户名、密码以及验证码用于登陆系统。</li><li>如果用户用户名、密码以及验证码校验正确的话，服务端会返回已经签名的 Token。</li><li>用户以后每次向后端发请求都在 Header 中带上这个 Token。</li><li>服务端检查 Token 并从中获取用户相关信息。</li></ol><p>两点建议：</p><ol><li>建议将 Token 存放在 localStorage 中，放在 Cookie 中会有 CSRF 风险。</li><li>请求服务端并携带 Token 的常见做法是将 Token 放在 HTTP Header 的 Authorization 字段中（Authorization: Bearer Token）。</li></ol><h2 id="_5-如何防止-jwt-被篡改的" tabindex="-1"><a class="header-anchor" href="#_5-如何防止-jwt-被篡改的" aria-hidden="true">#</a> 5. 如何防止 JWT 被篡改的</h2><blockquote><p>有了签名之后，即使 Token 被泄露或者解惑，黑客也没办法同时篡改 Signature 、Header 、Payload。</p></blockquote><p>这是为什么呢？因为服务端拿到 Token 之后，会解析出其中包含的 <strong>Header</strong>、<strong>Payload</strong> 以及 <strong>Signature</strong> 。服务端会根据 Header、Payload、密钥再次生成一个 Signature。拿新生成的 <strong>Signature</strong> 和 <strong>Token</strong> 中的 <strong>Signature</strong> 作对比，如果一样就说明 Header 和 Payload 没有被修改。</p><p>不过，如果服务端的秘钥也被泄露的话，黑客就可以同时篡改 Signature 、Header 、Payload 了。黑客直接修改了 Header 和 Payload 之后，再重新生成一个 Signature 就可以了。</p><p><strong>密钥一定保管好，一定不要泄露出去。JWT 安全的核心在于签名，签名安全的核心在密钥。</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202312031906036.png" alt="公众号封面" tabindex="0" loading="lazy"><figcaption>公众号封面</figcaption></figure>`,36);function g(h,k){const o=s("ExternalLinkIcon");return i(),r("div",null,[c,a("p",null,[e("你可以在 "),a("a",d,[e("jwt.io"),l(o)]),e(" 这个网站上对其 JWT 进行解码，解码之后得到的就是 Header、Payload、Signature 这三部分。")]),u])}const T=t(p,[["render",g],["__file","what-is-jwt.html.vue"]]);export{T as default};
