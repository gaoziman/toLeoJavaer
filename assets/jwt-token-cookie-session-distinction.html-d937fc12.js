import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as a,o as r,c as d,a as e,b as o,d as s,e as t}from"./app-2feb0630.js";const c={},l=t(`<h1 id="jwt-token-cookie-session之间的区别" tabindex="-1"><a class="header-anchor" href="#jwt-token-cookie-session之间的区别" aria-hidden="true">#</a> Jwt，Token，Cookie，Session之间的区别</h1><p><strong>思维导图</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311081141562.png" alt="image-20231108114133410" tabindex="0" loading="lazy"><figcaption>image-20231108114133410</figcaption></figure><h2 id="_1-基本概述" tabindex="-1"><a class="header-anchor" href="#_1-基本概述" aria-hidden="true">#</a> 1.基本概述</h2><h3 id="_2-1认证-authentication" tabindex="-1"><a class="header-anchor" href="#_2-1认证-authentication" aria-hidden="true">#</a> 2.1认证(Authentication)</h3><p>认证是关于验证你的凭据，如用户名/邮箱和密码，以验证访问者的身份。系统确定你是否就是你所说的使用凭据。在公共和专用网络中，系统通过登录密码验证用户身份。身份认证通常通过用户名和密码完成，有时与认证可以不仅仅通过密码的形式，也可以通过手机验证码或者生物特征等其他因素。</p><p>在某些应用系统中，为了追求更高的安全性，往往会要求多种认证因素叠加使用，这就是我们经常说的多因素认证。</p><p>通俗地讲就是验证当前用户的身份，证明<strong>你是你自己</strong> (比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功)</p><p><strong>常见的认证方式：</strong></p><ul><li>用户名密码认证</li><li>手机和短信验证码认证</li><li>邮箱和邮件验证码认证</li><li>人脸识别/指纹识别的生物因素认证</li><li>OTP 认证</li><li>Radius 网络认证</li></ul><h3 id="_2-2授权-authorization" tabindex="-1"><a class="header-anchor" href="#_2-2授权-authorization" aria-hidden="true">#</a> 2.2授权(Authorization)</h3><p>授权发生在系统完成身份认证之后，最终会授予你访问资源（如信息，文件，数据库，资金，位置，几乎任何内容）的完全权限。简单来说，授权决定了你访问系统的能力以及达到的程度。</p><p>授权是确定经过身份验证的用户是否可以访问特定资源的过程。它验证你是否有权授予你访问信息，数据库，文件等资源的权限。授权通常在验证后确认你的权限。简单来说，就像给予某人官方许可做某事或任何事情。</p><p>例如，验证和确认组织中的邮箱和密码的过程称为认证，但确定哪个员工可以访问哪个楼层称为授权。假设你正在旅行而且即将登机。当你在登记前出示机票和一些身份证明时，你会收到一张登机牌，证明机场管理局已对你的身份进行了身份验证。但那不是它。乘务员必须授权你登上你应该乘坐的航班，让你可以进入飞机内部及其资源。</p><p>用户授予第三方应用访问该用户某些资源的权限</p><ul><li>你在安装手机应用的时候，APP 会询问是否允许授予权限<code>(访问相册、地理位置等权限)</code></li><li>你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限<code>(获取昵称、头像、地区、性别等个人信息)</code></li></ul><p>实现授权的方式有：cookie、session、token、OAuth</p><h3 id="_2-3认证与授权的对比" tabindex="-1"><a class="header-anchor" href="#_2-3认证与授权的对比" aria-hidden="true">#</a> 2.3认证与授权的对比</h3><table><thead><tr><th style="text-align:left;">认证</th><th style="text-align:left;">授权</th></tr></thead><tbody><tr><td style="text-align:left;">验证确认身份以授予对系统的访问权限。</td><td style="text-align:left;">授权确定你是否有权访问资源。</td></tr><tr><td style="text-align:left;">这是验证用户凭据以获得用户访问权限的过程。</td><td style="text-align:left;">这是验证是否允许访问的过程。</td></tr><tr><td style="text-align:left;">它决定用户是否是他声称的用户。</td><td style="text-align:left;">它确定用户可以访问和不访问的内容。</td></tr><tr><td style="text-align:left;">身份验证通常需要用户名和密码。</td><td style="text-align:left;">授权所需的身份验证因素可能有所不同，具体取决于安全级别。</td></tr><tr><td style="text-align:left;">身份验证是授权的第一步，因此始终是第一步。</td><td style="text-align:left;">授权在成功验证后完成。</td></tr><tr><td style="text-align:left;">例如，特定大学的学生在访问大学官方网站的学生链接之前需要进行身份验证。这称为身份验证。</td><td style="text-align:left;">例如，授权确定成功验证后学生有权在大学网站上访问哪些信息。</td></tr></tbody></table><h3 id="_2-4凭证-credentials" tabindex="-1"><a class="header-anchor" href="#_2-4凭证-credentials" aria-hidden="true">#</a> 2.4凭证(Credentials)</h3><ul><li>实现认证和授权的前提</li><li>是需要一种媒介（证书）来标记访问者的身份</li></ul><p>在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。</p><p>在现实生活中，每个人都会有一张专属的居民身份证，是用于证明持有人身份的一种法定证件。通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是认证的凭证。</p><p>在互联网应用中，一般网站（如CSDN、掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个<strong>令牌(token)</strong>，这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。</p><h3 id="_2-5认证、授权、确权与鉴权" tabindex="-1"><a class="header-anchor" href="#_2-5认证、授权、确权与鉴权" aria-hidden="true">#</a> 2.5认证、授权、确权与鉴权</h3><table><thead><tr><th style="text-align:left;">概念</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">认证</td><td style="text-align:left;">确认声明者的身份。</td></tr><tr><td style="text-align:left;">授权</td><td style="text-align:left;">获取用户的委派权限。</td></tr><tr><td style="text-align:left;">确权</td><td style="text-align:left;">用户对授权进行确认。</td></tr><tr><td style="text-align:left;">鉴权</td><td style="text-align:left;">对所声明的权限真实性进行鉴别的过程。</td></tr></tbody></table><h2 id="_2-cookie" tabindex="-1"><a class="header-anchor" href="#_2-cookie" aria-hidden="true">#</a> 2.Cookie</h2><h3 id="_2-1cookie概述" tabindex="-1"><a class="header-anchor" href="#_2-1cookie概述" aria-hidden="true">#</a> 2.1Cookie概述</h3><p><strong>HTTP是无状态的协议</strong>：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次请求的发送者是不是同一个客户端。服务器与浏览器为了进行会话跟踪，就必须主动的去维护一个状态，这个状态用于告诉服务端前后两个请求是否来自同一个浏览器。这个状态就需要通过cookie或者session来实现。<code>(简单来说我们需要有一个标记让浏览器认识我们，当我们第一次登录之后保存我们的登录信息，方便下次登录。)</code></p><p><strong>cookie存储在客户端</strong>：<code>cookie</code>是服务器发送到用户浏览器，并进行保存到本地的数据，它会在浏览器下次向同一服务器再发起请求时被再一次被带到并发送到服务器上面</p><p><strong>cookie是不可跨域名的</strong>：每个<code>cookie</code>都会绑定单一的域名，无法在别的域名下获取使用。</p><p>先明确一点，<code>Cookie</code> 就是为了解决 HTTP 协议无状态的问题，接下来举个例子说明。</p><p>早年间医院对患者的病例还没有在线建档的时候，都需要患者在就医之前，办理一个病历的小册子，医生会在病历中写上此次就医的情况，什么时间、有什么表现的反映、诊断是什么病、开了一些什么药等等。如果下次又生病了，有病历的情况下，都会要求患者再把病历带上，这样医生就能通过病历了解到之前的情况。</p><p>在 <code>Cookie</code> 的实现上，也是这样的。</p><p>服务端（医生）在收到客户端（患者）请求的时候，将一些用户标识信息加入到 <strong>Cookie</strong> （病例）中，随着响应返回给客户端，客户端将 <strong>Cookie</strong> 中的信息存储在本地，下次再请求此服务器的时候，再将 <strong>Cookie</strong> 中携带的数据原样传输给服务端，此时服务端就能通过 <strong>Cookie</strong> 中的用户标识，识别出这是之前请求过的某个用户。</p><p>在这个例子中，服务端就是医生的角色、客户端是患者的角色、<strong>Cookie</strong> 就是病历。</p><p>cookie 重要的属性:</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311081147388.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-2一个完整的cookie细节" tabindex="-1"><a class="header-anchor" href="#_2-2一个完整的cookie细节" aria-hidden="true">#</a> 2.2一个完整的cookie细节</h3><p>HTTP 协议中的规则，都是通过在请求头和响应头中写入输入来实现，Cookie 也是这样的。</p><p>服务端通过 <code>Set-Cookie</code> 这个响应头来向客户端中写入 Cookie 信息，而客户端读取 <code>Set-Cookie</code> 这个响应头中的信息存储起来，在下次请求的时候取出来，再通过 <code>Cookie</code> 这个请求头，将 Cookie 的数据传输给服务端。</p><p>再看一个浏览器中，Cookie 使用的实例。</p><p>在响应头**(Response Header)**中，使用 <code>Set-Cookie</code> 传递不同的 Cookie 数据，多个数据可以分开成多个 <code>Set-Cookie</code> 头。</p><p>在请求头中**(Request Header)**中，使用 <code>Cookie</code> 这个请求头传递 Cookie 数据，不同的数据通过 <code>;</code>分割。</p><h3 id="_2-2set-cookie-和-cookie-标头" tabindex="-1"><a class="header-anchor" href="#_2-2set-cookie-和-cookie-标头" aria-hidden="true">#</a> 2.2Set-Cookie 和 Cookie 标头</h3><p><code>Set-Cookie</code> HTTP 响应标头将 cookie 从服务器发送到用户代理。下面是一个发送 Cookie 的例子</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311081407443.png" alt="image-20231108140722352" tabindex="0" loading="lazy"><figcaption>image-20231108140722352</figcaption></figure><p>有两种类型的 Cookies，一种是 <strong>Session Cookies会话 cookie</strong>，一种是 <strong>Persistent Cookies永久 cookie</strong>，如果 Cookie 不包含到期日期，则将其视为会话 Cookie。会话 Cookie 存储在内存中，永远不会写入磁盘，当浏览器关闭时，此后 Cookie 将永久丢失。如果 Cookie 包含<code>有效期</code> ，则将其视为持久性 Cookie。在到期指定的日期，Cookie 将从磁盘中删除。</p><p>还有一种是 Cookie 的 <code>Secure</code> 和 <code>HttpOnly</code> 标记。</p><h3 id="_2-3永久性cookie" tabindex="-1"><a class="header-anchor" href="#_2-3永久性cookie" aria-hidden="true">#</a> 2.3永久性Cookie</h3><p>永久性 Cookie 不会在客户端关闭时过期，而是在<code>特定日期（Expires）</code>或<code>特定时间长度（Max-Age）</code>外过期。例如</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Set</span><span class="token operator">-</span><span class="token class-name">Cookie</span><span class="token operator">:</span> id<span class="token operator">=</span>a3fWa<span class="token punctuation">;</span> <span class="token class-name">Expires</span><span class="token operator">=</span><span class="token class-name">Wed</span><span class="token punctuation">,</span> <span class="token number">21</span> <span class="token class-name">Oct</span> <span class="token number">2023</span> <span class="token number">07</span><span class="token operator">:</span><span class="token number">28</span><span class="token operator">:</span><span class="token number">00</span> <span class="token constant">GMT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,52),p={href:"https://www.cltphp.com/search/Cookie.html",target:"_blank",rel:"noopener noreferrer"},h={href:"https://www.cltphp.com/search/Cookie.html",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.cltphp.com/search/Cookie.html",target:"_blank",rel:"noopener noreferrer"},g=t(`<h3 id="_2-5cookie-的作用域" tabindex="-1"><a class="header-anchor" href="#_2-5cookie-的作用域" aria-hidden="true">#</a> 2.5Cookie 的作用域</h3><h2 id="_3-session" tabindex="-1"><a class="header-anchor" href="#_3-session" aria-hidden="true">#</a> 3.Session</h2><h3 id="_3-1session概述" tabindex="-1"><a class="header-anchor" href="#_3-1session概述" aria-hidden="true">#</a> 3.1Session概述</h3><p><strong>Session</strong> 是客户端与服务器通讯会话跟踪技术，服务器与客户端保持整个通讯的会话基本信息。</p><ul><li>session是区别cookie的另一种记录服务器和客户端会话状态的机制</li><li>session是基于cookie实现的，session存储在服务器端，sessionid会被存储到客户端的cookie中</li></ul><p>服务器为每个用户创建一个会话，存储用户的相关信息，以便多次请求能够定位到同一个上下文,流程如下：</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311081328015.png" alt="image-20231108132845893" tabindex="0" loading="lazy"><figcaption>image-20231108132845893</figcaption></figure><p>这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。</p><p>当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。</p><p>Web开发中，web-server可以自动为同一个浏览器的访问用户自动创建session，提供数据存储功能。最常见的，会把用户的登录信息、用户信息存储在session中，以保持登录状态。</p><h3 id="_3-2session如何判断是否是同一会话" tabindex="-1"><a class="header-anchor" href="#_3-2session如何判断是否是同一会话" aria-hidden="true">#</a> 3.2Session如何判断是否是同一会话</h3><p>服务器第一次接收到请求时，开辟了一块 Session 空间(创建了Session对象)，同时生成一个 <code>sessionId</code> ，并通过响应头的 <strong>Set-Cookie：JSESSIONID=XXXXXXX</strong> 命令，向客户端发送要求设置 Cookie 的响应；客户端收到响应后，在本机客户端设置了一个 <strong>JSESSIONID=XXXXXXX</strong> 的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311081341459.png" alt="image-20231108134118376" tabindex="0" loading="lazy"><figcaption>image-20231108134118376</figcaption></figure><h3 id="_3-3session的缺点" tabindex="-1"><a class="header-anchor" href="#_3-3session的缺点" aria-hidden="true">#</a> 3.3Session的缺点</h3><p><strong>Session</strong> 机制有个缺点，比如 A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。</p><h2 id="_4-cookie和session的区别" tabindex="-1"><a class="header-anchor" href="#_4-cookie和session的区别" aria-hidden="true">#</a> 4.Cookie和Session的区别</h2><ul><li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li><li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li><li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li><li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li><li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li></ul><p><strong>session用来跟踪会话</strong></p><ol><li>session 在服务器端，cookie 在客户端（浏览器）</li><li>session 默认被存在在服务器的一个文件里（不是内存）</li><li>session 的运行依赖 <strong>session id</strong>，而 <strong>session id</strong> 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）</li><li>session 可以放在 文件、数据库、或内存中都可以。</li><li>用户验证这种场合一般会用 session</li></ol><p>因此，维持一个会话的核心就是客户端的唯一标识，即 session id</p><h3 id="_4-1为什么需要-cookie-和-session-他们有什么关联" tabindex="-1"><a class="header-anchor" href="#_4-1为什么需要-cookie-和-session-他们有什么关联" aria-hidden="true">#</a> 4.1为什么需要 Cookie 和 Session，他们有什么关联？</h3><p>说起来为什么需要 Cookie ，这就需要从浏览器开始说起，我们都知道浏览器是没有状态的(HTTP 协议无状态)，这意味着浏览器并不知道是张三还是李四在和服务端打交道。这个时候就需要有一个机制来告诉服务端，本次操作用户是否登录，是哪个用户在执行的操作，那这套机制的实现就需要 Cookie 和 Session 的配合。</p><p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p><p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 <strong>SessionID</strong>，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p><p><strong>SessionID</strong> 是连接 <strong>Cookie</strong> 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p><p>既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 <strong>Cookie</strong>，如何保障整个机制的正常运转。</p><p>第一种方案，每次请求中都携带一个 <strong>SessionID</strong> 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 <code>xxx?SessionID=123456...</code>。</p><p>第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p><p>Token 的意思是<code>令牌</code>，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。</p><p>当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。</p><h2 id="_5-什么是token" tabindex="-1"><a class="header-anchor" href="#_5-什么是token" aria-hidden="true">#</a> 5.什么是Token</h2><h3 id="_5-1为什么要使用token" tabindex="-1"><a class="header-anchor" href="#_5-1为什么要使用token" aria-hidden="true">#</a> 5.1为什么要使用Token</h3><p>因为cookie和session一些自身的缺点,限制了一些功能的实现,比如:<br> cookie：优点是节省服务器空间，缺点不安全。不要保存敏感信息。<br> session：优点是安全，缺点需要服务器空间(服务器重启，则数据丢失)， 是一种最常见的解决方案。而这个时候,我们用token就能更好</p><h3 id="_5-2token概述" tabindex="-1"><a class="header-anchor" href="#_5-2token概述" aria-hidden="true">#</a> 5.2Token概述</h3><p>token的意思是<strong>令牌</strong>，是服务端生成的一串字符串，作为客户端进行请求的一个标识。<br> JWT（json web token） 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token punctuation">{</span>
<span class="token string">&quot;姓名&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Leo&quot;</span><span class="token punctuation">,</span>
<span class="token string">&quot;角色&quot;</span><span class="token operator">:</span> <span class="token string">&quot;管理员&quot;</span><span class="token punctuation">,</span>
<span class="token string">&quot;到期时间&quot;</span><span class="token operator">:</span> <span class="token string">&quot;2023年1月09日0点0分&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>常见的token组成</strong>：UID（用户唯一的身份标识）、time（当前时间的时间戳）、sign（签名，token+请求数据进行几次md5之后的值）</li></ul><p>以后，用户与服务端通信的时候，都要发回这个<strong>JSON</strong> 对象。服务器完全只靠这个对象认定用户身份。<br> 当然，为了防止用户篡改数据，服务器在生成这个对象的时候，会给他加密一下，就是我们看到的一个长长的字符串。如图所示:</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311081447376.png" alt="image-20231108144737292" tabindex="0" loading="lazy"><figcaption>image-20231108144737292</figcaption></figure><p><strong>使用token：</strong></p><p>使用基于 <code>Token</code> 的身份验证方法，在服务端<strong>不需要</strong>存储用户的登录记录。大概的流程是这样的</p><p>1.前端使用用户名跟密码请求首次登录</p><p>2.后服务端收到请求，去验证用户名与密码是否正确</p><p>3.验证成功后，服务端会根据用户<code>id</code>、用户名、定义好的秘钥、过期时间生成一个 <code>Token</code>，再把这个 <code>Token</code> 发送给前端</p><p>4.前端收到 返回的<code>Token</code> ，把它存储起来，比如放在 <code>Cookie</code> 里或者 <code>Local Storage</code> 里</p><p>5.前端每次路由跳转，判断 <code>localStroage</code> 有无 <code>token</code> ，没有则跳转到登录页。有则请求获取用户信息，改变登录状态；</p><p>6.前端每次向服务端请求资源的时候需要在<strong>请求头</strong>里携带服务端签发的<code>Token</code></p><p>7.服务端收到请求，然后去验证前端请求里面带着的 <code>Token</code>。没有或者 <code>token</code> 过期，返回<code>401</code>。如果验证成功，就向前端返回请求的数据。</p><p>8.前端得到 <code>401</code> 状态码，重定向到登录页面。</p><h3 id="_5-3token和session的区别" tabindex="-1"><a class="header-anchor" href="#_5-3token和session的区别" aria-hidden="true">#</a> 5.3Token和Session的区别</h3><p>Session是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。</p><p>token是一种令牌，访问接口(API)时需要的凭证，也像古代进入到城里需要腰牌一样。token使服务器五状态化，不会存储会话信息。</p><p>token的安全性要好于session，每次请求都有签名，也就会出现每次的token都会变化，也可以防止一定的攻击。</p><h2 id="_6-什么是jwt" tabindex="-1"><a class="header-anchor" href="#_6-什么是jwt" aria-hidden="true">#</a> 6.什么是JWT</h2>`,54),u={href:"https://gaoziman.blog.csdn.net/article/details/132154578",target:"_blank",rel:"noopener noreferrer"},_=t('<h3 id="_6-1概述" tabindex="-1"><a class="header-anchor" href="#_6-1概述" aria-hidden="true">#</a> 6.1概述</h3><ul><li>JSON Web Token（简称JWT）是目前最流行的跨越认证解决方案。</li><li>是一种认证授权机制</li><li>JMT是在网络应用环境之间传递声明，而执行的一种基于json的开发标准</li></ul><h3 id="_6-2jwt的认证流程" tabindex="-1"><a class="header-anchor" href="#_6-2jwt的认证流程" aria-hidden="true">#</a> 6.2JWT的认证流程</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202311081503262.png" alt="image-20231108150301169" tabindex="0" loading="lazy"><figcaption>image-20231108150301169</figcaption></figure><h2 id="_7-token和jwt的区别" tabindex="-1"><a class="header-anchor" href="#_7-token和jwt的区别" aria-hidden="true">#</a> 7.Token和JWT的区别</h2><ul><li><p>Token需要查库验证token 是否有效，而JWT不用查库，直接在服务端进行校验,因为用户的信息及加密信息,和过期时间,都在JWT里，只要在服务端进行校验就行，并且校验也是JWT自己实现的。</p><h3 id="_7-1jwt基本原理" tabindex="-1"><a class="header-anchor" href="#_7-1jwt基本原理" aria-hidden="true">#</a> 7.1JWT基本原理</h3><p>JWT是json web token缩写。它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证JWTToken的正确性，只要正确即通过验证。</p><p>JWT包含三个部分： Header头部，Payload负载和Signature签名。由三部分生成JwtToken，三部分之间用“.”号做分割。 校验也是JWT内部自己实现的 ,并且可以将你存储时候的信息从JwtToken中取出来无须查库</p><p>客户端使用用户名跟密码请求登录</p><p>服务端收到请求，去验证用户名与密码</p><p>验证成功，服务端会签发一个JwtToken,无须存储到服务器，直接再把这个JwtToken发送给客户端</p><p>客户端收到JwtToken以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</p><p>客户端每次向服务端请求资源的时候需要带着服务端签发的JwtToken</p><p>服务端收到请求，验证密客户端请求里面带着的 JwtToken, 如果验证成功，就向客户端返回请求的数据</p><h3 id="_7-2token基本原理" tabindex="-1"><a class="header-anchor" href="#_7-2token基本原理" aria-hidden="true">#</a> 7.2Token基本原理</h3><p>Token(就是加密的字符串,使用MD5,等不可逆加密算法,一定要保证唯一性)</p><p>客户端使用用户名跟密码请求登录</p><p>服务端收到请求，去验证用户名与密码</p><p>验证成功，服务端会签发一个Token保存到(Session,redis,mysql…)中，然后再把这个 Token 发送给客户端</p><p>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</p><p>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</p><p>服务端收到请求，验证密客户端请求里面带着的 Token和服务器中保存的Token进行对比效验, 如果验证成功，就向客户端返回请求</p></li></ul><h2 id="_9-json-web-token-和-session-cookies-的对比" tabindex="-1"><a class="header-anchor" href="#_9-json-web-token-和-session-cookies-的对比" aria-hidden="true">#</a> 9.Json Web Token 和 Session Cookies 的对比</h2><p><code>JSON Web Token</code>，简称 <code>JWT</code>，它和 <code>Session</code>都可以为网站提供用户的身份认证，但是它们不一样。</p><h3 id="_9-1什么是-json-web-tokens" tabindex="-1"><a class="header-anchor" href="#_9-1什么是-json-web-tokens" aria-hidden="true">#</a> 9.1什么是 Json Web Tokens</h3><p>Json Web Token 的简称就是 JWT，通常可以称为 <code>Json 令牌</code>。它是<code>RFC 7519</code> 中定义的用于<code>安全的</code>将信息作为 <code>Json 对象</code>进行传输的一种形式。JWT 中存储的信息是经过<code>数字签名</code>的，因此可以被信任和理解。可以使用 HMAC 算法或使用 RSA/ECDSA 的公用/专用密钥对 JWT 进行签名。</p><p>使用 JWT 主要用来下面两点</p><ul><li><code>认证(Authorization)</code>：这是使用 JWT 最常见的一种情况，一旦用户登录，后面每个请求都会包含 JWT，从而允许用户访问该令牌所允许的路由、服务和资源。<code>单点登录</code>是当今广泛使用 JWT 的一项功能，因为它的开销很小。</li><li><code>信息交换(Information Exchange)</code>：JWT 是能够安全传输信息的一种方式。通过使用公钥/私钥对 JWT 进行签名认证。此外，由于签名是使用 <code>head</code> 和 <code>payload</code>计算的，因此你还可以验证内容是否遭到篡改。</li></ul><h3 id="_9-2session-cookies" tabindex="-1"><a class="header-anchor" href="#_9-2session-cookies" aria-hidden="true">#</a> 9.2Session Cookies</h3><p>Session Cookies 也称为<code>会话 Cookies</code>，在 Session Cookies 中，用户的登录状态会保存在<code>服务器</code>的<code>内存</code>中。当用户登录时，Session 就被服务端安全的创建。</p><p>在每次请求时，服务器都会从会话 Cookie 中读取 SessionId，如果服务端的数据和读取的 SessionId 相同，那么服务器就会发送响应给浏览器，允许用户登录。</p><h2 id="_10-参考文献" tabindex="-1"><a class="header-anchor" href="#_10-参考文献" aria-hidden="true">#</a> 10.参考文献</h2>',16),f={href:"https://docs.authing.cn/v2/concepts/authentication-vs-authorization.html",target:"_blank",rel:"noopener noreferrer"},b={href:"https://blog.csdn.net/qq_41895003/article/details/130567062",target:"_blank",rel:"noopener noreferrer"},m={href:"https://pdai.tech/md/arch/arch-z-session.html#session-stick",target:"_blank",rel:"noopener noreferrer"},C={href:"https://www.cltphp.com/detail-537.html",target:"_blank",rel:"noopener noreferrer"},T={href:"https://www.coonote.com/note/token-detail.html",target:"_blank",rel:"noopener noreferrer"},x=e("h2",{id:"_11-总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_11-总结","aria-hidden":"true"},"#"),o(" 11.总结")],-1),S=e("p",null,[o("以上便是本文的全部内容，本人才疏学浅，文章有什么错误的地方，欢迎大佬们批评指正！我是"),e("strong",null,"Leo"),o("，一个在互联网行业的小白，立志成为更好的自己。")],-1),w=e("p",null,[o("如果你想了解更多关于"),e("strong",null,"Leo"),o("，可以关注公众号-程序员Leo，后面文章会首先同步至公众号。")],-1);function y(J,W){const n=a("ExternalLinkIcon");return r(),d("div",null,[l,e("p",null,[o("永久性 "),e("a",p,[o("Cookie"),s(n)]),o(" 主要用于实现一些持久性的记住用户偏好设置、登录状态等功能。当用户再次访问该网站时，可以根据存储在永久性 "),e("a",h,[o("Cookie"),s(n)]),o(" 中的信息来恢复用户的个性化设置，提供更好的用户体验。同时，该类型的 "),e("a",k,[o("Cookie"),s(n)]),o(" 也常被用于追踪用户行为、广告定向等目的。")]),g,e("p",null,[o("这里只是简单概述一下关于JWT的相关内容，如果想更深入了解JWT，可以看我"),e("a",u,[o("这一篇博客"),s(n)]),o("。")]),_,e("ul",null,[e("li",null,[e("a",f,[o("https://docs.authing.cn/v2/concepts/authentication-vs-authorization.html"),s(n)])]),e("li",null,[e("a",b,[o("https://blog.csdn.net/qq_41895003/article/details/130567062"),s(n)])]),e("li",null,[e("a",m,[o("https://pdai.tech/md/arch/arch-z-session.html#session-stick"),s(n)])]),e("li",null,[e("a",C,[o("https://www.cltphp.com/detail-537.html"),s(n)])]),e("li",null,[e("a",T,[o("https://www.coonote.com/note/token-detail.html"),s(n)])])]),x,S,w])}const j=i(c,[["render",y],["__file","jwt-token-cookie-session-distinction.html.vue"]]);export{j as default};
