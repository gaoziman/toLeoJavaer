import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as i,c as n,a as e,b as a,d as c,e as s}from"./app-2feb0630.js";const h={},l=e("h2",{id:"_1-csrf概念",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_1-csrf概念","aria-hidden":"true"},"#"),a(" 1. CSRF概念")],-1),d=e("p",null,[e("strong",null,"CSRF定义："),a(" 跨站请求伪造（英语：Cross-site request forgery）是一种对网站的恶意利用，也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 CSRF跨站点请求伪造(Cross—Site Request Forgery) 跟XSS攻击一样，存在巨大的危害性。")],-1),g=e("blockquote",null,[e("p",null,[a("你可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。"),e("br"),a(" 简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。")])],-1),u=e("strong",null,"CSRF地位：",-1),f={href:"http://NYTimes.com",target:"_blank",rel:"noopener noreferrer"},p=s('<p><strong>对比XSS：</strong> 跟跨网站脚本(XSS)相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202308061026279.png" alt="image-20230806102653152" tabindex="0" loading="lazy"><figcaption>image-20230806102653152</figcaption></figure><p>从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><ul><li>1.登录受信任网站A，并在本地生成Cookie。</li><li>2.在不登出A的情况下，访问危险网站B。</li></ul><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202308052351281.png" alt="image-20230805235153045" tabindex="0" loading="lazy"><figcaption>image-20230805235153045</figcaption></figure><h2 id="_2-csrf攻击的攻击原理" tabindex="-1"><a class="header-anchor" href="#_2-csrf攻击的攻击原理" aria-hidden="true">#</a> 2. CSRF攻击的攻击原理</h2><blockquote><p>CSRF攻击一般的攻击原理是，攻击者向目标网站注入一个恶意的CSRF攻击URL地址，当用户访问某特定网页时，如果用户点击了该URL，那么攻击就触发了，我们可以在该恶意的URL对应的网页中，利用来向目标网站发生一个get请求，该请求会携带cookie信息，所以也就借用了用户的身份，也就是伪造了一个请求，该请求可以是目标网站中的用户有权限访问的任意请求。也可以使用JavaScript构造一个提交表单的post请求。比如构造一个转账的POST请求。</p></blockquote><h2 id="_3-如何防御" tabindex="-1"><a class="header-anchor" href="#_3-如何防御" aria-hidden="true">#</a> 3. 如何防御</h2><h3 id="_3-1-尽量使用-post-限制get" tabindex="-1"><a class="header-anchor" href="#_3-1-尽量使用-post-限制get" aria-hidden="true">#</a> 3.1 尽量使用 post，限制get</h3><blockquote><p>get 请求太容易被利用，攻击者可以构造一个 img 标签，通过图片资源嵌入恶意操作，而 img 又不能被过滤掉。所以接口最好限制为 POST 请求</p></blockquote><h3 id="_3-2-加验证码" tabindex="-1"><a class="header-anchor" href="#_3-2-加验证码" aria-hidden="true">#</a> 3.2 加验证码</h3><blockquote><p>POST 请求也不是绝对安全的，攻击者可以通过内嵌框架，构建隐藏表单，当我们访问这个网站时候，就自动将这个表单提交了，从而造成了一次 CSRF 的攻击。所以这时候我们可以采用加入验证码的方式，因为攻击者所构造出来的就是伪的请求，所以在某一次提交时候，让用户提交验证码，或者滑块验证，能够确保这是一次用户的行为，而非黑客行为。</p></blockquote><h3 id="_3-3-referer-check" tabindex="-1"><a class="header-anchor" href="#_3-3-referer-check" aria-hidden="true">#</a> 3.3 Referer Check</h3><blockquote><p>http 头存在一个字段 Referer，它能够记录当前一次请求的来源地址。什么意思呢，当我们访问正常网站时候，调用了某个接口例如 192.108.12.88/transferxxxxx ——&gt; 而攻击者构造的伪请求地址 113.132.44.53/gg.html 由于攻击者对正常网站实施 CSRF 攻击他只能在自己的站点里面进行构造请求，所以当 Referer 传过来是跟当前网站不同的域名，经过后端判断，如果 Referer 的值不是当前的网页就拒绝此次请求。</p></blockquote><h3 id="_3-4-anti-csrf-token" tabindex="-1"><a class="header-anchor" href="#_3-4-anti-csrf-token" aria-hidden="true">#</a> 3.4 Anti CSRF Token</h3><blockquote><p>CSRF 攻击之所以能够成功，主要是因为黑客能够完全伪造用户的请求，在这次请求中，用户的信息是存在 cookie 中的，所以黑客可以在不知道这些验证信息的情况下直接利用用户的 cookie 去跳过安全认证，我们要防御 CSRF 关键在于请求放入的时候黑客不能去伪造信息，并且这个信息不存在 cookie 之中，所以我们就可以在通过 http 的请求中或者是头信息中加入一个随机产生的 token，这个 token 就会存在服务端，通过拦截器去验证这个 token，如果请求头中不存在 token 或者 token 不正确，拦截器就会认为这是一次 CSRF 攻击，拒绝此次请求。</p></blockquote><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202312031906036.png" alt="公众号封面" tabindex="0" loading="lazy"><figcaption>公众号封面</figcaption></figure>',17);function _(k,m){const o=r("ExternalLinkIcon");return i(),n("div",null,[l,d,g,e("p",null,[u,a(" 是一种网络攻击方式，是互联网重大安全隐患之一，"),e("a",f,[a("NYTimes.com"),c(o)]),a("（纽约时报）、Metafilter，YouTube、Gmail和百度HI都受到过此类攻击。")]),p])}const R=t(h,[["render",_],["__file","what-is-csrf.html.vue"]]);export{R as default};
