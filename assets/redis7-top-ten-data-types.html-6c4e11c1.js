import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as r,c,a,b as i,d as e,w as d,e as t}from"./app-2feb0630.js";const h={},p=a("h2",{id:"_1-认识redis十大数据类型",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_1-认识redis十大数据类型","aria-hidden":"true"},"#"),i(" 1. 认识Redis十大数据类型")],-1),l={href:"https://redis.io/docs/data-types/",target:"_blank",rel:"noopener noreferrer"},m=t('<figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309062104357.png" alt="image-20230906210420929" tabindex="0" loading="lazy"><figcaption>image-20230906210420929</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309062103533.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>提前声明</strong></p><p>这里说的数据类型是<code>value</code>的数据类型，<code>key</code> 的类型都是字符串</p><h3 id="_1-1-redis字符串-string" tabindex="-1"><a class="header-anchor" href="#_1-1-redis字符串-string" aria-hidden="true">#</a> 1.1 redis字符串（String）</h3><p>String是redis最基本的数据类型，一个key对应一个value。</p>',6),u=t('<p>string类型是Redis最基本的数据类型，一个redis中字符串value<strong>最多可以是512M</strong></p><h3 id="_2-redis列表-list" tabindex="-1"><a class="header-anchor" href="#_2-redis列表-list" aria-hidden="true">#</a> 2.redis列表（List）</h3><p>Redis列表是最简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边），它的底层实际是个双端链表，最多可以包含2^32-1个元素（4294967295，每个列表超过40亿个元素）</p><h3 id="_3-redis哈希表-hash" tabindex="-1"><a class="header-anchor" href="#_3-redis哈希表-hash" aria-hidden="true">#</a> 3.redis哈希表（Hash）</h3><p>Redis Hash是一个string类型的field（字段）和value（值）的映射表，Hash特别适合用户存储对象。</p><p>Redis中每个Hash可以存储2^32-1个键值对（40多亿）</p><h3 id="_4-redis集合-set" tabindex="-1"><a class="header-anchor" href="#_4-redis集合-set" aria-hidden="true">#</a> 4.redis集合（Set）</h3><p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据，集合对象的编码可以是intset或者Hashtable。</p><p>Redis中Set集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><p>集合中最大的成员数为2^32-1（4294967295，每个集合可存储40多亿个成员）</p><h3 id="_5-redis有序集合-zset" tabindex="-1"><a class="header-anchor" href="#_5-redis有序集合-zset" aria-hidden="true">#</a> 5.redis有序集合（ZSet）</h3><p>zset(sorted set：有序集合)</p><ul><li>Redis <code>zset</code> 和<code>Set</code>一样也是<code>string</code>类型元素的集合，且不允许重复的成员。</li><li>不同的是每个元素都会关联一个<code>double</code>类型的分数，<code>Redis</code>正是通过分数来为集合中的成员进行从小到大的排序。</li><li>zset的成员是唯一的，但是分数（<code>score</code>）却可以重复。</li><li>zset集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。集合中最大的成员数是<code>2^.32-1</code></li></ul><h3 id="_6-redis地理空间-geo" tabindex="-1"><a class="header-anchor" href="#_6-redis地理空间-geo" aria-hidden="true">#</a> 6.redis地理空间（GEO）</h3><p>Redis GEO主要用于存储地理位置信息，并对存储的信息进行操作，包括：</p><ul><li>添加地理位置的坐标。</li><li>获取地理位置的坐标。</li><li>计算两个位置之间的距离。</li><li>根据用户给定的经纬度坐标来获取指定范围内的地址位置集合。</li></ul><p>7.redis基数统计（HyperLogLog）</p><p>HyperLogLog是用来做基数统计的算法，HyperLogLog的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需要的空间总是固定且是很小的。</p><p>在Redis里面，每个HyperLogLog键只需要花费12KB内存，就可以计算接近2^64个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为HyperLogLog只会根据输入元素来计算基数，而不会存储输入元素本身，所以HyperLogLog不能像集合那样，返回输入的各个元素。</p><h3 id="_8-redis位图-bitmap" tabindex="-1"><a class="header-anchor" href="#_8-redis位图-bitmap" aria-hidden="true">#</a> 8.redis位图（bitmap）</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309062103550.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由0和1状态表现的二进制位的bit数组</p><h3 id="_9-redis位域-bitfield" tabindex="-1"><a class="header-anchor" href="#_9-redis位域-bitfield" aria-hidden="true">#</a> 9.redis位域（bitfield）</h3><p>通过bitfield命令可以一次性操作多个比特位域(指的是连续的多个比特位)，它会执行一系列操作并返回一个响应数组，这个数组中的元素对应参数列表中的相应的执行结果。</p><p>说白了就是通过bitfield命令我们可以一次性对多个比特位域进行操作。</p><h3 id="_10-redis流-stream" tabindex="-1"><a class="header-anchor" href="#_10-redis流-stream" aria-hidden="true">#</a> 10.redis流（Stream）</h3><p>Redis Stream是Redis5.0版本新增加的数据结构。</p><p>Redis Stream主要用于消息队列（MQ，Message Queue），Redis本身就是一个Redis发布订阅（pub/sub）来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis宕机等，消息就会被丢弃。</p><p>简单来说发布订阅（pub/sub）可以分发消息，但无法记录历史消息。</p><p>而Redis Stream提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p><p><strong>Redis常见数据类型操作命令</strong></p>',32),f=a("strong",null,"英文官网：",-1),y={href:"https://redis.io/commands/",target:"_blank",rel:"noopener noreferrer"},z=a("strong",null,"中文：",-1),b={href:"http://www.redis.cn/commands.html",target:"_blank",rel:"noopener noreferrer"},x=t('<h2 id="_2-redis键" tabindex="-1"><a class="header-anchor" href="#_2-redis键" aria-hidden="true">#</a> 2. Redis键</h2><p>案例</p><h3 id="_2-1-keys" tabindex="-1"><a class="header-anchor" href="#_2-1-keys" aria-hidden="true">#</a> 2. 1 keys *</h3><p><strong>查看当前库所有的key</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309062111004.png" alt="image-20230906211123943" tabindex="0" loading="lazy"><figcaption>image-20230906211123943</figcaption></figure><h3 id="_2-2-exists-key" tabindex="-1"><a class="header-anchor" href="#_2-2-exists-key" aria-hidden="true">#</a> 2.2 exists key</h3><p><strong>判断某个key是否存在, 存在则返回1，不存在返回0</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309062111380.png" alt="image-20230906211144328" tabindex="0" loading="lazy"><figcaption>image-20230906211144328</figcaption></figure><h3 id="_2-3-type-key" tabindex="-1"><a class="header-anchor" href="#_2-3-type-key" aria-hidden="true">#</a> 2.3 type key</h3><p><strong>查看你的key是什么类型</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309062112076.png" alt="image-20230906211232025" tabindex="0" loading="lazy"><figcaption>image-20230906211232025</figcaption></figure><h3 id="_2-4-del-key" tabindex="-1"><a class="header-anchor" href="#_2-4-del-key" aria-hidden="true">#</a> 2.4 del key</h3><p><strong>删除指定的key数据</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309062114720.png" alt="image-20230906211407659" tabindex="0" loading="lazy"><figcaption>image-20230906211407659</figcaption></figure><h3 id="_2-5-unlink" tabindex="-1"><a class="header-anchor" href="#_2-5-unlink" aria-hidden="true">#</a> 2.5 unlink</h3><p><strong>非阻塞删除</strong>，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步中操作。</p><blockquote><p>del key 是原子的删除，只有删除成功了才会返回删除结果，如果是删除大key用del会将后面的操作都阻塞，而unlink key 不会阻塞，它会在后台异步删除数据。</p></blockquote><h3 id="_2-6-ttl-key" tabindex="-1"><a class="header-anchor" href="#_2-6-ttl-key" aria-hidden="true">#</a> 2.6 ttl key</h3><p><strong>查看还有多少秒过期，-1表示永不过期，-2表示已过期</strong></p><h3 id="_2-7-expire-key-秒钟" tabindex="-1"><a class="header-anchor" href="#_2-7-expire-key-秒钟" aria-hidden="true">#</a> 2.7 expire key 秒钟</h3><p><strong>为给定的key设置过期时间</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309062116184.png" alt="image-20230906211631076" tabindex="0" loading="lazy"><figcaption>image-20230906211631076</figcaption></figure><h3 id="_2-8-move-key-dbindex-0-15" tabindex="-1"><a class="header-anchor" href="#_2-8-move-key-dbindex-0-15" aria-hidden="true">#</a> 2.8 move key dbindex[0-15]</h3><p><strong>将当前数据库的key移动到给定的数据库DB当中</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309062122821.png" alt="image-20230906212209759" tabindex="0" loading="lazy"><figcaption>image-20230906212209759</figcaption></figure><h3 id="_2-9-select-dbindex" tabindex="-1"><a class="header-anchor" href="#_2-9-select-dbindex" aria-hidden="true">#</a> 2.9 select dbindex</h3><p><strong>切换数据库【0-15】，默认为0</strong></p><h3 id="_2-10-dbsize" tabindex="-1"><a class="header-anchor" href="#_2-10-dbsize" aria-hidden="true">#</a> 2.10 dbsize</h3><p><strong>查看当前数据库key的数量</strong></p><h3 id="_2-11-flushdb" tabindex="-1"><a class="header-anchor" href="#_2-11-flushdb" aria-hidden="true">#</a> 2.11 flushdb</h3><p><strong>清空当前库</strong></p><h3 id="_2-12-flushall" tabindex="-1"><a class="header-anchor" href="#_2-12-flushall" aria-hidden="true">#</a> 2.12 flushall</h3><p><strong>通杀全部库</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309062123178.png" alt="image-20230906212318127" tabindex="0" loading="lazy"><figcaption>image-20230906212318127</figcaption></figure><blockquote><p>注意 ： flushall 命令会删除所有库的数据，谨慎使用！！！</p></blockquote><h2 id="_3-数据类型命令及落地运用" tabindex="-1"><a class="header-anchor" href="#_3-数据类型命令及落地运用" aria-hidden="true">#</a> 3. 数据类型命令及落地运用</h2>',36),_=a("strong",null,"英文官网：",-1),k={href:"https://redis.io/commands/",target:"_blank",rel:"noopener noreferrer"},v=a("strong",null,"中文官网：",-1),R={href:"http://www.redis.cn/commands.html",target:"_blank",rel:"noopener noreferrer"},S=t('<p><strong>备注：</strong></p><p>1.命令不区分大小写，而key是区分大小写的</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309091501337.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>2.永远的帮助命令，help @类型</p><p>help @string</p><p>help @list</p><p>help @hash</p><p>help @hyperloglog</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309091501358.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_4-redis字符串-string" tabindex="-1"><a class="header-anchor" href="#_4-redis字符串-string" aria-hidden="true">#</a> 4. Redis字符串(String)</h2>',10),I=a("strong",null,"官网：",-1),D={href:"https://redis.io/docs/data-types/strings/",target:"_blank",rel:"noopener noreferrer"},E=t(`<figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309062104357.png" alt="image-20230906210420929" tabindex="0" loading="lazy"><figcaption>image-20230906210420929</figcaption></figure><p><code>String</code>是单值单 <code>value</code></p><p>String常见 <code>API</code> ：</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101412062.png" alt="image-20230910141225950" tabindex="0" loading="lazy"><figcaption>image-20230910141225950</figcaption></figure><h3 id="_1-最-常-用" tabindex="-1"><a class="header-anchor" href="#_1-最-常-用" aria-hidden="true">#</a> 1. 最 常 用：</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309091503481.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>返回值：</strong></p><p>设置成功则返回OK，返回 <code>nil</code> 为未执行Set命令，如不满足<code>NX</code>，<code>XX</code>条件等。</p><p>若使用GET参数，则返回该键原来的值，或在键不存在时nil。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101419174.png" alt="image-20230910141913060" tabindex="0" loading="lazy"><figcaption>image-20230910141913060</figcaption></figure><p>如何获得设置指定的 <strong>key</strong> 过期的 <strong>Unix</strong> 时间，单位为秒</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000L</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101424556.png" alt="image-20230910142456459" tabindex="0" loading="lazy"><figcaption>image-20230910142456459</figcaption></figure><h3 id="_2-同时设置-获取多个键值" tabindex="-1"><a class="header-anchor" href="#_2-同时设置-获取多个键值" aria-hidden="true">#</a> 2.同时设置/获取多个键值</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101425583.png" alt="image-20230910142525476" tabindex="0" loading="lazy"><figcaption>image-20230910142525476</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101430754.png" alt="image-20230910143000665" tabindex="0" loading="lazy"><figcaption>image-20230910143000665</figcaption></figure><h3 id="_3-获取指定区间范围内的值" tabindex="-1"><a class="header-anchor" href="#_3-获取指定区间范围内的值" aria-hidden="true">#</a> 3.获取指定区间范围内的值</h3><p><code>setrange</code></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101432850.png" alt="image-20230910143221785" tabindex="0" loading="lazy"><figcaption>image-20230910143221785</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101436068.png" alt="image-20230910143626994" tabindex="0" loading="lazy"><figcaption>image-20230910143626994</figcaption></figure><p><code>getrange</code></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101432467.png" alt="image-20230910143245397" tabindex="0" loading="lazy"><figcaption>image-20230910143245397</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101438721.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_4-数值增减" tabindex="-1"><a class="header-anchor" href="#_4-数值增减" aria-hidden="true">#</a> 4.数值增减</h3><p><strong>一定要是数据才能进行加减</strong></p><blockquote><p>递增数字：INCR key</p><p>增加指定的整数：INCRBY key increment</p><p>递减数值：DECR key</p><p>减少指定的整数：DECRBY key decrement</p></blockquote><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101441698.png" alt="image-20230910144128608" tabindex="0" loading="lazy"><figcaption>image-20230910144128608</figcaption></figure><h3 id="_5-获取字符串长度和内容追加" tabindex="-1"><a class="header-anchor" href="#_5-获取字符串长度和内容追加" aria-hidden="true">#</a> 5.获取字符串长度和内容追加</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101442632.png" alt="image-20230910144218549" tabindex="0" loading="lazy"><figcaption>image-20230910144218549</figcaption></figure><p>获取字符串长度：<code>strlen key</code></p><p>字符串内容追加：<code>append key value</code></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101445392.png" alt="image-20230910144505283" tabindex="0" loading="lazy"><figcaption>image-20230910144505283</figcaption></figure><h3 id="_6-分布式锁" tabindex="-1"><a class="header-anchor" href="#_6-分布式锁" aria-hidden="true">#</a> 6.分布式锁</h3><p>setnx key value</p><p>setex(set with expire) 键秒值/setnx(set if not exist)</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309091503045.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_7-getset-先get再set" tabindex="-1"><a class="header-anchor" href="#_7-getset-先get再set" aria-hidden="true">#</a> 7.getset(先get再set)</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101446625.png" alt="image-20230910144633552" tabindex="0" loading="lazy"><figcaption>image-20230910144633552</figcaption></figure><p>getset：将给定key的值设为value，并返回key的旧值(old value)。</p><p>简单一句话：<strong>先get然后立即set</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101446201.png" alt="image-20230910144610147" tabindex="0" loading="lazy"><figcaption>image-20230910144610147</figcaption></figure><h2 id="_5-redis列表-list" tabindex="-1"><a class="header-anchor" href="#_5-redis列表-list" aria-hidden="true">#</a> 5. Redis列表(List)</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101353859.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>List属于 <strong>单key多value</strong></p><p>List API</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101518321.png" alt="image-20230910151851211" tabindex="0" loading="lazy"><figcaption>image-20230910151851211</figcaption></figure><p>简单说明：一个双端链表的结构，容量是2的32次方减1个元素大概40多亿，主要功能有<code>push</code>/<code>pop</code>等，一般用在栈、队列、消息队列等场景。left、right都可以插入添加。</p><ul><li>如果键不存在，创建新的链表；</li><li>如果键已存在，新增内容；</li><li>如果值全移除，对应的键也就消失了</li><li>它的底层实际上就是个双向链表，对两端的作性能很高，通过索引下标的操作中间的节点性能会较差。</li></ul><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101353913.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_1-lpush-rpush-lrange" tabindex="-1"><a class="header-anchor" href="#_1-lpush-rpush-lrange" aria-hidden="true">#</a> 1.lpush/rpush/lrange</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101519357.png" alt="image-20230910151925285" tabindex="0" loading="lazy"><figcaption>image-20230910151925285</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101519474.png" alt="image-20230910151938400" tabindex="0" loading="lazy"><figcaption>image-20230910151938400</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101519285.png" alt="image-20230910151955209" tabindex="0" loading="lazy"><figcaption>image-20230910151955209</figcaption></figure><p>注意：<strong>没有rrange</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101524993.png" alt="image-20230910152426922" tabindex="0" loading="lazy"><figcaption>image-20230910152426922</figcaption></figure><h3 id="_2-lpop-rpop" tabindex="-1"><a class="header-anchor" href="#_2-lpop-rpop" aria-hidden="true">#</a> 2.lpop/rpop</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101524266.png" alt="image-20230910152441194" tabindex="0" loading="lazy"><figcaption>image-20230910152441194</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101525072.png" alt="image-20230910152512998" tabindex="0" loading="lazy"><figcaption>image-20230910152512998</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101527359.png" alt="image-20230910152726280" tabindex="0" loading="lazy"><figcaption>image-20230910152726280</figcaption></figure><h3 id="_3-lindex-按照索引下标获得元素-从上到下" tabindex="-1"><a class="header-anchor" href="#_3-lindex-按照索引下标获得元素-从上到下" aria-hidden="true">#</a> 3.lindex，按照索引下标获得元素（从上到下）</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101528275.png" alt="image-20230910152804200" tabindex="0" loading="lazy"><figcaption>image-20230910152804200</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101530946.png" alt="image-20230910153015864" tabindex="0" loading="lazy"><figcaption>image-20230910153015864</figcaption></figure><h3 id="_4-llen-获取list列表中元素的个数" tabindex="-1"><a class="header-anchor" href="#_4-llen-获取list列表中元素的个数" aria-hidden="true">#</a> 4.llen,获取List列表中元素的个数</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101530623.png" alt="image-20230910153032543" tabindex="0" loading="lazy"><figcaption>image-20230910153032543</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101530216.png" alt="image-20230910153050140" tabindex="0" loading="lazy"><figcaption>image-20230910153050140</figcaption></figure><h3 id="_5-lrem-key-数字n-给定值v1" tabindex="-1"><a class="header-anchor" href="#_5-lrem-key-数字n-给定值v1" aria-hidden="true">#</a> 5.lrem key 数字N 给定值v1</h3><p>解释：删除N个值等于v1的元素</p><p>从left往right删除2个值等于v1的元素，返回的值为实际删除的数量</p><p>LREM list3 0 值，表示删除全部给定的值，零个就是全部值</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101353475.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_6-ltrim-key-开始index-结束index" tabindex="-1"><a class="header-anchor" href="#_6-ltrim-key-开始index-结束index" aria-hidden="true">#</a> 6.ltrim key 开始index 结束index</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101531322.png" alt="image-20230910153118250" tabindex="0" loading="lazy"><figcaption>image-20230910153118250</figcaption></figure><p>截取指定范围的值后在赋值给key</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101532650.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_7-rpoplpush-源列表-目的列表" tabindex="-1"><a class="header-anchor" href="#_7-rpoplpush-源列表-目的列表" aria-hidden="true">#</a> 7.rpoplpush 源列表 目的列表</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101533113.png" alt="image-20230910153309028" tabindex="0" loading="lazy"><figcaption>image-20230910153309028</figcaption></figure><p>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101534333.png" alt="image-20230910153423242" tabindex="0" loading="lazy"><figcaption>image-20230910153423242</figcaption></figure><h3 id="_8-lset-key-index-value" tabindex="-1"><a class="header-anchor" href="#_8-lset-key-index-value" aria-hidden="true">#</a> 8.lset key index value</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101534771.png" alt="image-20230910153451694" tabindex="0" loading="lazy"><figcaption>image-20230910153451694</figcaption></figure><p>让指定数组集合的小标位置值替换成新值</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101535091.png" alt="image-20230910153542980" tabindex="0" loading="lazy"><figcaption>image-20230910153542980</figcaption></figure><h3 id="_9-linsert-key-before-after-已有值-插入的新值" tabindex="-1"><a class="header-anchor" href="#_9-linsert-key-before-after-已有值-插入的新值" aria-hidden="true">#</a> 9.linsert key before/after 已有值 插入的新值</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101536791.png" alt="image-20230910153605700" tabindex="0" loading="lazy"><figcaption>image-20230910153605700</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101601490.png" alt="image-20230910160136407" tabindex="0" loading="lazy"><figcaption>image-20230910160136407</figcaption></figure><h2 id="_6-redis哈希-hash" tabindex="-1"><a class="header-anchor" href="#_6-redis哈希-hash" aria-hidden="true">#</a> 6. Redis哈希(Hash)</h2><p>KV模式不变，但V是一个键值对 <code>Map&lt;String, Map&lt;Object, Object&gt;&gt;</code></p><p><strong>API</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101608395.png" alt="image-20230910160833304" tabindex="0" loading="lazy"><figcaption>image-20230910160833304</figcaption></figure><h3 id="_1-hset-hget-hmset-hmget-hgetall-hdel" tabindex="-1"><a class="header-anchor" href="#_1-hset-hget-hmset-hmget-hgetall-hdel" aria-hidden="true">#</a> 1. hset/hget/hmset/hmget/hgetall/hdel</h3><h4 id="_1-1-hset" tabindex="-1"><a class="header-anchor" href="#_1-1-hset" aria-hidden="true">#</a> 1.1 hset</h4><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102007403.png" alt="image-20230910200758290" tabindex="0" loading="lazy"><figcaption>image-20230910200758290</figcaption></figure><h4 id="_1-2-hget" tabindex="-1"><a class="header-anchor" href="#_1-2-hget" aria-hidden="true">#</a> 1.2 hget</h4><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102009203.png" alt="image-20230910200949115" tabindex="0" loading="lazy"><figcaption>image-20230910200949115</figcaption></figure><h4 id="_1-3-hmset" tabindex="-1"><a class="header-anchor" href="#_1-3-hmset" aria-hidden="true">#</a> 1.3 hmset</h4><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102009053.png" alt="image-20230910200958959" tabindex="0" loading="lazy"><figcaption>image-20230910200958959</figcaption></figure><h4 id="_1-4-hmget" tabindex="-1"><a class="header-anchor" href="#_1-4-hmget" aria-hidden="true">#</a> 1.4 hmget</h4><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102010741.png" alt="image-20230910201016661" tabindex="0" loading="lazy"><figcaption>image-20230910201016661</figcaption></figure><h4 id="_1-5-hgetall" tabindex="-1"><a class="header-anchor" href="#_1-5-hgetall" aria-hidden="true">#</a> 1.5 hgetall</h4><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102010849.png" alt="image-20230910201027775" tabindex="0" loading="lazy"><figcaption>image-20230910201027775</figcaption></figure><h4 id="_1-6-hdel" tabindex="-1"><a class="header-anchor" href="#_1-6-hdel" aria-hidden="true">#</a> 1.6 hdel</h4><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102010069.png" alt="image-20230910201040947" tabindex="0" loading="lazy"><figcaption>image-20230910201040947</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102022873.png" alt="image-20230910202257771" tabindex="0" loading="lazy"><figcaption>image-20230910202257771</figcaption></figure><h3 id="_2-hlen" tabindex="-1"><a class="header-anchor" href="#_2-hlen" aria-hidden="true">#</a> 2. hlen</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102025135.png" alt="image-20230910202512054" tabindex="0" loading="lazy"><figcaption>image-20230910202512054</figcaption></figure><p>获取某个key内的全部数量</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102024486.png" alt="image-20230910202417406" tabindex="0" loading="lazy"><figcaption>image-20230910202417406</figcaption></figure><h3 id="_3-hexists-key-在key里面的某个值的key" tabindex="-1"><a class="header-anchor" href="#_3-hexists-key-在key里面的某个值的key" aria-hidden="true">#</a> 3.hexists key 在key里面的某个值的key</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102025960.png" alt="image-20230910202521876" tabindex="0" loading="lazy"><figcaption>image-20230910202521876</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102024032.png" alt="image-20230910202449961" tabindex="0" loading="lazy"><figcaption>image-20230910202449961</figcaption></figure><h3 id="_4-hkeys-hvals" tabindex="-1"><a class="header-anchor" href="#_4-hkeys-hvals" aria-hidden="true">#</a> 4. hkeys/hvals</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102025859.png" alt="image-20230910202539785" tabindex="0" loading="lazy"><figcaption>image-20230910202539785</figcaption></figure><p>hkeys key 查询出所有key对应的子key值</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102025635.png" alt="image-20230910202550564" tabindex="0" loading="lazy"><figcaption>image-20230910202550564</figcaption></figure><p>hvals key 查询出所有key对应的子key的value值</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102026794.png" alt="image-20230910202626714" tabindex="0" loading="lazy"><figcaption>image-20230910202626714</figcaption></figure><h3 id="_5-hincrby-hincrbyfloat" tabindex="-1"><a class="header-anchor" href="#_5-hincrby-hincrbyfloat" aria-hidden="true">#</a> 5. hincrby/hincrbyfloat</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102026449.png" alt="image-20230910202648354" tabindex="0" loading="lazy"><figcaption>image-20230910202648354</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102026840.png" alt="image-20230910202658740" tabindex="0" loading="lazy"><figcaption>image-20230910202658740</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102029323.png" alt="image-20230910202910165" tabindex="0" loading="lazy"><figcaption>image-20230910202910165</figcaption></figure><h3 id="_6-hsetnx" tabindex="-1"><a class="header-anchor" href="#_6-hsetnx" aria-hidden="true">#</a> 6. hsetnx</h3><p>不存在赋值，存在了无效</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102029639.png" alt="image-20230910202941572" tabindex="0" loading="lazy"><figcaption>image-20230910202941572</figcaption></figure><h2 id="_7-redis集合-set" tabindex="-1"><a class="header-anchor" href="#_7-redis集合-set" aria-hidden="true">#</a> 7. Redis集合(Set)</h2><p>单值<code>多value</code>，且<code>无重复</code></p><p><strong>API</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101604199.png" alt="image-20230910160428090" tabindex="0" loading="lazy"><figcaption>image-20230910160428090</figcaption></figure><h3 id="_1-sadd-key-member" tabindex="-1"><a class="header-anchor" href="#_1-sadd-key-member" aria-hidden="true">#</a> 1. SADD key member</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102031202.png" alt="image-20230910203102087" tabindex="0" loading="lazy"><figcaption>image-20230910203102087</figcaption></figure><p>添加元素，可以多次向同一个key中设置不同值，不会覆盖之前的值</p><h3 id="_2-smembers-key" tabindex="-1"><a class="header-anchor" href="#_2-smembers-key" aria-hidden="true">#</a> 2. SMEMBERS key</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102031176.png" alt="image-20230910203123078" tabindex="0" loading="lazy"><figcaption>image-20230910203123078</figcaption></figure><p>遍历集合中的所有元素</p><h3 id="_3-sismember-key-member" tabindex="-1"><a class="header-anchor" href="#_3-sismember-key-member" aria-hidden="true">#</a> 3. SISMEMBER key member</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102032660.png" alt="image-20230910203202534" tabindex="0" loading="lazy"><figcaption>image-20230910203202534</figcaption></figure><p>判断元素是否在集合中</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102037820.png" alt="image-20230910203707716" tabindex="0" loading="lazy"><figcaption>image-20230910203707716</figcaption></figure><h3 id="_4-srem-key-member" tabindex="-1"><a class="header-anchor" href="#_4-srem-key-member" aria-hidden="true">#</a> 4. SREM key member</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102032258.png" alt="image-20230910203238159" tabindex="0" loading="lazy"><figcaption>image-20230910203238159</figcaption></figure><p>删除元素</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102038543.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_5-scard" tabindex="-1"><a class="header-anchor" href="#_5-scard" aria-hidden="true">#</a> 5.scard</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102033380.png" alt="image-20230910203304295" tabindex="0" loading="lazy"><figcaption>image-20230910203304295</figcaption></figure><p>获取集合里面的元素个数</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102040468.png" alt="image-20230910204018382" tabindex="0" loading="lazy"><figcaption>image-20230910204018382</figcaption></figure><h3 id="_6-srandmember-key-数字" tabindex="-1"><a class="header-anchor" href="#_6-srandmember-key-数字" aria-hidden="true">#</a> 6.SRANDMEMBER key [数字]</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102041274.png" alt="image-20230910204140181" tabindex="0" loading="lazy"><figcaption>image-20230910204140181</figcaption></figure><p>从集合中随机<code>展现设置的数字个数元素</code>，元素不删除</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102042509.png" alt="image-20230910204251361" tabindex="0" loading="lazy"><figcaption>image-20230910204251361</figcaption></figure><h3 id="_7-spop-key-数字" tabindex="-1"><a class="header-anchor" href="#_7-spop-key-数字" aria-hidden="true">#</a> 7.SPOP key [数字]</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102043182.png" alt="image-20230910204308099" tabindex="0" loading="lazy"><figcaption>image-20230910204308099</figcaption></figure><p>从集合中<code>随机弹出</code>一个元素，出一个<code>删除</code>一个</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102044765.png" alt="image-20230910204421632" tabindex="0" loading="lazy"><figcaption>image-20230910204421632</figcaption></figure><h3 id="_8-smove-key1-key2" tabindex="-1"><a class="header-anchor" href="#_8-smove-key1-key2" aria-hidden="true">#</a> 8. smove key1 key2</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102045121.png" alt="image-20230910204506010" tabindex="0" loading="lazy"><figcaption>image-20230910204506010</figcaption></figure><p>将key1里已存在的某个值赋给key2</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102046582.png" alt="image-20230910204625458" tabindex="0" loading="lazy"><figcaption>image-20230910204625458</figcaption></figure><h3 id="_9-集合运算-集合的差集运算a-b" tabindex="-1"><a class="header-anchor" href="#_9-集合运算-集合的差集运算a-b" aria-hidden="true">#</a> 9.集合运算-集合的差集运算A-B</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102044617.png" alt="image-20230910204447526" tabindex="0" loading="lazy"><figcaption>image-20230910204447526</figcaption></figure><p>属于A但是不属于B的元素构成的集合</p><p>SDIFF key [key ...]，可以计算多个元素的差集</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102048958.png" alt="image-20230910204858847" tabindex="0" loading="lazy"><figcaption>image-20230910204858847</figcaption></figure><h3 id="_10-集合运算-集合的并集运算a∪b" tabindex="-1"><a class="header-anchor" href="#_10-集合运算-集合的并集运算a∪b" aria-hidden="true">#</a> 10.集合运算-集合的并集运算A∪B</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102050331.png" alt="image-20230910205059224" tabindex="0" loading="lazy"><figcaption>image-20230910205059224</figcaption></figure><p>属于A或者属于B的元素构成的集合</p><p>SUNION key [key ...]</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102049284.png" alt="image-20230910204942210" tabindex="0" loading="lazy"><figcaption>image-20230910204942210</figcaption></figure><h3 id="_11-集合运算-集合的交集运算a∩b" tabindex="-1"><a class="header-anchor" href="#_11-集合运算-集合的交集运算a∩b" aria-hidden="true">#</a> 11.集合运算-集合的交集运算A∩B</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102051371.png" alt="image-20230910205110280" tabindex="0" loading="lazy"><figcaption>image-20230910205110280</figcaption></figure><p>属于A同时也属于B的共同拥有的元素构成的集合</p><p>SINTER key [key ...]</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102050721.png" alt="image-20230910205006591" tabindex="0" loading="lazy"><figcaption>image-20230910205006591</figcaption></figure><p><strong>SINTERCARD numkeys key 【key ...】【LIMIT limit】</strong></p><p>numkeys 的具体值由输入的key个数决定</p><p>SINTERCARD 为redis7新命令，它不返回结果集，而是返回结果的基数。返回由所有给定集合的交集产生的集合的基数</p><p>基数的词语解释: 用于表示事物个数的数</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102051241.png" alt="image-20230910205154159" tabindex="0" loading="lazy"><figcaption>image-20230910205154159</figcaption></figure><h2 id="_8-redis有序集合zset-sorted-set" tabindex="-1"><a class="header-anchor" href="#_8-redis有序集合zset-sorted-set" aria-hidden="true">#</a> 8. Redis有序集合Zset(sorted set)</h2><blockquote><p>在 set 基础上，每个val值前加一个score分数值。之前set是k1 v1 v2 v3，现在zset是 k1 score1 v1 score2 v2</p></blockquote><p><strong>API</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102053781.png" alt="image-20230910205337647" tabindex="0" loading="lazy"><figcaption>image-20230910205337647</figcaption></figure><p>向有序集合中加入一个元素和该元素的分数</p><h3 id="_1-zadd-key-score-member-score-member" tabindex="-1"><a class="header-anchor" href="#_1-zadd-key-score-member-score-member" aria-hidden="true">#</a> 1.ZADD key score member [score member ...]</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102054534.png" alt="image-20230910205403432" tabindex="0" loading="lazy"><figcaption>image-20230910205403432</figcaption></figure><p>添加元素</p><h3 id="_2-zrange-key-start-stop-withscores" tabindex="-1"><a class="header-anchor" href="#_2-zrange-key-start-stop-withscores" aria-hidden="true">#</a> 2.ZRANGE key start stop [WITHSCORES]</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102055526.png" alt="image-20230910205509412" tabindex="0" loading="lazy"><figcaption>image-20230910205509412</figcaption></figure><p>按照元素分数从小到大的顺序返回索引从start到stop之间的所有元素</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102059274.png" alt="image-20230910205929183" tabindex="0" loading="lazy"><figcaption>image-20230910205929183</figcaption></figure><h3 id="_3-zrevrange-key-start-stop-withscores" tabindex="-1"><a class="header-anchor" href="#_3-zrevrange-key-start-stop-withscores" aria-hidden="true">#</a> 3.zrevrange key start stop [WITHSCORES]</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102059101.png" alt="image-20230910205951995" tabindex="0" loading="lazy"><figcaption>image-20230910205951995</figcaption></figure><p>反转集合，按照元素分数从大到小的顺序返回索引从start到stop之间的所有元素</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102107529.png" alt="image-20230910210724452" tabindex="0" loading="lazy"><figcaption>image-20230910210724452</figcaption></figure><h3 id="_4-zrangebyscore-key-min-max-【withscores】【limit-offset-count】" tabindex="-1"><a class="header-anchor" href="#_4-zrangebyscore-key-min-max-【withscores】【limit-offset-count】" aria-hidden="true">#</a> 4.ZRANGEBYSCORE key min max 【WITHSCORES】【LIMIT offset count】</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102101415.png" alt="image-20230910210123269" tabindex="0" loading="lazy"><figcaption>image-20230910210123269</figcaption></figure><p>获取指定分数范围的元素，可以在min和max前面加个(，表示不包含</p><p>limit作用是返回限制，limit开始下标步，一共多少步</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102111046.png" alt="image-20230910211107927" tabindex="0" loading="lazy"><figcaption>image-20230910211107927</figcaption></figure><h3 id="_5-zscore-key-member" tabindex="-1"><a class="header-anchor" href="#_5-zscore-key-member" aria-hidden="true">#</a> 5.ZSCORE key member</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102101188.png" alt="image-20230910210141099" tabindex="0" loading="lazy"><figcaption>image-20230910210141099</figcaption></figure><p>获取元素的分数</p><h3 id="_6-zcard-key" tabindex="-1"><a class="header-anchor" href="#_6-zcard-key" aria-hidden="true">#</a> 6.ZCARD key</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102101732.png" alt="image-20230910210151637" tabindex="0" loading="lazy"><figcaption>image-20230910210151637</figcaption></figure><p>获取集合中元素的数量</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102111901.png" alt="image-20230910211149821" tabindex="0" loading="lazy"><figcaption>image-20230910211149821</figcaption></figure><h3 id="_7-zrem-key-member-member" tabindex="-1"><a class="header-anchor" href="#_7-zrem-key-member-member" aria-hidden="true">#</a> 7. zrem key member [member ...]</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102103781.png" alt="image-20230910210313660" tabindex="0" loading="lazy"><figcaption>image-20230910210313660</figcaption></figure><p>某个score对应的value值，作用是删除元素</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102114212.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_8-zincrby-key-increment-member" tabindex="-1"><a class="header-anchor" href="#_8-zincrby-key-increment-member" aria-hidden="true">#</a> 8.ZINCRBY key increment member</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102103509.png" alt="image-20230910210348414" tabindex="0" loading="lazy"><figcaption>image-20230910210348414</figcaption></figure><p>增加某个元素的分数</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102115186.png" alt="image-20230910211534103" tabindex="0" loading="lazy"><figcaption>image-20230910211534103</figcaption></figure><h3 id="_9-zcount-key-min-max" tabindex="-1"><a class="header-anchor" href="#_9-zcount-key-min-max" aria-hidden="true">#</a> 9.ZCOUNT key min max</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102104146.png" alt="image-20230910210408056" tabindex="0" loading="lazy"><figcaption>image-20230910210408056</figcaption></figure><p>获得指定分数内的元素个数</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102116911.png" alt="image-20230910211658790" tabindex="0" loading="lazy"><figcaption>image-20230910211658790</figcaption></figure><h3 id="_10-zmpop-numkeys-key-key-min-max-count-count" tabindex="-1"><a class="header-anchor" href="#_10-zmpop-numkeys-key-key-min-max-count-count" aria-hidden="true">#</a> 10.ZMPOP numkeys key [key ...] MIN|MAX [COUNT count]</h3><p>从键名列表中的<strong>第一个非空排序集中弹出一个或多个元素</strong>，他们是成员分数对</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102119473.png" alt="image-20230910211911396" tabindex="0" loading="lazy"><figcaption>image-20230910211911396</figcaption></figure><h3 id="_11-zrank-key-member-withscore" tabindex="-1"><a class="header-anchor" href="#_11-zrank-key-member-withscore" aria-hidden="true">#</a> 11.zrank key member [withscore]</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102105076.png" alt="image-20230910210522979" tabindex="0" loading="lazy"><figcaption>image-20230910210522979</figcaption></figure><p>作用是通过子value获得下标值</p><h3 id="_12-zrevrank-key-member-withscore" tabindex="-1"><a class="header-anchor" href="#_12-zrevrank-key-member-withscore" aria-hidden="true">#</a> 12.zrevrank key member [withscore]</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102105737.png" alt="image-20230910210545637" tabindex="0" loading="lazy"><figcaption>image-20230910210545637</figcaption></figure><p>作用是通过子value逆序获得下标值</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309102121539.png" alt="image-20230910212153456" tabindex="0" loading="lazy"><figcaption>image-20230910212153456</figcaption></figure><h2 id="_9-redis位图-bitmap" tabindex="-1"><a class="header-anchor" href="#_9-redis位图-bitmap" aria-hidden="true">#</a> 9. Redis位图(bitmap)</h2><p>在平时开发过程中，经常会有一些 bool 类型数据需要存取。比如记录用户一年内签到的次数，签了是 1，没签是 0。如果使用 key-value 来存储，那么每个用户都要记录 365 次，当用户成百上亿时，需要的存储空间将非常巨大。为了解决这个问题，Redis 提供了位图结构。</p><p>位图（bitmap）同样属于 string 数据类型。Redis 中一个字符串类型的值最多能存储 512 MB 的内容，每个字符串由多个字节组成，每个字节又由 8 个 Bit 位组成。位图结构正是使用“位”来实现存储的，它通过将比特位设置为 0 或 1来达到数据存取的目的，这大大增加了 value 存储数量，它存储上限为<code>2^32 </code>。</p><p>位图本质上就是一个普通的字节串，也就是 bytes 数组。您可以使用 <code>getbit/setbit</code> 命令来处理这个位数组，位图的结构如下所示：</p><figure><img src="http://c.biancheng.net/uploads/allimg/210913/1333395108-0.gif" alt="位数组" tabindex="0" loading="lazy"><figcaption>位数组</figcaption></figure><p>位图适用于一些特定的应用场景，比如用户签到次数、或者登录次数等。上图是表示一位用户 10 天内来网站的签到次数，1 代表签到，0 代表未签到，这样可以很轻松地统计出用户的活跃程度。相比于直接使用字符串而言，位图中的每一条记录仅占用一个 bit 位，从而大大降低了内存空间使用率。</p><p>Redis 官方也做了一个实验，他们模拟了一个拥有 1 亿 2 千 8 百万用户的系统，然后使用 Redis 的位图来统计 <strong>日均用户数量</strong>，最终所用时间的约为 50ms，且仅仅占用 16 MB内存。</p><p>一句话：<strong>由0和1状态表现的二进制位的bit数组</strong></p><h3 id="_1-需求" tabindex="-1"><a class="header-anchor" href="#_1-需求" aria-hidden="true">#</a> 1. 需求：</h3><ol><li>用户是否登陆过Y、N，比如软件的每日签到功能</li><li>电影、广告是否被点击播放过</li><li>钉钉打卡上下班，签到统计</li><li>统计用户在某网站的活跃度</li></ol><h3 id="_2-bitmap是什么" tabindex="-1"><a class="header-anchor" href="#_2-bitmap是什么" aria-hidden="true">#</a> 2. bitmap是什么?</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101354055.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>说明：用<code>String</code>类型作为底层数据结构实现的一种统计二值状态的数据类型</p><p>位图本质是数组，它是基于String数据类型的按位的操作。该数组由多个二进制位组成，每个二进制位都对应一个偏移量（我们称之为一个索引）。</p><p><code>Bitmap</code>支持的最大位数是2<sup>32位，它可以极大的节约存储空间，使用512M内存就可以存储多达42.9亿的字节信息(2</sup>32=4294967296)</p><h3 id="_3-bitmap可以用来干嘛" tabindex="-1"><a class="header-anchor" href="#_3-bitmap可以用来干嘛" aria-hidden="true">#</a> 3. bitmap可以用来干嘛？</h3><p>用于状态统计，Y、N类似 <code>AtomicBoolean</code></p><h3 id="_4-原理" tabindex="-1"><a class="header-anchor" href="#_4-原理" aria-hidden="true">#</a> 4. 原理</h3><p>某网站要统计一个用户一年的签到记录，若用 String 类型存储，则需要 365 个键值对。若使用位图存储，用户签到就存 1，否则存 0。最后会生成 11010101... 这样的存储结果，其中每天的记录只占一位，一年就是 365 位，约为 46 个字节。如果只想统计用户签到的天数，那么统计 1 的个数即可。</p><p>位图操作的优势，相比于字符串而言，它不仅效率高，而且还非常的节省空间。</p><p>Redis 的位数组是自动扩展的，如果设置了某个偏移位置超出了现有的内容范围，位数组就会自动扩充。</p><p>下面设置一个名为 a 的 key，我们对这个 key 进行位图操作，使得 a 的对应的 value 变为“he”。</p><p>首先我们分别获取字符“h”和字符“e”的八位二进制码，如下所示：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&gt;&gt;&gt; bin(ord(&quot;h&quot;))
&#39;0b1101000&#39;
&gt;&gt;&gt; bin(ord(&quot;e&quot;))
&#39;0b1100101&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，只要对需值为 1 的位进行操作即可。如下图所示：</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309111115474.gif" alt="bitmap位图应用" tabindex="0" loading="lazy"><figcaption>bitmap位图应用</figcaption></figure><p>把 h 和 e 的二进制码连接在一起，第一位的下标是 0，依次递增至 15，然后将数字为 1 的位置标记出来，得到 1/2/4/9/10/13/15，我们把这组数字称为位的“偏置数”，最后按照上述偏置数对字符 a 进行如下位图操作。注意，key 的初始二进制位全部为 0。</p><h3 id="_5-基本命令" tabindex="-1"><a class="header-anchor" href="#_5-基本命令" aria-hidden="true">#</a> 5. 基本命令</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101354066.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_1-setbit-key-offset-value" tabindex="-1"><a class="header-anchor" href="#_1-setbit-key-offset-value" aria-hidden="true">#</a> 1.setbit key offset value</h4><p>setbit 键偏移位 只能零或者1</p><p><strong>Bitmap的偏移量从零开始计算的</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101354071.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309112020538.png" alt="image-20230911202012402" tabindex="0" loading="lazy"><figcaption>image-20230911202012402</figcaption></figure><h4 id="_2-getbit-key-offset" tabindex="-1"><a class="header-anchor" href="#_2-getbit-key-offset" aria-hidden="true">#</a> 2.getbit key offset</h4><p>获取键偏移位的值</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309112020171.png" alt="image-20230911202050086" tabindex="0" loading="lazy"><figcaption>image-20230911202050086</figcaption></figure><h4 id="_3-strlen-key" tabindex="-1"><a class="header-anchor" href="#_3-strlen-key" aria-hidden="true">#</a> 3.strlen key</h4><p>统计字节数占用多少</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309112022416.png" alt="image-20230911202234321" tabindex="0" loading="lazy"><figcaption>image-20230911202234321</figcaption></figure><p>不是字符串长度而是占据几个字节，超过8位后自己按照8位一组<strong>一byte</strong>再扩容</p><h4 id="_4-bitcount-key-start-end-byte-bit" tabindex="-1"><a class="header-anchor" href="#_4-bitcount-key-start-end-byte-bit" aria-hidden="true">#</a> 4.bitcount key [start end [byte|bit]]</h4><p>全部键里面包含有1的有多少个</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309112022671.png" alt="image-20230911202257570" tabindex="0" loading="lazy"><figcaption>image-20230911202257570</figcaption></figure><h4 id="_5-bitop-operation-and-or-xor-not-destkey-key-key" tabindex="-1"><a class="header-anchor" href="#_5-bitop-operation-and-or-xor-not-destkey-key-key" aria-hidden="true">#</a> 5.bitop operation(AND|OR|XOR|NOT) destkey key [key ...]</h4><p>案例：连续2天都签到的用户数量</p><p>假如某个网站或者系统，它的用户有1000W，我们可以使用Redis的<code>HASH</code>结构和<code>bitmap</code>结构做个用户id和位置的映射</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309112034034.png" alt="image-20230911203452911" tabindex="0" loading="lazy"><figcaption>image-20230911203452911</figcaption></figure><h2 id="_10-redis基数统计-hyperloglog" tabindex="-1"><a class="header-anchor" href="#_10-redis基数统计-hyperloglog" aria-hidden="true">#</a> 10. Redis基数统计(HyperLogLog)</h2><h3 id="_1-需求-1" tabindex="-1"><a class="header-anchor" href="#_1-需求-1" aria-hidden="true">#</a> 1. 需求：</h3><p>用户搜索网站关键词的数量</p><p>统计用户每天搜索不同词条个数</p><p>统计某个网站的UV、统计某个文章的UV</p><p>什么是UV？</p><p><strong>Unique Visitor</strong>，独立访客，一般理解为客户端IP，<strong>需要去重考虑</strong></p><h3 id="_2-hyperloglog是什么" tabindex="-1"><a class="header-anchor" href="#_2-hyperloglog是什么" aria-hidden="true">#</a> 2. HyperLogLog是什么</h3><p>去重复统计功能的基数估计算法-就是HyperLogLog</p><div class="language-tex line-numbers-mode" data-ext="tex"><pre class="language-tex"><code>Redis在2.8.9版本添加了HyperLogLog 结构。
Redis HyperLogLog是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。
在Redis里面，每个 HyperLogLog键只需要花费12KB内存，就可以计算接近2^64个不同元素的基数。这和计算基数时，元素越多耗费
内存就越多的集合形成鲜明对比。
但是，因为HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身，所以HyperLogLog不能像集合那样，返回输入的各个元素。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>基数</strong>：是一种数据集，去重复后的真实个数</p><div class="language-tex line-numbers-mode" data-ext="tex"><pre class="language-tex"><code>(全集)=<span class="token punctuation">{</span>2,4,6,8,77,39,4,8,10<span class="token punctuation">}</span>
去掉重复的内容
基数=<span class="token punctuation">{</span>2,4,6,8,77,39,10<span class="token punctuation">}</span> = 7
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基数统计：用于统计一个集合中不重复的元素个数，就是对集合去重复后剩余元素的计算。</p><p>一句话：去重脱水后的真实数据</p><h3 id="_3-基本命令" tabindex="-1"><a class="header-anchor" href="#_3-基本命令" aria-hidden="true">#</a> 3. 基本命令</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309111119587.png" alt="image-20230911111916490" tabindex="0" loading="lazy"><figcaption>image-20230911111916490</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309112038073.png" alt="image-20230911203836964" tabindex="0" loading="lazy"><figcaption>image-20230911203836964</figcaption></figure><h2 id="_11-redis地理空间-geo" tabindex="-1"><a class="header-anchor" href="#_11-redis地理空间-geo" aria-hidden="true">#</a> 11. Redis地理空间(GEO)</h2><h3 id="_1-geo简介" tabindex="-1"><a class="header-anchor" href="#_1-geo简介" aria-hidden="true">#</a> 1. GEO简介：</h3><p>移动互联网时代LBS应用越来越多，交友软件中附近的小姐姐、外卖软件中附近的美食店铺、高德地图附近的核酸检查点等等，那这种附近各种形形色色的XXX地址位置选择是如何实现的?<br> 地球上的地理位置是使用二维的经纬度表示，经度范围(-180,180]，纬度范围(-90，90]，只要我们确定一个点的经纬度就可以取得他在地球的位置。<br> 例如滴滴打车，最直观的操作就是实时记录更新各个车的位置，<br> 然后当我们要找车时，在数据库中查找距离我们(坐标x0,y0)附近r公里范围内部的车辆</p><p>使用如下SQL即可:</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> taxi <span class="token keyword">from</span> position <span class="token keyword">where</span> x0<span class="token operator">-</span>r<span class="token operator">&lt;</span> X <span class="token operator">&lt;</span> x0 <span class="token operator">+</span> r <span class="token operator">and</span> y0<span class="token operator">-</span>r<span class="token operator">&lt;</span> y <span class="token operator">&lt;</span> y0<span class="token operator">+</span>r
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是这样会有什么问题呢?</p><ol><li>查询性能问题，如果并发高，数据量大这种查询是要搞垮数据库的</li><li>这个查询的是一个矩形访问，而不是以我为中心r公里为半径的圆形访问。</li><li>精准度的问题，我们知道地球不是平面坐标系，而是一个圆球，这种矩形计算在长距离计算时会有很大误差</li></ol><h3 id="_2-geo原理" tabindex="-1"><a class="header-anchor" href="#_2-geo原理" aria-hidden="true">#</a> 2. GEO原理</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101355430.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Redis在 <code>3.2</code> 版本以后增加了地址位置的处理</p><h3 id="_3-geo命令" tabindex="-1"><a class="header-anchor" href="#_3-geo命令" aria-hidden="true">#</a> 3. GEO命令</h3><h4 id="_1-geoadd-key-longitude-latitude-member-longitude-latitude-member" tabindex="-1"><a class="header-anchor" href="#_1-geoadd-key-longitude-latitude-member-longitude-latitude-member" aria-hidden="true">#</a> 1.GEOADD key longitude latitude member [longitude latitude member]</h4><p>多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的key中</p><p>命令：GEOADD city 116.403963 39.915119 &quot;天安门&quot; 116.403414 39.924091 &quot;故宫&quot; 116.024067 40.362639 &quot;长城&quot;</p><p>geo类型实际上是zset，可以使用zset相关的命令对其进行遍历，如果遍历出现中文乱码可以使用如下命令：redis-cli --raw</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309112042252.png" alt="image-20230911204251128" tabindex="0" loading="lazy"><figcaption>image-20230911204251128</figcaption></figure><h4 id="_2-geopos-key-member-member" tabindex="-1"><a class="header-anchor" href="#_2-geopos-key-member-member" aria-hidden="true">#</a> 2.GEOPOS key member [member]</h4><p>从键里面返回所有指定名称(member )元素的位置（经度和纬度），不存在返回nil</p><p>GEOPOS city 天安门 故宫 长城</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309112045182.png" alt="image-20230911204545099" tabindex="0" loading="lazy"><figcaption>image-20230911204545099</figcaption></figure><h4 id="_3-geodist-key-member1-member2-m-km-ft-mi" tabindex="-1"><a class="header-anchor" href="#_3-geodist-key-member1-member2-m-km-ft-mi" aria-hidden="true">#</a> 3.GEODIST key member1 member2 [M|KM|FT|MI]</h4><p>返回两个给定位置之间的距离</p><ul><li>m-米</li><li>km-千米</li><li>ft-英寸</li><li>mi-英里</li></ul><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309112048871.png" alt="image-20230911204822752" tabindex="0" loading="lazy"><figcaption>image-20230911204822752</figcaption></figure><h4 id="_4-georadius-key-longitude-latitude-radius" tabindex="-1"><a class="header-anchor" href="#_4-georadius-key-longitude-latitude-radius" aria-hidden="true">#</a> 4.GEORADIUS key longitude latitude radius</h4><p>以给定的经纬度为中心，返回与中心的距离不超过给定最大距离的所有元素位置</p><p>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。<br> WITHCOORD: 将位置元素的经度和维度也一并返回。<br> WITHHASH:以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试，实际中的作用并不大<br> COUNT 限定返回的记录数。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309112049523.png" alt="image-20230911204915408" tabindex="0" loading="lazy"><figcaption>image-20230911204915408</figcaption></figure><h4 id="_5-georadiusbymember" tabindex="-1"><a class="header-anchor" href="#_5-georadiusbymember" aria-hidden="true">#</a> 5.GEORADIUSBYMEMBER</h4><p>跟GEORADIUS类似</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309112050434.png" alt="image-20230911205034351" tabindex="0" loading="lazy"><figcaption>image-20230911205034351</figcaption></figure><h4 id="_6-geohash" tabindex="-1"><a class="header-anchor" href="#_6-geohash" aria-hidden="true">#</a> 6.GEOHASH</h4><p>返回一个或多个位置元素的GEOhash表示</p><p>geohash 算法生成的base32编码值，3维变2维变1维</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309112051754.png" alt="image-20230911205104660" tabindex="0" loading="lazy"><figcaption>image-20230911205104660</figcaption></figure><h2 id="_12-redis流-stream" tabindex="-1"><a class="header-anchor" href="#_12-redis流-stream" aria-hidden="true">#</a> 12. Redis流(Stream)</h2><h3 id="_1-stream是什么" tabindex="-1"><a class="header-anchor" href="#_1-stream是什么" aria-hidden="true">#</a> 1. Stream是什么</h3><p>Redis5.0 之前的痛点，Redis消息队列的2种方案：</p><ol><li><p>List实现消息队列，List实现方式其实就是点对点的模式</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356770.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li><li><p>Pub/Sub</p></li></ol><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356781.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Redis5.0版本新增了一个更强大的数据结构---Stream</p><p>一句话：Stream流就是Redis版的MQ消息中间件+阻塞队列</p><h3 id="_2-stream能干嘛" tabindex="-1"><a class="header-anchor" href="#_2-stream能干嘛" aria-hidden="true">#</a> 2. Stream能干嘛</h3><p>实现消息队列，它支持消息的持久化、支持自动生成全局唯一ID、支持ack确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠</p><h3 id="_3-stream底层结构和原理说明" tabindex="-1"><a class="header-anchor" href="#_3-stream底层结构和原理说明" aria-hidden="true">#</a> 3. Stream底层结构和原理说明</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356793.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一个<strong>消息链表</strong>，将所有加入的消息都串起来，每个消息都有一个唯一的ID和对应的内容</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356805.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_4-stream基本命令" tabindex="-1"><a class="header-anchor" href="#_4-stream基本命令" aria-hidden="true">#</a> 4. Stream基本命令</h3><h4 id="_1-队列相关指令" tabindex="-1"><a class="header-anchor" href="#_1-队列相关指令" aria-hidden="true">#</a> 1. 队列相关指令</h4><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356801.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_2-消费组相关指令" tabindex="-1"><a class="header-anchor" href="#_2-消费组相关指令" aria-hidden="true">#</a> 2. 消费组相关指令</h4><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356829.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>XINFO GROUPS 打印消费组的详细信息</p><p>XINFO STREAM 打印stream的详细信息</p><h4 id="_3-四个特殊符号" tabindex="-1"><a class="header-anchor" href="#_3-四个特殊符号" aria-hidden="true">#</a> 3. 四个特殊符号</h4><table><thead><tr><th>- +</th><th>最小和最大可能出现的Id</th></tr></thead><tbody><tr><td>$</td><td>$表示只消费新的消息，当前流中最大的Id，可用于将要到来的信息</td></tr><tr><td>&gt;</td><td>用于XREADGROUP命令，表示迄今还没有发送给组中使用者的信息，会更新消费者组的最后Id</td></tr><tr><td>*</td><td>用于XADD命令，让系统自动生成Id</td></tr></tbody></table><p>基本命令代码实操</p><p>Redis流实例演示</p><h3 id="_5-stream队列相关命令" tabindex="-1"><a class="header-anchor" href="#_5-stream队列相关命令" aria-hidden="true">#</a> 5. Stream队列相关命令</h3><h4 id="_1-xadd" tabindex="-1"><a class="header-anchor" href="#_1-xadd" aria-hidden="true">#</a> 1.XADD</h4><p>添加消息到队列末尾，消息ID必须要比上一个ID大，默认用星号表示自动生成ID；* 用于XADD命令中，让系统自动生成ID；</p><p>XADD用于向Stream队列中添加消息，如果指定的Stream队列不存在，则该命令执行时会新建一个Stream队列</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356529.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>生成的消息ID，有两部分组成，毫秒时间戳-该毫秒内产生的第一条消息</p><p>// * 表示服务器自动生成MessageID(类似MySQL里面主键auto_increment)，后面顺序跟着一堆业务key/value</p><table><thead><tr><th>信息条目指的是序列号，在相同的毫秒下序列号从0开始递增，序列号是64位长度，理论上在同一毫秒内生成的数据量无法到达这个级别，因此不用担心序列号会不够用。milisecondsTime指的是Redis节点服务器的本地时间，如果存在当前的毫秒时间截比以前已经存在的数据的时间戳小的话(本地时间钟后跳)，那么系统将会采用以前相同的毫秒创建新的ID，也即redis 在增加信息条目时会检查当前 id 与上一条目的 id，自动纠正错误的情况，一定要保证后面的 id 比前面大，.个流中信息条目的ID必须是单调增的，这是流的基础。</th></tr></thead><tbody><tr><td>客户端显示传入规则:<br>Redis对于ID有强制要求，格式必须是<strong>时间戳-自增Id</strong>这样的方式，且后续ID不能小于前一个ID</td></tr><tr><td>Stream的消息内容，也就是图中的Messaget它的结构类似Hash结构，以kev-value的形式存在</td></tr></tbody></table><h4 id="_2-xrange-key-start-end-count-count" tabindex="-1"><a class="header-anchor" href="#_2-xrange-key-start-end-count-count" aria-hidden="true">#</a> 2.XRANGE key start end [COUNT count]</h4><p>用于获取消息列表（可以指定范围），忽略删除的消息</p><p>start 表示开始值，-代表最小值</p><p>end 表示结束值，+代表最大值</p><p>count 表示最多获取多少个值</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356547.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_3-xrevrange-key-end-start-count-count" tabindex="-1"><a class="header-anchor" href="#_3-xrevrange-key-end-start-count-count" aria-hidden="true">#</a> 3.XREVRANGE key end start [COUNT count]</h4><p>根据ID降序输出</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356585.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_4-xdel-key-id-id" tabindex="-1"><a class="header-anchor" href="#_4-xdel-key-id-id" aria-hidden="true">#</a> 4.XDEL key id [id ...]</h4><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356802.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_5-xlen-key" tabindex="-1"><a class="header-anchor" href="#_5-xlen-key" aria-hidden="true">#</a> 5.XLEN key</h4><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356808.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_6-xtrim-key-maxlen-minid" tabindex="-1"><a class="header-anchor" href="#_6-xtrim-key-maxlen-minid" aria-hidden="true">#</a> 6.XTRIM key MAXLEN|MINID</h4><p>用于对Stream的长度进行截取，如超长会进行截取</p><p>MAXLEN 允许的最大长度，对流进行修剪限制长度</p><p>MINID 允许的最小id，从某个id值开始比该id值小的将会被抛弃</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356842.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_7-xread-count-count-block-milliseconds-streams-key-key-id-id" tabindex="-1"><a class="header-anchor" href="#_7-xread-count-count-block-milliseconds-streams-key-key-id-id" aria-hidden="true">#</a> 7.XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]</h4><p>可以读取多个key</p><p><strong>用于获取消息(阻塞/非阻塞)</strong></p><p>​ 只会返回大于指定ID的消息，COUNT最多读取多少条消息；BLOCK是否以阻塞的方式读取消息，默认不阻塞，如果milliseconds设置为0，表示永远阻塞</p><p><strong>非阻塞</strong></p><ul><li><p>$表特殊ID，表示以当前Stream已经存储的最大的ID作为最后一个ID，当前Stream中不存在大于当前最大ID的消息，因此此时返回nil</p></li><li><p>0-0代表从最小的ID开始获取Stream中的消息，当不指定count，将会返回Stream中的所有消息，注意也可以使用0 (00/000也都是可以的)</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356879.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li></ul><p><strong>阻塞</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356121.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>小总结</strong>（类似Java里面的阻塞队列）</p><p>Stream的基础方法，使用XADD存入消息和XREAD循环阻塞读取消息的方式可以实现简易版的消息队列</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356236.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_6-消费组相关指令" tabindex="-1"><a class="header-anchor" href="#_6-消费组相关指令" aria-hidden="true">#</a> 6. 消费组相关指令</h3><h4 id="_1-xgroup-create-key-group-id" tabindex="-1"><a class="header-anchor" href="#_1-xgroup-create-key-group-id" aria-hidden="true">#</a> 1.XGROUP CREATE key group id|</h4><p>用于创建消费组</p><p>xgroup create mystream group $</p><p>xgroup create mystream groupB 0</p><p>$表示从Stream尾部开始消费</p><p>0表示从Stream头部开始消费</p><p>创建消费组的时候必须指定ID，ID为0表示从头开始消费，为$表示只消费新消息</p><p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356274.png" alt="" loading="lazy">&#39;&#39;</p><h4 id="_2-xreadgroup-group-group" tabindex="-1"><a class="header-anchor" href="#_2-xreadgroup-group-group" aria-hidden="true">#</a> 2.XREADGROUP GROUP group</h4><p>&quot;&gt;&quot;，表示从第一条尚未被消费的消息开始读取</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356374.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>消费组groupA内的消费者consumer1从mystream消息队列中读取所有消息</p><p>但是，<strong>不同消费组</strong>的消费者可以消费同一条消息</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356557.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>消费组的目的？</strong></p><p>让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分部的</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356590.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>重点问题</strong></p><p>基于 Stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息?</p><p>Streams 会自动使用内部队列(也称为 PENDING List)留存消费组里每个消费者读取的消息保底措施，直到消费者使用 XACK命令通知 Streams&quot;消息已经处理完成”。<br> 消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 XACK 命令确认消息已经被消费完成</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356621.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_3-xpending" tabindex="-1"><a class="header-anchor" href="#_3-xpending" aria-hidden="true">#</a> 3.XPENDING</h4><p>查询每个消费组内所有消费组[已读取、但尚未确认]的消息</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356809.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查看某个消费组具体读取了那些数据</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356930.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_4-xack-key-group-id-id" tabindex="-1"><a class="header-anchor" href="#_4-xack-key-group-id-id" aria-hidden="true">#</a> 4.XACK key group id [id...]</h4><p>向消息队列确认消息处理已完成</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356136.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_7-xinfo-用于打印stream-consumer-group的详细信息" tabindex="-1"><a class="header-anchor" href="#_7-xinfo-用于打印stream-consumer-group的详细信息" aria-hidden="true">#</a> 7. XINFO 用于打印Stream\\Consumer\\Group的详细信息</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101356159.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_13-redis位域-bitfield" tabindex="-1"><a class="header-anchor" href="#_13-redis位域-bitfield" aria-hidden="true">#</a> 13. Redis位域(bitfield)</h2><h3 id="_1-bitfield能干嘛" tabindex="-1"><a class="header-anchor" href="#_1-bitfield能干嘛" aria-hidden="true">#</a> 1. bitfield能干嘛</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101357453.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>位域修改、溢出控制</p><h3 id="_2-bitfield是什么" tabindex="-1"><a class="header-anchor" href="#_2-bitfield是什么" aria-hidden="true">#</a> 2. bitfield是什么</h3><p>将一个redis字符串看作是<strong>一个由二进制位组成的数组</strong>并能对变长位宽和任意没有字节对齐的指定整型位域进行寻址和修改</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101357458.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-bitfield命令" tabindex="-1"><a class="header-anchor" href="#_3-bitfield命令" aria-hidden="true">#</a> 3. bitfield命令</h3>`,429),L={href:"https://ascii.org.cn",target:"_blank",rel:"noopener noreferrer"},A=t('<h4 id="_1-bitfield-key-get-type-offset" tabindex="-1"><a class="header-anchor" href="#_1-bitfield-key-get-type-offset" aria-hidden="true">#</a> 1.BITFIELD key [GET type offset]</h4><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101357480.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_2-bitfield-key-set-type-offstet-value" tabindex="-1"><a class="header-anchor" href="#_2-bitfield-key-set-type-offstet-value" aria-hidden="true">#</a> 2.BITFIELD key set type offstet value</h4><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101357470.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="_3-bitfield-key-incrby-type-offset-increment" tabindex="-1"><a class="header-anchor" href="#_3-bitfield-key-incrby-type-offset-increment" aria-hidden="true">#</a> 3.BITFIELD key [INCRBY type offset increment]</h4><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101357474.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果偏移量后面的值发生溢出（大于127），redis对此也有对应的溢出控制，默认情况下，INCRBY使用WRAP参数</p><h4 id="_4-溢出控制-overflow-wrap-sat-fail" tabindex="-1"><a class="header-anchor" href="#_4-溢出控制-overflow-wrap-sat-fail" aria-hidden="true">#</a> 4.溢出控制 OVERFLOW [WRAP|SAT|FAIL]</h4><p>WRAP:使用回绕(wrap around)方法处理有符号整数和无符号整数溢出情况</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101357500.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>SAT:使用饱和计算(saturation arithmetic)方法处理溢出，下溢计算的结果为最小的整数值，而上溢计算的结果为最大的整数值</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101357109.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>fail:命令将拒绝执行那些会导致上溢或者下溢情况出现的计算，并向用户返回空值表示计算未被执行</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/cisyam/202309101357182.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202312031906036.png" alt="公众号封面" tabindex="0" loading="lazy"><figcaption>公众号封面</figcaption></figure>',15);function O(N,T){const n=s("ExternalLinkIcon"),g=s("font");return r(),c("div",null,[p,a("p",null,[i("官网: "),a("a",l,[i("https://redis.io/docs/data-types/"),e(n)])]),m,a("p",null,[i("string类型是 "),e(g,{color:"red"},{default:d(()=>[i("二进制安全的")]),_:1}),i("，意思是redis的string可以包含任何数据，比如jpg图片或者序列化的对象。")]),u,a("p",null,[f,i(),a("a",y,[i("https://redis.io/commands/"),e(n)])]),a("p",null,[z,i(),a("a",b,[i("http://www.redis.cn/commands.html"),e(n)])]),x,a("p",null,[_,i(),a("a",k,[i("https://redis.io/commands/"),e(n)])]),a("p",null,[v,i(),a("a",R,[i("http://www.redis.cn/commands.html"),e(n)])]),S,a("p",null,[I,i(),a("a",D,[i("https://redis.io/docs/data-types/strings/"),e(n)])]),E,a("p",null,[i("Ascii码表："),a("a",L,[i("https://ascii.org.cn"),e(n)])]),A])}const B=o(h,[["render",O],["__file","redis7-top-ten-data-types.html.vue"]]);export{B as default};
