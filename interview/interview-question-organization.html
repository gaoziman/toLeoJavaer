<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.67" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://manamn.space/toLeoJavaer/interview/interview-question-organization.html"><meta property="og:site_name" content="ToLeoJavaer"><meta property="og:title" content="面试题整理"><meta property="og:description" content="1、Java 语言有哪些特点 1. 简单易学； 2. 面向对象（封装，继承，多态）； 3. 平台无关性（ Java 虚拟机实现平台无关性）； 4. 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 5. 可靠性； 6. 安全性； 7. 支持网络编程并且很方便（..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-12-03T11:52:46.000Z"><meta property="article:author" content="Leo"><meta property="article:tag" content="面试题"><meta property="article:published_time" content="2023-09-12T00:00:00.000Z"><meta property="article:modified_time" content="2023-12-03T11:52:46.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"面试题整理","image":[""],"datePublished":"2023-09-12T00:00:00.000Z","dateModified":"2023-12-03T11:52:46.000Z","author":[{"@type":"Person","name":"Leo","url":"https://manamn.space/"}]}</script><meta name="robots" content="all"><meta name="author" content="Leo"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><meta name="keywords" content="basic, 多线程, JVM, 虚拟机, 数据库, database, spring, redis, mybaits, 系统设计, 分布式, RPC, 高可用, 高并发"><meta name="apple-mobile-web-app-capable" content="yes"><script>var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?7f3ff39fbb72aabacbcc5072e15b827e";
          var s = document.getElementsByTagName("script")[0]; 
          s.parentNode.insertBefore(hm, s);
        })();</script><script>const btw = new BTWPlugin();
        btw.init({
        id: 'container',
        blogId: '32863-1711898538696-276',
        name: '程序员Leo',
        qrcode: 'https://gaoziman.oss-cn-hangzhou.aliyuncs.com/Leo100/202309232030341.png',
        keyword: 'vip',
    });</script><script src="https://readmore.openwrite.cn/js/readmore.js"></script><link rel="stylesheet" href="no-chttps://cdn.jsdelivr.net/npm/@docsearch/css@3ache"><script src="https://cdn.jsdelivr.net/npm/@docsearch/js@3"></script><title>面试题整理 | ToLeoJavaer</title><meta name="description" content="1、Java 语言有哪些特点 1. 简单易学； 2. 面向对象（封装，继承，多态）； 3. 平台无关性（ Java 虚拟机实现平台无关性）； 4. 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 5. 可靠性； 6. 安全性； 7. 支持网络编程并且很方便（...">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/toLeoJavaer/assets/style-c76b2b5b.css" as="style"><link rel="stylesheet" href="/toLeoJavaer/assets/style-c76b2b5b.css">
    <link rel="modulepreload" href="/toLeoJavaer/assets/app-2feb0630.js"><link rel="modulepreload" href="/toLeoJavaer/assets/interview-question-organization.html-6527ba50.js"><link rel="modulepreload" href="/toLeoJavaer/assets/plugin-vue_export-helper-c27b6911.js"><link rel="modulepreload" href="/toLeoJavaer/assets/interview-question-organization.html-40bd4294.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="vp-link vp-brand vp-brand" href="/toLeoJavaer/"><img class="vp-nav-logo" src="/toLeoJavaer/logo.png" alt="ToLeoJavaer"><!----><span class="vp-site-name hide-in-pad">ToLeoJavaer</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a aria-label="文档指南" class="vp-link nav-link nav-link" href="/toLeoJavaer/home.html"><span class="font-icon icon iconfont icon-kuangjia" style=""></span>文档指南<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="微服务"><span class="title"><span class="font-icon icon iconfont icon-cloud" style=""></span>微服务</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>重要知识点</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a aria-label="了解SpringCloud微服务架构" class="vp-link nav-link nav-link" href="/toLeoJavaer/service/star/understanding-springcloud-microservices.html"><span class="font-icon icon iconfont icon-circle-info" style=""></span>了解SpringCloud微服务架构<!----></a></li><li class="dropdown-subitem"><a aria-label="认识SpringCloud核心组件" class="vp-link nav-link nav-link" href="/toLeoJavaer/service/star/understanding-core-components-springcloud.html"><span class="font-icon icon iconfont icon-circle-info" style=""></span>认识SpringCloud核心组件<!----></a></li><li class="dropdown-subitem"><a aria-label="Ribbon和Nacos注册中心" class="vp-link nav-link nav-link" href="/toLeoJavaer/service/star/ribbon-and-Nacos-Service-registry.html"><span class="font-icon icon iconfont icon-circle-info" style=""></span>Ribbon和Nacos注册中心<!----></a></li><li class="dropdown-subitem"><a aria-label="远程调用openFeign整合" class="vp-link nav-link nav-link" href="/toLeoJavaer/service/star/remote-call-to-openFeign-integration.html"><span class="font-icon icon iconfont icon-circle-info" style=""></span>远程调用openFeign整合<!----></a></li><li class="dropdown-subitem"><a aria-label="微服务整合Gateway网关" class="vp-link nav-link nav-link" href="/toLeoJavaer/service/star/micro-service-integration-gateway.html"><span class="font-icon icon iconfont icon-circle-info" style=""></span>微服务整合Gateway网关<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a aria-label="文库汇总" class="vp-link nav-link nav-link" href="/toLeoJavaer/document-all.html"><span class="font-icon icon iconfont icon-wenku" style=""></span>文库汇总<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="网站相关"><span class="title"><span class="font-icon icon iconfont icon-zuozhe" style=""></span>网站相关</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a aria-label="关于作者" class="vp-link nav-link nav-link" href="/toLeoJavaer/about-the-author/"><span class="font-icon icon iconfont icon-zuozhe1" style=""></span>关于作者<!----></a></li></ul></button></div></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/gaoziman/toLeoJavaer" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" class="outlook-button" tabindex="-1" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索本站" autocomplete="off" spellcheck="false" value><!----></form><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-star" style=""></span><span class="vp-sidebar-title">必看</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable active" type="button"><span class="font-icon icon iconfont icon-book3" style=""></span><span class="vp-sidebar-title">面试准备</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><!--[--><a aria-label="面试题整理" class="vp-link nav-link active vp-sidebar-link vp-sidebar-page active nav-link active vp-sidebar-link vp-sidebar-page active" href="/toLeoJavaer/interview/interview-question-organization.html"><span class="font-icon icon iconfont icon-circle-info" style=""></span>面试题整理<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、Java 语言有哪些特点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、java-语言有哪些特点"><!---->1、Java 语言有哪些特点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、JVM、JRE和JDK的关系" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、jvm、jre和jdk的关系"><!---->2、JVM、JRE和JDK的关系<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、字符型常量和字符串常量的区别?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、字符型常量和字符串常量的区别"><!---->3、字符型常量和字符串常量的区别?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、注释有哪几种" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、注释有哪几种"><!---->4、注释有哪几种<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、标识符和关键字的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、标识符和关键字的区别"><!---->5、标识符和关键字的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、自增自减运算符" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、自增自减运算符"><!---->6、自增自减运算符<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、continue、break 和 return 的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、continue、break-和-return-的区别"><!---->7、continue、break 和 return 的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、静态方法为什么不能调用非静态成员?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_8、静态方法为什么不能调用非静态成员"><!---->8、静态方法为什么不能调用非静态成员?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="9、静态方法和实例方法有何不同？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_9、静态方法和实例方法有何不同"><!---->9、静态方法和实例方法有何不同？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="10、重载和重写的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_10、重载和重写的区别"><!---->10、重载和重写的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="11、== 和 equals() 的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_11、-和-equals-的区别"><!---->11、== 和 equals() 的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="12、hashCode() 与 equals()" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_12、hashcode-与-equals"><!---->12、hashCode() 与 equals()<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="13、为什么重写 equals() 时必须重写 hashCode() 方法？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_13、为什么重写-equals-时必须重写-hashcode-方法"><!---->13、为什么重写 equals() 时必须重写 hashCode() 方法？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="14、基本数据类型" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_14、基本数据类型"><!---->14、基本数据类型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="15、包装类型的常量池技术" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_15、包装类型的常量池技术"><!---->15、包装类型的常量池技术<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="16、内部类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_16、内部类"><!---->16、内部类<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="什么是内部类？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#什么是内部类"><!---->什么是内部类？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="内部类的分类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#内部类的分类"><!---->内部类的分类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="静态内部类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#静态内部类"><!---->静态内部类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="成员内部类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#成员内部类"><!---->成员内部类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="局部内部类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#局部内部类"><!---->局部内部类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="匿名内部类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#匿名内部类"><!---->匿名内部类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="内部类的优点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#内部类的优点"><!---->内部类的优点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="为什么局部内部类和厦名内部类只能访问局部final变量？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#为什么局部内部类和厦名内部类只能访问局部final变量"><!---->为什么局部内部类和厦名内部类只能访问局部final变量？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="17、成员变量与局部变量的区别有哪些？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_17、成员变量与局部变量的区别有哪些"><!---->17、成员变量与局部变量的区别有哪些？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="18、创建一个对象用什么运算符?对象实体与对象引用有何不同?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_18、创建一个对象用什么运算符-对象实体与对象引用有何不同"><!---->18、创建一个对象用什么运算符?对象实体与对象引用有何不同?<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="19、对象的相等与指向他们的引用相等,两者有什么不同?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_19、对象的相等与指向他们的引用相等-两者有什么不同"><!---->19、对象的相等与指向他们的引用相等,两者有什么不同?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="20、一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_20、一个类的构造方法的作用是什么-若一个类没有声明构造方法-该程序能正确执行吗"><!---->20、一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="21、构造方法有哪些特点？是否可被 override?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_21、构造方法有哪些特点-是否可被-override"><!---->21、构造方法有哪些特点？是否可被 override?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="22、面向对象三大特征" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_22、面向对象三大特征"><!---->22、面向对象三大特征<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="封装" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#封装"><!---->封装<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="继承" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#继承"><!---->继承<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="多态" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#多态"><!---->多态<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="面向对象五大基本原则是什么" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#面向对象五大基本原则是什么"><!---->面向对象五大基本原则是什么<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="23、深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_23、深拷贝和浅拷贝区别了解吗-什么是引用拷贝"><!---->23、深拷贝和浅拷贝区别了解吗？什么是引用拷贝？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="24、String、StringBuffer、StringBuilder 的区别？String 为什么是不可变的?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_24、string、stringbuffer、stringbuilder-的区别-string-为什么是不可变的"><!---->24、String、StringBuffer、StringBuilder 的区别？String 为什么是不可变的?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="25、字符串拼接用“+” 还是 StringBuilder?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_25、字符串拼接用-还是-stringbuilder"><!---->25、字符串拼接用“+” 还是 StringBuilder?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="26、字符串常量池的作用了解吗？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_26、字符串常量池的作用了解吗"><!---->26、字符串常量池的作用了解吗？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="27、final" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_27、final"><!---->27、final<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="final 有什么用？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#final-有什么用"><!---->final 有什么用？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="final finally finalize区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#final-finally-finalize区别"><!---->final finally finalize区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="28、泛型" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_28、泛型"><!---->28、泛型<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="泛型的分类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#泛型的分类"><!---->泛型的分类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="常用的通配符有哪些？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#常用的通配符有哪些"><!---->常用的通配符有哪些？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="你的项目中哪里用到了泛型？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#你的项目中哪里用到了泛型"><!---->你的项目中哪里用到了泛型？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="29、反射" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_29、反射"><!---->29、反射<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、谈谈你对反射的理解？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、谈谈你对反射的理解"><!---->1、谈谈你对反射的理解？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、反射机制优缺点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、反射机制优缺点"><!---->2、反射机制优缺点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、反射的应用场景" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、反射的应用场景"><!---->3、反射的应用场景<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="30、注解" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_30、注解"><!---->30、注解<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="31、I/O" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_31、i-o"><!---->31、I/O<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="什么是序列化?什么是反序列化?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#什么是序列化-什么是反序列化"><!---->什么是序列化?什么是反序列化?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Java 序列化中如果有些字段不想进行序列化，怎么办？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#java-序列化中如果有些字段不想进行序列化-怎么办"><!---->Java 序列化中如果有些字段不想进行序列化，怎么办？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="获取用键盘输入常用的两种方法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#获取用键盘输入常用的两种方法"><!---->获取用键盘输入常用的两种方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Java 中 IO 流分为几种?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#java-中-io-流分为几种"><!---->Java 中 IO 流分为几种?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="既然有了字节流,为什么还要有字符流?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#既然有了字节流-为什么还要有字符流"><!---->既然有了字节流,为什么还要有字符流?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="32、Java 中 3 种常见 IO 模型" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_32、java-中-3-种常见-io-模型"><!---->32、Java 中 3 种常见 IO 模型<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="BIO (Blocking I/O)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#bio-blocking-i-o"><!---->BIO (Blocking I/O)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="NIO (Non-blocking/New I/O)" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#nio-non-blocking-new-i-o"><!---->NIO (Non-blocking/New I/O)<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="AIO" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#aio"><!---->AIO<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="33、" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_33、"><!---->33、<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="34、&amp;和&amp;&amp;的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_34、-和-的区别"><!---->34、&amp;和&amp;&amp;的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="35、抽象类和接口的区别?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_35、抽象类和接口的区别"><!---->35、抽象类和接口的区别?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="36、this关键字的用法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_36、this关键字的用法"><!---->36、this关键字的用法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="37、super关键字的用法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_37、super关键字的用法"><!---->37、super关键字的用法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="38、是否了解连接池，使用连接池有什么好处？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_38、是否了解连接池-使用连接池有什么好处"><!---->38、是否了解连接池，使用连接池有什么好处？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="39、hashCode（）与equals（）的相关规定" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_39、hashcode-与equals-的相关规定"><!---->39、hashCode（）与equals（）的相关规定<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1、异常的含义" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、异常的含义"><!---->1、异常的含义<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、异常的作用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、异常的作用"><!---->2、异常的作用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、运行时异常与一般异常" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、运行时异常与一般异常"><!---->3、运行时异常与一般异常<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、 Error 和 Exception 区别是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、-error-和-exception-区别是什么"><!---->4、 Error 和 Exception 区别是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、throw 和 throws 的区别是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、throw-和-throws-的区别是什么"><!---->5、throw 和 throws 的区别是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、JVM如何处理异常" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、jvm如何处理异常"><!---->6、JVM如何处理异常<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、Java异常关键字" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、java异常关键字"><!---->7、Java异常关键字<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、final、finally、finalize 有什么区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_8、final、finally、finalize-有什么区别"><!---->8、final、finally、finalize 有什么区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="9、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_9、try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗"><!---->9、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="10、 Java常见异常有哪些" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_10、-java常见异常有哪些"><!---->10、 Java常见异常有哪些<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1、集合概述：" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、集合概述"><!---->1、集合概述：<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、集合框架：" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、集合框架"><!---->2、集合框架：<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、集合和数组的区别：" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、集合和数组的区别"><!---->3、集合和数组的区别：<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、List、Set两者的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、list、set两者的区别"><!---->4、List、Set两者的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、HashMap、HashTable、HashSet" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、hashmap、hashtable、hashset"><!---->5、HashMap、HashTable、HashSet<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、HashMap的存储原理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、hashmap的存储原理"><!---->6、HashMap的存储原理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、迭代器lterator" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、迭代器lterator"><!---->7、迭代器lterator<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、ArrayList、LinkedList、Vector" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_8、arraylist、linkedlist、vector"><!---->8、ArrayList、LinkedList、Vector<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="9、集合框架底层数据结构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_9、集合框架底层数据结构"><!---->9、集合框架底层数据结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="10、怎么确保一个集合不能被修改？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_10、怎么确保一个集合不能被修改"><!---->10、怎么确保一个集合不能被修改？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="12、迭代器 Iterator 是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_12、迭代器-iterator-是什么"><!---->12、迭代器 Iterator 是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="13、Iterator 和 ListIterator 有什么区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_13、iterator-和-listiterator-有什么区别"><!---->13、Iterator 和 ListIterator 有什么区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="14、List和Set的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_14、list和set的区别"><!---->14、List和Set的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="15、ArrayList和LinkedList的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_15、arraylist和linkedlist的区别"><!---->15、ArrayList和LinkedList的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="16、HashMap和hasptable有什么区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_16、hashmap和hasptable有什么区别"><!---->16、HashMap和hasptable有什么区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="17、说一下HashMap的Put方法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_17、说一下hashmap的put方法"><!---->17、说一下HashMap的Put方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="18、HashMap的扩容机制原理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_18、hashmap的扩容机制原理"><!---->18、HashMap的扩容机制原理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="19、说一下 ArrayList 的优缺点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_19、说一下-arraylist-的优缺点"><!---->19、说一下 ArrayList 的优缺点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="20、如何实现数组和 List 之间的转换？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_20、如何实现数组和-list-之间的转换"><!---->20、如何实现数组和 List 之间的转换？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="21、ArrayList 和 Vector 的区别是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_21、arraylist-和-vector-的区别是什么"><!---->21、ArrayList 和 Vector 的区别是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="22、说一下 HashSet 的实现原理？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_22、说一下-hashset-的实现原理"><!---->22、说一下 HashSet 的实现原理？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="23、 HashSet如何检查重复？HashSet是如何保证数据不可重复的？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_23、-hashset如何检查重复-hashset是如何保证数据不可重复的"><!---->23、 HashSet如何检查重复？HashSet是如何保证数据不可重复的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="24、说一下HashMap的实现原理？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_24、说一下hashmap的实现原理"><!---->24、说一下HashMap的实现原理？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="25、HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_25、hashmap在jdk1-7和jdk1-8中有哪些不同-hashmap的底层实现"><!---->25、HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="26、说说什么是红黑树" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_26、说说什么是红黑树"><!---->26、说说什么是红黑树<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="27、能否使用任何类作为 Map 的 key？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_27、能否使用任何类作为-map-的-key"><!---->27、能否使用任何类作为 Map 的 key？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="28、HashMap 的长度为什么是2的幂次方" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_28、hashmap-的长度为什么是2的幂次方"><!---->28、HashMap 的长度为什么是2的幂次方<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="29、HashMap 与 HashTable 有什么区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_29、hashmap-与-hashtable-有什么区别"><!---->29、HashMap 与 HashTable 有什么区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="30、Array 和 ArrayList 有何区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_30、array-和-arraylist-有何区别"><!---->30、Array 和 ArrayList 有何区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="31、comparable 和 comparator的区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_31、comparable-和-comparator的区别"><!---->31、comparable 和 comparator的区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="32、Collection和Collections有什么区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_32、collection和collections有什么区别"><!---->32、Collection和Collections有什么区别？<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、为什么要使用多线程？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、为什么要使用多线程"><!---->1、为什么要使用多线程？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、单线程和多线程的区别。" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、单线程和多线程的区别。"><!---->2、单线程和多线程的区别。<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、进程和线程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、进程和线程"><!---->3、进程和线程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、并行和并发" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、并行和并发"><!---->4、并行和并发<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、线程的创建方式" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、线程的创建方式"><!---->5、线程的创建方式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、线程的六种状态（）" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、线程的六种状态"><!---->6、线程的六种状态（）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、如何停止一个正在运行的线程？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、如何停止一个正在运行的线程"><!---->7、如何停止一个正在运行的线程？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、start()和run()方法的区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_8、start-和run-方法的区别"><!---->8、start()和run()方法的区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="9、为什么调用start()方法的时候会执行run()方法，而不能直接调用run()方法？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_9、为什么调用start-方法的时候会执行run-方法-而不能直接调用run-方法"><!---->9、为什么调用start()方法的时候会执行run()方法，而不能直接调用run()方法？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="10、什么是线程安全？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_10、什么是线程安全"><!---->10、什么是线程安全？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="11、Java中堆和栈的区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_11、java中堆和栈的区别"><!---->11、Java中堆和栈的区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="12、如何确保线程安全？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_12、如何确保线程安全"><!---->12、如何确保线程安全？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="13、线程的安全级别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_13、线程的安全级别"><!---->13、线程的安全级别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="14、线程类的构造方法和静态块是被哪个线程调用的？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_14、线程类的构造方法和静态块是被哪个线程调用的"><!---->14、线程类的构造方法和静态块是被哪个线程调用的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="15、线程池的作用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_15、线程池的作用"><!---->15、线程池的作用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="16、Java中的死锁问题" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_16、java中的死锁问题"><!---->16、Java中的死锁问题<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="17、如何避免死锁和检测" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_17、如何避免死锁和检测"><!---->17、如何避免死锁和检测<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="18、synchronized底层原理？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_18、synchronized底层原理"><!---->18、synchronized底层原理？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="19、生产者消费者模型的作用是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_19、生产者消费者模型的作用是什么"><!---->19、生产者消费者模型的作用是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="20、生产者消费者模式" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_20、生产者消费者模式"><!---->20、生产者消费者模式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="21、创建线程池的几种方法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_21、创建线程池的几种方法"><!---->21、创建线程池的几种方法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="22、自定义线程池的配置" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_22、自定义线程池的配置"><!---->22、自定义线程池的配置<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="23、什么是乐观锁和悲观锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_23、什么是乐观锁和悲观锁"><!---->23、什么是乐观锁和悲观锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="24、并发编程三要素是什么？在Java程序中怎么保证多线程的运行安全？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_24、并发编程三要素是什么-在java程序中怎么保证多线程的运行安全"><!---->24、并发编程三要素是什么？在Java程序中怎么保证多线程的运行安全？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="25、volatile 关键字" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_25、volatile-关键字"><!---->25、volatile 关键字<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="26、乐观锁如何实现" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_26、乐观锁如何实现"><!---->26、乐观锁如何实现<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="27、sleep方法和wait方法有什么区别和共同点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_27、sleep方法和wait方法有什么区别和共同点"><!---->27、sleep方法和wait方法有什么区别和共同点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="28、CAS算法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_28、cas算法"><!---->28、CAS算法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1、什么是Java虚拟机？为何被称作“平台无关的编程语言”？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、什么是java虚拟机-为何被称作-平台无关的编程语言"><!---->1、什么是Java虚拟机？为何被称作“平台无关的编程语言”？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、Java的内存结构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、java的内存结构"><!---->2、Java的内存结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、内存分配" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、内存分配"><!---->3、内存分配<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、类加载器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、类加载器"><!---->4、类加载器<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、JVM如何加载class文件？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、jvm如何加载class文件"><!---->5、JVM如何加载class文件？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、Java对象创建的过程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、java对象创建的过程"><!---->6、Java对象创建的过程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、Java对象的结构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、java对象的结构"><!---->7、Java对象的结构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、类的生命周期" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_8、类的生命周期"><!---->8、类的生命周期<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="9、什么情况下会发生栈溢出？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_9、什么情况下会发生栈溢出"><!---->9、什么情况下会发生栈溢出？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="10、Java垃圾回收机制,GC是什么？为什么要GC?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_10、java垃圾回收机制-gc是什么-为什么要gc"><!---->10、Java垃圾回收机制,GC是什么？为什么要GC?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="11、JVM新生代、老年代、持久代都存储些哪些东西？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_11、jvm新生代、老年代、持久代都存储些哪些东西"><!---->11、JVM新生代、老年代、持久代都存储些哪些东西？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="12、Java会存在内存泄漏吗？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_12、java会存在内存泄漏吗"><!---->12、Java会存在内存泄漏吗？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="13、JVM调优有哪些？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_13、jvm调优有哪些"><!---->13、JVM调优有哪些？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="说一下 JVM 调优的工具？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#说一下-jvm-调优的工具"><!---->说一下 JVM 调优的工具？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="14、如何判断对象可以被回收？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_14、如何判断对象可以被回收"><!---->14、如何判断对象可以被回收？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="15、 JVM的永久代中会发生垃圾回收么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_15、-jvm的永久代中会发生垃圾回收么"><!---->15、 JVM的永久代中会发生垃圾回收么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="16、栈帧有哪些数据？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_16、栈帧有哪些数据"><!---->16、栈帧有哪些数据？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="17、Java的双亲委托机制是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_17、java的双亲委托机制是什么"><!---->17、Java的双亲委托机制是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="18、说一下堆栈的区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_18、说一下堆栈的区别"><!---->18、说一下堆栈的区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="19、队列和栈是什么？有什么区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_19、队列和栈是什么-有什么区别"><!---->19、队列和栈是什么？有什么区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="20、为对象分配内存" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_20、为对象分配内存"><!---->20、为对象分配内存<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="21、处理并发安全问题" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_21、处理并发安全问题"><!---->21、处理并发安全问题<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="22、说一下 JVM 有哪些垃圾回收算法？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_22、说一下-jvm-有哪些垃圾回收算法"><!---->22、说一下 JVM 有哪些垃圾回收算法？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="23、分代概念" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_23、分代概念"><!---->23、分代概念<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="24、为什么分代？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_24、为什么分代"><!---->24、为什么分代？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="25、JVM堆内存常用参数" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_25、jvm堆内存常用参数"><!---->25、JVM堆内存常用参数<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="26、类加载的过程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_26、类加载的过程"><!---->26、类加载的过程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="27、Java中的4种引用类型" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_27、java中的4种引用类型"><!---->27、Java中的4种引用类型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1、什么是MySQL" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、什么是mysql"><!---->1、什么是MySQL<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、数据库三大范式" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、数据库三大范式"><!---->2、数据库三大范式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、对慢查询怎么样优化过？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、对慢查询怎么样优化过"><!---->3、对慢查询怎么样优化过？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、mysql有关权限的表都有哪几个" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、mysql有关权限的表都有哪几个"><!---->4、mysql有关权限的表都有哪几个<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、MySQL由哪些部分组成？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、mysql由哪些部分组成"><!---->5、MySQL由哪些部分组成？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、优化数据库的方法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、优化数据库的方法"><!---->6、优化数据库的方法<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="优化查询过程中的数据访问" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#优化查询过程中的数据访问"><!---->优化查询过程中的数据访问<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="优化长难的查询语句" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#优化长难的查询语句"><!---->优化长难的查询语句<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="优化特定类型的查询语句" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#优化特定类型的查询语句"><!---->优化特定类型的查询语句<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="优化关联查询" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#优化关联查询"><!---->优化关联查询<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="优化子查询" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#优化子查询"><!---->优化子查询<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="优化GROUP BY和DISTINCT" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#优化group-by和distinct"><!---->优化GROUP BY和DISTINCT<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="优化LIMIT分页" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#优化limit分页"><!---->优化LIMIT分页<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="优化UNION查询" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#优化union查询"><!---->优化UNION查询<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、解释一下交叉连接、内连接、外连接" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、解释一下交叉连接、内连接、外连接"><!---->7、解释一下交叉连接、内连接、外连接<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="六种关联查询" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#六种关联查询"><!---->六种关联查询<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="外连接（LEFT JOIN/RIGHT JOIN）" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#外连接-left-join-right-join"><!---->外连接（LEFT JOIN/RIGHT JOIN）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="联合查询（UNION与UNION ALL）" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#联合查询-union与union-all"><!---->联合查询（UNION与UNION ALL）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="全连接（FULL JOIN）" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#全连接-full-join"><!---->全连接（FULL JOIN）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、为什么要使用NOTNULL？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_8、为什么要使用notnull"><!---->8、为什么要使用NOTNULL？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="9、什么是索引？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_9、什么是索引"><!---->9、什么是索引？<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="索引有哪几种类型？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#索引有哪几种类型"><!---->索引有哪几种类型？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="索引的基本原理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#索引的基本原理"><!---->索引的基本原理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="索引设计的原则？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#索引设计的原则"><!---->索引设计的原则？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="创建索引的原则（重中之重）" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#创建索引的原则-重中之重"><!---->创建索引的原则（重中之重）<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="使用索引查询一定能提高查询的性能吗？为什么" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#使用索引查询一定能提高查询的性能吗-为什么"><!---->使用索引查询一定能提高查询的性能吗？为什么<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="10、什么是事务？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_10、什么是事务"><!---->10、什么是事务？<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="MySQL 事务隔离级别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#mysql-事务隔离级别"><!---->MySQL 事务隔离级别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="11、ACID事务的特性" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_11、acid事务的特性"><!---->11、ACID事务的特性<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="12、并发事务带来了哪些问题？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_12、并发事务带来了哪些问题"><!---->12、并发事务带来了哪些问题？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="13、MySQL的四种隔离级别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_13、mysql的四种隔离级别"><!---->13、MySQL的四种隔离级别<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="隔离级别与锁的关系" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#隔离级别与锁的关系"><!---->隔离级别与锁的关系<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="14、MySQL存储引擎MyISAM与InnoDB区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_14、mysql存储引擎myisam与innodb区别"><!---->14、MySQL存储引擎MyISAM与InnoDB区别<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="MyISAM索引与InnoDB索引的区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#myisam索引与innodb索引的区别"><!---->MyISAM索引与InnoDB索引的区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MyISAM与InnoDB区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#myisam与innodb区别"><!---->MyISAM与InnoDB区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="InnoDB引擎的4大特性" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#innodb引擎的4大特性"><!---->InnoDB引擎的4大特性<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="15、百万级别或以上的数据如何删除" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_15、百万级别或以上的数据如何删除"><!---->15、百万级别或以上的数据如何删除<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="16、数据库为什么使用B+树而不是B树" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_16、数据库为什么使用b-树而不是b树"><!---->16、数据库为什么使用B+树而不是B树<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="17、对MySQL的锁了解吗？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_17、对mysql的锁了解吗"><!---->17、对MySQL的锁了解吗？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="18、为什么要使用视图？什么是视图？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_18、为什么要使用视图-什么是视图"><!---->18、为什么要使用视图？什么是视图？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="19、视图有哪些特点？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_19、视图有哪些特点"><!---->19、视图有哪些特点？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="20、视图的使用场景有哪些？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_20、视图的使用场景有哪些"><!---->20、视图的使用场景有哪些？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="21、视图的优点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_21、视图的优点"><!---->21、视图的优点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="22、视图的缺点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_22、视图的缺点"><!---->22、视图的缺点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="23、存储过程与函数" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_23、存储过程与函数"><!---->23、存储过程与函数<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="24、什么是触发器？触发器的使用场景有哪些？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_24、什么是触发器-触发器的使用场景有哪些"><!---->24、什么是触发器？触发器的使用场景有哪些？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="25、超键、候选键、主键、外键分别是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_25、超键、候选键、主键、外键分别是什么"><!---->25、超键、候选键、主键、外键分别是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="26、什么是子查询？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_26、什么是子查询"><!---->26、什么是子查询？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="27、mysql中 in 和 exists 区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_27、mysql中-in-和-exists-区别"><!---->27、mysql中 in 和 exists 区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="28、大表数据查询，怎么优化？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_28、大表数据查询-怎么优化"><!---->28、大表数据查询，怎么优化？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="29、超大分页怎么处理？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_29、超大分页怎么处理"><!---->29、超大分页怎么处理？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="30、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_30、关心过业务系统里面的sql耗时吗-统计过慢查询吗-对慢查询都怎么优化过"><!---->30、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="31、CHAR 和VARCHAR 的区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_31、char-和varchar-的区别"><!---->31、CHAR 和VARCHAR 的区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="32、数据库索引的原理，为什么要用B+树，为什么不用二叉树？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_32、数据库索引的原理-为什么要用b-树-为什么不用二叉树"><!---->32、数据库索引的原理，为什么要用B+树，为什么不用二叉树？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="33、数据库自增主键可能遇到什么问题" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_33、数据库自增主键可能遇到什么问题"><!---->33、数据库自增主键可能遇到什么问题<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="34、Blob和text有什么区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_34、blob和text有什么区别"><!---->34、Blob和text有什么区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="35、count(1)、count(*) 与 count(列名) 的区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_35、count-1-、count-与-count-列名-的区别"><!---->35、count(1)、count(*) 与 count(列名) 的区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="36、查询语句执行流程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_36、查询语句执行流程"><!---->36、查询语句执行流程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="37、MySQL锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_37、mysql锁"><!---->37、MySQL锁<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、全局锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、全局锁"><!---->1、全局锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、表级锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、表级锁"><!---->2、表级锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、行级锁" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、行级锁"><!---->3、行级锁<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="38、什么是最左前缀原则？什么是最左匹配原则" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_38、什么是最左前缀原则-什么是最左匹配原则"><!---->38、什么是最左前缀原则？什么是最左匹配原则<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="39、什么是聚簇索引？何时使用聚簇索引与非聚簇索引" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_39、什么是聚簇索引-何时使用聚簇索引与非聚簇索引"><!---->39、什么是聚簇索引？何时使用聚簇索引与非聚簇索引<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="40、联合索引是什么？为什么需要注意联合索引中的顺序？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_40、联合索引是什么-为什么需要注意联合索引中的顺序"><!---->40、联合索引是什么？为什么需要注意联合索引中的顺序？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="41、SQL语句主要分为哪几类" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_41、sql语句主要分为哪几类"><!---->41、SQL语句主要分为哪几类<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="42、超键、候选键、主键、外键分别是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_42、超键、候选键、主键、外键分别是什么"><!---->42、超键、候选键、主键、外键分别是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="43、SQL 约束有哪几种？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_43、sql-约束有哪几种"><!---->43、SQL 约束有哪几种？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="44、varchar(50)中50的涵义" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_44、varchar-50-中50的涵义"><!---->44、varchar(50)中50的涵义<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="45、int(20)中20的涵义" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_45、int-20-中20的涵义"><!---->45、int(20)中20的涵义<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="46、为什么要尽量设定一个主键？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_46、为什么要尽量设定一个主键"><!---->46、为什么要尽量设定一个主键？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="47、MySQL的复制原理以及流程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_47、mysql的复制原理以及流程"><!---->47、MySQL的复制原理以及流程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="48、MySQL主从复制的作用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_48、mysql主从复制的作用"><!---->48、MySQL主从复制的作用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="49、MySQL主从复制工作原理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_49、mysql主从复制工作原理"><!---->49、MySQL主从复制工作原理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="50、什么是死锁？怎么解决？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_50、什么是死锁-怎么解决"><!---->50、什么是死锁？怎么解决？<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="51、数据库的乐观锁和悲观锁是什么？怎么实现的？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_51、数据库的乐观锁和悲观锁是什么-怎么实现的"><!---->51、数据库的乐观锁和悲观锁是什么？怎么实现的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="51、drop、delete与truncate的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_51、drop、delete与truncate的区别"><!---->51、drop、delete与truncate的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="52、UNION与UNIONALL的区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_52、union与unionall的区别"><!---->52、UNION与UNIONALL的区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="53、按照锁的粒度分数据库锁有哪些？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_53、按照锁的粒度分数据库锁有哪些"><!---->53、按照锁的粒度分数据库锁有哪些？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="54、数据库中有六种触发器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_54、数据库中有六种触发器"><!---->54、数据库中有六种触发器<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="55、Hash索引和B+树索引有什么区别或者说优劣呢?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_55、hash索引和b-树索引有什么区别或者说优劣呢"><!---->55、Hash索引和B+树索引有什么区别或者说优劣呢?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Spring" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#spring"><!---->Spring<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、什么是Spring：" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、什么是spring"><!---->1、什么是Spring：<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、你们项目中为什么使用Spring框架？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、你们项目中为什么使用spring框架"><!---->2、你们项目中为什么使用Spring框架？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、Autowired和Resource关键字的区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、autowired和resource关键字的区别"><!---->3、Autowired和Resource关键字的区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、依赖注入的方式有几种，各是什么?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、依赖注入的方式有几种-各是什么"><!---->4、依赖注入的方式有几种，各是什么?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、说说你对Spring的IOC是怎么理解的？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、说说你对spring的ioc是怎么理解的"><!---->5、说说你对Spring的IOC是怎么理解的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、谈谈你对Spring的AOP理解" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、谈谈你对spring的aop理解"><!---->6、谈谈你对Spring的AOP理解<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、Spring AOP和AspectJ AOP有什么区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、spring-aop和aspectj-aop有什么区别"><!---->7、Spring AOP和AspectJ AOP有什么区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、在Spring AOP 中，关注点和横切关注的区别是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_8、在spring-aop-中-关注点和横切关注的区别是什么"><!---->8、在Spring AOP 中，关注点和横切关注的区别是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="9、什么是通知呢？有哪些类型呢？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_9、什么是通知呢-有哪些类型呢"><!---->9、什么是通知呢？有哪些类型呢？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="10、解释一下spring bean的生命周期" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_10、解释一下spring-bean的生命周期"><!---->10、解释一下spring bean的生命周期<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="11、解释Spring支持的几种bean的作用域？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_11、解释spring支持的几种bean的作用域"><!---->11、解释Spring支持的几种bean的作用域？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="12、静态代理和动态代理的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_12、静态代理和动态代理的区别"><!---->12、静态代理和动态代理的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="13、JDK动态代理和CGLIB动态代理的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_13、jdk动态代理和cglib动态代理的区别"><!---->13、JDK动态代理和CGLIB动态代理的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="14、Spring框架中都用到了哪些设计模式？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_14、spring框架中都用到了哪些设计模式"><!---->14、Spring框架中都用到了哪些设计模式？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="15、说说Spring 中 ApplicationContext 和 BeanFactory 的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_15、说说spring-中-applicationcontext-和-beanfactory-的区别"><!---->15、说说Spring 中 ApplicationContext 和 BeanFactory 的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="16、Spring 框架中的单例 Bean 是线程安全的么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_16、spring-框架中的单例-bean-是线程安全的么"><!---->16、Spring 框架中的单例 Bean 是线程安全的么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="17、Spring 是怎么解决循环依赖的？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_17、spring-是怎么解决循环依赖的"><!---->17、Spring 是怎么解决循环依赖的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="18、Spring 管理事务的方式有几种？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_18、spring-管理事务的方式有几种"><!---->18、Spring 管理事务的方式有几种？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="19、Spring 事务中的隔离级别有哪几种?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_19、spring-事务中的隔离级别有哪几种"><!---->19、Spring 事务中的隔离级别有哪几种?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="SpringMVC" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#springmvc"><!---->SpringMVC<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、SpringMVC的执行流程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、springmvc的执行流程"><!---->1、SpringMVC的执行流程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、SpringMVC中的拦截器和Servlet中的Filter过滤器的区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、springmvc中的拦截器和servlet中的filter过滤器的区别"><!---->2、SpringMVC中的拦截器和Servlet中的Filter过滤器的区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、什么是Spring MVC？简单介绍下你对Spring MVC的理解？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、什么是spring-mvc-简单介绍下你对spring-mvc的理解"><!---->3、什么是Spring MVC？简单介绍下你对Spring MVC的理解？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、spring-mvc的控制器是不是单例模式-如果是-有什么问题-怎么解决"><!---->4、Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、MVC是什么？MVC设计模式的好处有哪些" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、mvc是什么-mvc设计模式的好处有哪些"><!---->5、MVC是什么？MVC设计模式的好处有哪些<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、Spring MVC常用的注解有哪些？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、spring-mvc常用的注解有哪些"><!---->6、Spring MVC常用的注解有哪些？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、Spring MVC怎么样设定重定向和转发的？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、spring-mvc怎么样设定重定向和转发的"><!---->7、Spring MVC怎么样设定重定向和转发的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="MyBatis" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#mybatis"><!---->MyBatis<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、介绍一下MyBatis：" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、介绍一下mybatis"><!---->1、介绍一下MyBatis：<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、ORM是什么" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、orm是什么"><!---->2、ORM是什么<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、为什么说mybatis是半自动orm映射工具-它与全自动的区别在哪里"><!---->3、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、传统JDBC开发存在的问题" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、传统jdbc开发存在的问题"><!---->4、传统JDBC开发存在的问题<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、jdbc编程有哪些不足之处-mybatis是如何解决这些问题的"><!---->5、JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、Mybatis优缺点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、mybatis优缺点"><!---->6、Mybatis优缺点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、Hibernate 和 MyBatis 的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、hibernate-和-mybatis-的区别"><!---->7、Hibernate 和 MyBatis 的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、MyBatis编程步骤是什么样的？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_8、mybatis编程步骤是什么样的"><!---->8、MyBatis编程步骤是什么样的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="9、请说说MyBatis的工作原理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_9、请说说mybatis的工作原理"><!---->9、请说说MyBatis的工作原理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="10、Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_10、mybatis都有哪些executor执行器-它们之间的区别是什么"><!---->10、Mybatis都有哪些Executor执行器？它们之间的区别是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="11、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_11、mybatis是否支持延迟加载-如果支持-它的实现原理是什么"><!---->11、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="12、MyBatis#{}和${}的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_12、mybatis-和-的区别"><!---->12、MyBatis#{}和${}的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="13、MyBatis如何获取生成的主键" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_13、mybatis如何获取生成的主键"><!---->13、MyBatis如何获取生成的主键<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="14、使用MyBatis的mapper接口调用时有哪些要求？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_14、使用mybatis的mapper接口调用时有哪些要求"><!---->14、使用MyBatis的mapper接口调用时有哪些要求？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="16、MyBatis实现一对一，一对多有几种方式，怎么操作的？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_16、mybatis实现一对一-一对多有几种方式-怎么操作的"><!---->16、MyBatis实现一对一，一对多有几种方式，怎么操作的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="17、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_17、mybatis动态sql是做什么的-都有哪些动态sql-能简述一下动态sql的执行原理不"><!---->17、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="18、Mybatis是如何进行分页的？分页插件的原理是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_18、mybatis是如何进行分页的-分页插件的原理是什么"><!---->18、Mybatis是如何进行分页的？分页插件的原理是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="19、Mybatis的一级、二级缓存" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_19、mybatis的一级、二级缓存"><!---->19、Mybatis的一级、二级缓存<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="SSM" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#ssm"><!---->SSM<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、SSM分工：" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、ssm分工"><!---->1、SSM分工：<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1、什么是SpringBoot" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、什么是springboot"><!---->1、什么是SpringBoot<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、Spring Boot 有哪些优点？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、spring-boot-有哪些优点"><!---->2、Spring Boot 有哪些优点？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、spring-boot-的核心注解是哪个-它主要由哪几个注解组成的"><!---->3、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、Spring Boot 自动配置原理是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、spring-boot-自动配置原理是什么"><!---->4、Spring Boot 自动配置原理是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、Spring Boot 配置加载顺序详解" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、spring-boot-配置加载顺序详解"><!---->5、Spring Boot 配置加载顺序详解<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、YAML 配置的优势在哪里 ?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、yaml-配置的优势在哪里"><!---->6、YAML 配置的优势在哪里 ?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、Spring Boot 中如何解决跨域问题 ?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、spring-boot-中如何解决跨域问题"><!---->7、Spring Boot 中如何解决跨域问题 ?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、SpringBoot打成的jar和普通的jar有什么区别?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_8、springboot打成的jar和普通的jar有什么区别"><!---->8、SpringBoot打成的jar和普通的jar有什么区别?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="9、什么是YAML？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_9、什么是yaml"><!---->9、什么是YAML？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="10、Spring Boot、Spring MVC 和 Spring 有什么区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_10、spring-boot、spring-mvc-和-spring-有什么区别"><!---->10、Spring Boot、Spring MVC 和 Spring 有什么区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="11、Spring Boot 中如何解决跨域问题 ?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_11、spring-boot-中如何解决跨域问题"><!---->11、Spring Boot 中如何解决跨域问题 ?<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="12、什么是 CSRF 攻击？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_12、什么是-csrf-攻击"><!---->12、什么是 CSRF 攻击？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="14、SpringBoot支持哪些日志框架？推荐和默认的日志框架是哪个？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_14、springboot支持哪些日志框架-推荐和默认的日志框架是哪个"><!---->14、SpringBoot支持哪些日志框架？推荐和默认的日志框架是哪个？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="15、SpringBoot Starter的工作原理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_15、springboot-starter的工作原理"><!---->15、SpringBoot Starter的工作原理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="16、SpringBoot多数据源事务如何管理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_16、springboot多数据源事务如何管理"><!---->16、SpringBoot多数据源事务如何管理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="17、SpringBoot中如何实现定时任务 ?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_17、springboot中如何实现定时任务"><!---->17、SpringBoot中如何实现定时任务 ?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="18、spring-boot-starter-parent有什么用?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_18、spring-boot-starter-parent有什么用"><!---->18、spring-boot-starter-parent有什么用?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1、什么是SpringCloud" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、什么是springcloud"><!---->1、什么是SpringCloud<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、互联网架构演进" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、互联网架构演进"><!---->2、互联网架构演进<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、单体应用架构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、单体应用架构"><!---->1、单体应用架构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、垂直应用架构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、垂直应用架构"><!---->2、垂直应用架构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、SOA应用架构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、soa应用架构"><!---->3、SOA应用架构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、微服务应用架构" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、微服务应用架构"><!---->4、微服务应用架构<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、什么是服务注册与服务发现。" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、什么是服务注册与服务发现。"><!---->3、什么是服务注册与服务发现。<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、SpringBoot和SpringCloud的区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、springboot和springcloud的区别"><!---->4、SpringBoot和SpringCloud的区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、Spring Cloud的优缺点有哪些？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、spring-cloud的优缺点有哪些"><!---->5、Spring Cloud的优缺点有哪些？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、Eureka的服务治理是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、eureka的服务治理是什么"><!---->6、Eureka的服务治理是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、Eureka的服务注册是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、eureka的服务注册是什么"><!---->7、Eureka的服务注册是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、什么是Spring Cloud Ribbon？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_8、什么是spring-cloud-ribbon"><!---->8、什么是Spring Cloud Ribbon？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="9、Nginx和Ribbon的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_9、nginx和ribbon的区别"><!---->9、Nginx和Ribbon的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="10、Ribbon支持的负载均衡算法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_10、ribbon支持的负载均衡算法"><!---->10、Ribbon支持的负载均衡算法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="11、服务器雪崩" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_11、服务器雪崩"><!---->11、服务器雪崩<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="12、Hystrix熔断器" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_12、hystrix熔断器"><!---->12、Hystrix熔断器<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="13、Feign" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_13、feign"><!---->13、Feign<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="14、Gateway的作用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_14、gateway的作用"><!---->14、Gateway的作用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="15、Gateway的工作流程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_15、gateway的工作流程"><!---->15、Gateway的工作流程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="16、Gateway的路由规则" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_16、gateway的路由规则"><!---->16、Gateway的路由规则<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="17、Gateway的过滤使用" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_17、gateway的过滤使用"><!---->17、Gateway的过滤使用<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="18、什么是Spring Cloud Alibaba?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_18、什么是spring-cloud-alibaba"><!---->18、什么是Spring Cloud Alibaba?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="19、Spring Cloud Alibaba有哪些功能？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_19、spring-cloud-alibaba有哪些功能"><!---->19、Spring Cloud Alibaba有哪些功能？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="20、Spring Cloud Alibaba的常用组件有哪些？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_20、spring-cloud-alibaba的常用组件有哪些"><!---->20、Spring Cloud Alibaba的常用组件有哪些？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="21、什么是Nacos？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_21、什么是nacos"><!---->21、什么是Nacos？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="22、Nacos有什么作用？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_22、nacos有什么作用"><!---->22、Nacos有什么作用？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="23、什么是Spring Cloud Seata？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_23、什么是spring-cloud-seata"><!---->23、什么是Spring Cloud Seata？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1、为什么要用缓存" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、为什么要用缓存"><!---->1、为什么要用缓存<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、使用 Redis有哪些好处？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、使用-redis有哪些好处"><!---->2、使用 Redis有哪些好处？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、什么是 Redis？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、什么是-redis"><!---->3、什么是 Redis？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、为什么Redis单线程模型效率也能那么高？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、为什么redis单线程模型效率也能那么高"><!---->4、为什么Redis单线程模型效率也能那么高？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、为什么 Redis 需要把所有数据放到内存中？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、为什么-redis-需要把所有数据放到内存中"><!---->5、为什么 Redis 需要把所有数据放到内存中？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、Redis 的同步机制了解是什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、redis-的同步机制了解是什么"><!---->6、Redis 的同步机制了解是什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、说一下Redis有什么优点和缺点" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、说一下redis有什么优点和缺点"><!---->7、说一下Redis有什么优点和缺点<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、Redis的淘汰策略" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_8、redis的淘汰策略"><!---->8、Redis的淘汰策略<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="9、Redis 为什么设计成单线程的？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_9、redis-为什么设计成单线程的"><!---->9、Redis 为什么设计成单线程的？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="10、Redis五种数据类型" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_10、redis五种数据类型"><!---->10、Redis五种数据类型<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="11、Redis集群一般需要几台服务器？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_11、redis集群一般需要几台服务器"><!---->11、Redis集群一般需要几台服务器？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="12、什么是缓存穿透，如何避免" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_12、什么是缓存穿透-如何避免"><!---->12、什么是缓存穿透，如何避免<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="13、什么是缓存雪崩，如何避免" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_13、什么是缓存雪崩-如何避免"><!---->13、什么是缓存雪崩，如何避免<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="14、Redis 的持久化机制是什么？各自的优缺点？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_14、redis-的持久化机制是什么-各自的优缺点"><!---->14、Redis 的持久化机制是什么？各自的优缺点？<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="RDB：" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#rdb"><!---->RDB：<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="AOF：" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#aof"><!---->AOF：<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="RabbitMQ" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#rabbitmq"><!---->RabbitMQ<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、MQ的优势" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、mq的优势"><!---->1、MQ的优势<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、你们项目中用到过 MQ 吗？谈谈你对 MQ 的理解？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、你们项目中用到过-mq-吗-谈谈你对-mq-的理解"><!---->2、你们项目中用到过 MQ 吗？谈谈你对 MQ 的理解？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、常用的MQ" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、常用的mq"><!---->3、常用的MQ<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、MQ消费者消费消息的顺序一致性问题？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、mq消费者消费消息的顺序一致性问题"><!---->4、MQ消费者消费消息的顺序一致性问题？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、RabbitMQ如何保证数据⼀致性？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、rabbitmq如何保证数据一致性"><!---->5、RabbitMQ如何保证数据⼀致性？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、如何确保消息正确地发送⾄RabbitMQ？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、如何确保消息正确地发送至rabbitmq"><!---->6、如何确保消息正确地发送⾄RabbitMQ？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、如何避免消息重复投递或重复消费？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、如何避免消息重复投递或重复消费"><!---->7、如何避免消息重复投递或重复消费？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、RabbitMQ的工作模式" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_8、rabbitmq的工作模式"><!---->8、RabbitMQ的工作模式<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="ElasticSearch" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#elasticsearch"><!---->ElasticSearch<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、elasticsearch 了解多少，说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、elasticsearch-了解多少-说说你们公司-es-的集群架构-索引数据大小-分片有多少-以及一些调优手段"><!---->1、elasticsearch 了解多少，说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、为什么要使用elasticsearch" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、为什么要使用elasticsearch"><!---->2、为什么要使用elasticsearch<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、项目中如何使用elasticsearch" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、项目中如何使用elasticsearch"><!---->3、项目中如何使用elasticsearch<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、谈谈分词与倒排索引的原理" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、谈谈分词与倒排索引的原理"><!---->4、谈谈分词与倒排索引的原理<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Sharing-JDBC" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#sharing-jdbc"><!---->Sharing-JDBC<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、Shards&amp;Replicas分片和复制：" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、shards-replicas分片和复制"><!---->1、Shards&amp;Replicas分片和复制：<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、、分库分表" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、、分库分表"><!---->2、、分库分表<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、垂直分库" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、垂直分库"><!---->3、垂直分库<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、水平分库" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、水平分库"><!---->4、水平分库<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、垂直分表" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、垂直分表"><!---->5、垂直分表<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、水平分表" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、水平分表"><!---->6、水平分表<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、Sharing-JDBC定义" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、sharing-jdbc定义"><!---->7、Sharing-JDBC定义<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="Docker" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#docker"><!---->Docker<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、简介" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、简介"><!---->1、简介<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、Docker基本概念" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、docker基本概念"><!---->2、Docker基本概念<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1.1 概述" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-1-概述"><!---->1.1 概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1.2 数组" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-2-数组"><!---->1.2 数组<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1.3 栈" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-3-栈"><!---->1.3 栈<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1.3.1 概述" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-3-1-概述"><!---->1.3.1 概述<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1.4 队列" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-4-队列"><!---->1.4 队列<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1.5 链表" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-5-链表"><!---->1.5 链表<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1.6 树" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-6-树"><!---->1.6 树<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1.6.1 树" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-6-1-树"><!---->1.6.1 树<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1.6.2 二叉树" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-6-2-二叉树"><!---->1.6.2 二叉树<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1.6.3 满二叉树" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-6-3-满二叉树"><!---->1.6.3 满二叉树<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1.6.4 完全二叉树" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-6-4-完全二叉树"><!---->1.6.4 完全二叉树<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1.6.5 二叉查找树" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-6-5-二叉查找树"><!---->1.6.5 二叉查找树<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1.6.6 平衡二叉树" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-6-6-平衡二叉树"><!---->1.6.6 平衡二叉树<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1.6.7 红黑树" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-6-7-红黑树"><!---->1.6.7 红黑树<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1.7 哈希表" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-7-哈希表"><!---->1.7 哈希表<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1.7.2 哈希冲突" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-7-2-哈希冲突"><!---->1.7.2 哈希冲突<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1.8 对比" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1-8-对比"><!---->1.8 对比<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、简单算法" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、简单算法"><!---->2、简单算法<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、懒汉和饿汉" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、懒汉和饿汉"><!---->3、懒汉和饿汉<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="冒泡排序" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#冒泡排序"><!---->冒泡排序<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="选择排序" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#选择排序"><!---->选择排序<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="二分法查找" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#二分法查找"><!---->二分法查找<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1、OA工作流Activiti" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、oa工作流activiti"><!---->1、OA工作流Activiti<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="定义：业务过程部分或整体，在计算机应用环境下的自动化" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#定义-业务过程部分或整体-在计算机应用环境下的自动化"><!---->定义：业务过程部分或整体，在计算机应用环境下的自动化<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="工作流管理系统：" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#工作流管理系统"><!---->工作流管理系统：<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="主要作用：" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#主要作用"><!---->主要作用：<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、微信登录" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、微信登录"><!---->2、微信登录<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、微信支付" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、微信支付"><!---->3、微信支付<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、单点登录" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、单点登录"><!---->4、单点登录<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、并发量大的话如何处理？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、并发量大的话如何处理"><!---->5、并发量大的话如何处理？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、预计吞吐量" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、预计吞吐量"><!---->6、预计吞吐量<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、文件上传如何处理断点续传？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、文件上传如何处理断点续传"><!---->7、文件上传如何处理断点续传？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、redis分布式锁怎么实现的，当同时有多个······他是怎么处理的" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_8、redis分布式锁怎么实现的-当同时有多个······他是怎么处理的"><!---->8、redis分布式锁怎么实现的，当同时有多个······他是怎么处理的<!----></a><ul class="vp-sidebar-sub-headers"><li class="vp-sidebar-sub-header"><a aria-label="1、实现分布式锁的思路" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、实现分布式锁的思路"><!---->1、实现分布式锁的思路<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、Redisson" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、redisson"><!---->2、Redisson<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1、什么是Servlet" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、什么是servlet"><!---->1、什么是Servlet<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、什么是Servlet对象的生命周期" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、什么是servlet对象的生命周期"><!---->2、什么是Servlet对象的生命周期<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、JSP九大内置对象" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、jsp九大内置对象"><!---->3、JSP九大内置对象<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、JSP和Servlet的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、jsp和servlet的区别"><!---->4、JSP和Servlet的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、转发和重定向的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、转发和重定向的区别"><!---->5、转发和重定向的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、session 和 cookie 有什么区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、session-和-cookie-有什么区别"><!---->6、session 和 cookie 有什么区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、get和post的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、get和post的区别"><!---->7、get和post的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、说一下 session 的工作原理？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_8、说一下-session-的工作原理"><!---->8、说一下 session 的工作原理？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="9、简述 TCP 和 UDP的区别？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_9、简述-tcp-和-udp的区别"><!---->9、简述 TCP 和 UDP的区别？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="10、什么是三次握手，四次挥手 ？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_10、什么是三次握手-四次挥手"><!---->10、什么是三次握手，四次挥手 ？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="四次挥手" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#四次挥手"><!---->四次挥手<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="11、tcp 为什么要三次握手，两次不行吗？为什么？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_11、tcp-为什么要三次握手-两次不行吗-为什么"><!---->11、tcp 为什么要三次握手，两次不行吗？为什么？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1、Git和SVN的区别" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、git和svn的区别"><!---->1、Git和SVN的区别<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、什么是Git" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、什么是git"><!---->2、什么是Git<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、Git的工作流程" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、git的工作流程"><!---->3、Git的工作流程<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1、什么是maven？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、什么是maven"><!---->1、什么是maven？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、说说maven有什么优缺点？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、说说maven有什么优缺点"><!---->2、说说maven有什么优缺点？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、讲一下maven的生命周期" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、讲一下maven的生命周期"><!---->3、讲一下maven的生命周期<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、说说你熟悉哪些maven命令？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、说说你熟悉哪些maven命令"><!---->4、说说你熟悉哪些maven命令？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、"><!---->5、<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="1、为什么从上家公司离职？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_1、为什么从上家公司离职"><!---->1、为什么从上家公司离职？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="2、你对加班怎么看待？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_2、你对加班怎么看待"><!---->2、你对加班怎么看待？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="3、如果公司录用你,你会在公司工作多久?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_3、如果公司录用你-你会在公司工作多久"><!---->3、如果公司录用你,你会在公司工作多久?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="4、你最大的优缺点？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_4、你最大的优缺点"><!---->4、你最大的优缺点？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="5、希望去怎么样的公司?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_5、希望去怎么样的公司"><!---->5、希望去怎么样的公司?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="6、你工作中遇到哪些bug,怎么解决的?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_6、你工作中遇到哪些bug-怎么解决的"><!---->6、你工作中遇到哪些bug,怎么解决的?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="7、和同事或经理起冲突怎么办?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_7、和同事或经理起冲突怎么办"><!---->7、和同事或经理起冲突怎么办?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="8、三到五年的规划?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_8、三到五年的规划"><!---->8、三到五年的规划?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="9、上家公司的人员组成?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_9、上家公司的人员组成"><!---->9、上家公司的人员组成?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="10、项目经理给了一个超出你能力的需求，你怎么办？" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_10、项目经理给了一个超出你能力的需求-你怎么办"><!---->10、项目经理给了一个超出你能力的需求，你怎么办？<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="11、你和别人比,你觉得他们强的地方在哪里?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_11、你和别人比-你觉得他们强的地方在哪里"><!---->11、你和别人比,你觉得他们强的地方在哪里?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="12、你对自己评价如何?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_12、你对自己评价如何"><!---->12、你对自己评价如何?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="13、你还有什么问题要问?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_13、你还有什么问题要问"><!---->13、你还有什么问题要问?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="14、你能为我们公司带来什么?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_14、你能为我们公司带来什么"><!---->14、你能为我们公司带来什么?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="15、能不能接受出差?有没有打算做项目经理?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_15、能不能接受出差-有没有打算做项目经理"><!---->15、能不能接受出差?有没有打算做项目经理?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="16、如果你刚入职,将会如何开展工作?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_16、如果你刚入职-将会如何开展工作"><!---->16、如果你刚入职,将会如何开展工作?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="17、谈谈你对跳槽的看法?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_17、谈谈你对跳槽的看法"><!---->17、谈谈你对跳槽的看法?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="18、你的朋友对你评价?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_18、你的朋友对你评价"><!---->18、你的朋友对你评价?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li><li class="vp-sidebar-sub-header"><a aria-label="19、说说开发中，你的性格、经验、视野、基础如何?" class="vp-link nav-link vp-sidebar-link vp-heading nav-link vp-sidebar-link vp-heading" href="/toLeoJavaer/interview/interview-question-organization.html#_19、说说开发中-你的性格、经验、视野、基础如何"><!---->19、说说开发中，你的性格、经验、视野、基础如何?<!----></a><ul class="vp-sidebar-sub-headers"></ul></li></ul><!--]--></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-book4" style=""></span><span class="vp-sidebar-title">死磕面试</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-kafei1" style=""></span><span class="vp-sidebar-title">Java</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-database" style=""></span><span class="vp-sidebar-title">数据库</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-ios-tv" style=""></span><span class="vp-sidebar-title">计算机基础</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-tool" style=""></span><span class="vp-sidebar-title">开发工具</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-project" style=""></span><span class="vp-sidebar-title">常用框架</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-zhongjianjian2" style=""></span><span class="vp-sidebar-title">中间件</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-cloud" style=""></span><span class="vp-sidebar-title">微服务</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-1-2-1-fenbushi" style=""></span><span class="vp-sidebar-title">分布式</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-xiangmu-mian" style=""></span><span class="vp-sidebar-title">项目</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-heading clickable" type="button"><span class="font-icon icon iconfont icon-qianduan1" style=""></span><span class="vp-sidebar-title">前端技术</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><span class="font-icon icon iconfont icon-circle-info" style=""></span>面试题整理</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://manamn.space/" target="_blank" rel="noopener noreferrer">Leo</a></span><span property="author" content="Leo"></span></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><!--[--><span class="page-category-item category8" role>面试题</span><!--]--><meta property="articleSection" content="面试题"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><!--[--><span class="page-tag-item tag8" role>面试题</span><!--]--><meta property="keywords" content="面试题"></span><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-09-12T00:00:00.000Z"></span><!----><span class="page-word-info" aria-label="字数🔠" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 68458 字</span><meta property="wordCount" content="68458"></span><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 228 分钟</span><meta property="timeRequired" content="PT228M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1、java-语言有哪些特点">1、Java 语言有哪些特点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_2、jvm、jre和jdk的关系">2、JVM、JRE和JDK的关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_3、字符型常量和字符串常量的区别">3、字符型常量和字符串常量的区别?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_4、注释有哪几种">4、注释有哪几种</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_5、标识符和关键字的区别">5、标识符和关键字的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_6、自增自减运算符">6、自增自减运算符</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_7、continue、break-和-return-的区别">7、continue、break 和 return 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_8、静态方法为什么不能调用非静态成员">8、静态方法为什么不能调用非静态成员?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_9、静态方法和实例方法有何不同">9、静态方法和实例方法有何不同？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_10、重载和重写的区别">10、重载和重写的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_11、-和-equals-的区别">11、== 和 equals() 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_12、hashcode-与-equals">12、hashCode() 与 equals()</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_13、为什么重写-equals-时必须重写-hashcode-方法">13、为什么重写 equals() 时必须重写 hashCode() 方法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_14、基本数据类型">14、基本数据类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_15、包装类型的常量池技术">15、包装类型的常量池技术</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_16、内部类">16、内部类</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#什么是内部类">什么是内部类？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#内部类的分类">内部类的分类</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#静态内部类">静态内部类</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#成员内部类">成员内部类</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#局部内部类">局部内部类</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#匿名内部类">匿名内部类</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#内部类的优点">内部类的优点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#为什么局部内部类和厦名内部类只能访问局部final变量">为什么局部内部类和厦名内部类只能访问局部final变量？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_17、成员变量与局部变量的区别有哪些">17、成员变量与局部变量的区别有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_18、创建一个对象用什么运算符-对象实体与对象引用有何不同">18、创建一个对象用什么运算符?对象实体与对象引用有何不同?</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_19、对象的相等与指向他们的引用相等-两者有什么不同">19、对象的相等与指向他们的引用相等,两者有什么不同?</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_20、一个类的构造方法的作用是什么-若一个类没有声明构造方法-该程序能正确执行吗">20、一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_21、构造方法有哪些特点-是否可被-override">21、构造方法有哪些特点？是否可被 override?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_22、面向对象三大特征">22、面向对象三大特征</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#封装">封装</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#继承">继承</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#多态">多态</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#面向对象五大基本原则是什么">面向对象五大基本原则是什么</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_23、深拷贝和浅拷贝区别了解吗-什么是引用拷贝">23、深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_24、string、stringbuffer、stringbuilder-的区别-string-为什么是不可变的">24、String、StringBuffer、StringBuilder 的区别？String 为什么是不可变的?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_25、字符串拼接用-还是-stringbuilder">25、字符串拼接用“+” 还是 StringBuilder?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_26、字符串常量池的作用了解吗">26、字符串常量池的作用了解吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_27、final">27、final</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#final-有什么用">final 有什么用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#final-finally-finalize区别">final finally finalize区别</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_28、泛型">28、泛型</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#泛型的分类">泛型的分类</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#常用的通配符有哪些">常用的通配符有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#你的项目中哪里用到了泛型">你的项目中哪里用到了泛型？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_29、反射">29、反射</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1、谈谈你对反射的理解">1、谈谈你对反射的理解？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_2、反射机制优缺点">2、反射机制优缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_3、反射的应用场景">3、反射的应用场景</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_30、注解">30、注解</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_31、i-o">31、I/O</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#什么是序列化-什么是反序列化">什么是序列化?什么是反序列化?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#java-序列化中如果有些字段不想进行序列化-怎么办">Java 序列化中如果有些字段不想进行序列化，怎么办？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#获取用键盘输入常用的两种方法">获取用键盘输入常用的两种方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#java-中-io-流分为几种">Java 中 IO 流分为几种?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#既然有了字节流-为什么还要有字符流">既然有了字节流,为什么还要有字符流?</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_32、java-中-3-种常见-io-模型">32、Java 中 3 种常见 IO 模型</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#bio-blocking-i-o">BIO (Blocking I/O)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#nio-non-blocking-new-i-o">NIO (Non-blocking/New I/O)</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#aio">AIO</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_33、">33、</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_34、-和-的区别">34、&amp;和&amp;&amp;的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_35、抽象类和接口的区别">35、抽象类和接口的区别?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_36、this关键字的用法">36、this关键字的用法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_37、super关键字的用法">37、super关键字的用法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_38、是否了解连接池-使用连接池有什么好处">38、是否了解连接池，使用连接池有什么好处？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_39、hashcode-与equals-的相关规定">39、hashCode（）与equals（）的相关规定</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1、异常的含义">1、异常的含义</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_2、异常的作用">2、异常的作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_3、运行时异常与一般异常">3、运行时异常与一般异常</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_4、-error-和-exception-区别是什么">4、 Error 和 Exception 区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_5、throw-和-throws-的区别是什么">5、throw 和 throws 的区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_6、jvm如何处理异常">6、JVM如何处理异常</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_7、java异常关键字">7、Java异常关键字</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_8、final、finally、finalize-有什么区别">8、final、finally、finalize 有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_9、try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗">9、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_10、-java常见异常有哪些">10、 Java常见异常有哪些</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1、集合概述">1、集合概述：</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_2、集合框架">2、集合框架：</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_3、集合和数组的区别">3、集合和数组的区别：</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_4、list、set两者的区别">4、List、Set两者的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_5、hashmap、hashtable、hashset">5、HashMap、HashTable、HashSet</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_6、hashmap的存储原理">6、HashMap的存储原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_7、迭代器lterator">7、迭代器lterator</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_8、arraylist、linkedlist、vector">8、ArrayList、LinkedList、Vector</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_9、集合框架底层数据结构">9、集合框架底层数据结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_10、怎么确保一个集合不能被修改">10、怎么确保一个集合不能被修改？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_12、迭代器-iterator-是什么">12、迭代器 Iterator 是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_13、iterator-和-listiterator-有什么区别">13、Iterator 和 ListIterator 有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_14、list和set的区别">14、List和Set的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_15、arraylist和linkedlist的区别">15、ArrayList和LinkedList的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_16、hashmap和hasptable有什么区别">16、HashMap和hasptable有什么区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_17、说一下hashmap的put方法">17、说一下HashMap的Put方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_18、hashmap的扩容机制原理">18、HashMap的扩容机制原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_19、说一下-arraylist-的优缺点">19、说一下 ArrayList 的优缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_20、如何实现数组和-list-之间的转换">20、如何实现数组和 List 之间的转换？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_21、arraylist-和-vector-的区别是什么">21、ArrayList 和 Vector 的区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_22、说一下-hashset-的实现原理">22、说一下 HashSet 的实现原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_23、-hashset如何检查重复-hashset是如何保证数据不可重复的">23、 HashSet如何检查重复？HashSet是如何保证数据不可重复的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_24、说一下hashmap的实现原理">24、说一下HashMap的实现原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_25、hashmap在jdk1-7和jdk1-8中有哪些不同-hashmap的底层实现">25、HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_26、说说什么是红黑树">26、说说什么是红黑树</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_27、能否使用任何类作为-map-的-key">27、能否使用任何类作为 Map 的 key？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_28、hashmap-的长度为什么是2的幂次方">28、HashMap 的长度为什么是2的幂次方</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_29、hashmap-与-hashtable-有什么区别">29、HashMap 与 HashTable 有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_30、array-和-arraylist-有何区别">30、Array 和 ArrayList 有何区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_31、comparable-和-comparator的区别">31、comparable 和 comparator的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_32、collection和collections有什么区别">32、Collection和Collections有什么区别？</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1、为什么要使用多线程">1、为什么要使用多线程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_2、单线程和多线程的区别。">2、单线程和多线程的区别。</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_3、进程和线程">3、进程和线程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_4、并行和并发">4、并行和并发</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_5、线程的创建方式">5、线程的创建方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_6、线程的六种状态">6、线程的六种状态（）</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_7、如何停止一个正在运行的线程">7、如何停止一个正在运行的线程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_8、start-和run-方法的区别">8、start()和run()方法的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_9、为什么调用start-方法的时候会执行run-方法-而不能直接调用run-方法">9、为什么调用start()方法的时候会执行run()方法，而不能直接调用run()方法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_10、什么是线程安全">10、什么是线程安全？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_11、java中堆和栈的区别">11、Java中堆和栈的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_12、如何确保线程安全">12、如何确保线程安全？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_13、线程的安全级别">13、线程的安全级别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_14、线程类的构造方法和静态块是被哪个线程调用的">14、线程类的构造方法和静态块是被哪个线程调用的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_15、线程池的作用">15、线程池的作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_16、java中的死锁问题">16、Java中的死锁问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_17、如何避免死锁和检测">17、如何避免死锁和检测</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_18、synchronized底层原理">18、synchronized底层原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_19、生产者消费者模型的作用是什么">19、生产者消费者模型的作用是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_20、生产者消费者模式">20、生产者消费者模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_21、创建线程池的几种方法">21、创建线程池的几种方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_22、自定义线程池的配置">22、自定义线程池的配置</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_23、什么是乐观锁和悲观锁">23、什么是乐观锁和悲观锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_24、并发编程三要素是什么-在java程序中怎么保证多线程的运行安全">24、并发编程三要素是什么？在Java程序中怎么保证多线程的运行安全？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_25、volatile-关键字">25、volatile 关键字</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_26、乐观锁如何实现">26、乐观锁如何实现</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_27、sleep方法和wait方法有什么区别和共同点">27、sleep方法和wait方法有什么区别和共同点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_28、cas算法">28、CAS算法</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1、什么是java虚拟机-为何被称作-平台无关的编程语言">1、什么是Java虚拟机？为何被称作“平台无关的编程语言”？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_2、java的内存结构">2、Java的内存结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_3、内存分配">3、内存分配</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_4、类加载器">4、类加载器</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_5、jvm如何加载class文件">5、JVM如何加载class文件？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_6、java对象创建的过程">6、Java对象创建的过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_7、java对象的结构">7、Java对象的结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_8、类的生命周期">8、类的生命周期</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_9、什么情况下会发生栈溢出">9、什么情况下会发生栈溢出？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_10、java垃圾回收机制-gc是什么-为什么要gc">10、Java垃圾回收机制,GC是什么？为什么要GC?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_11、jvm新生代、老年代、持久代都存储些哪些东西">11、JVM新生代、老年代、持久代都存储些哪些东西？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_12、java会存在内存泄漏吗">12、Java会存在内存泄漏吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_13、jvm调优有哪些">13、JVM调优有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#说一下-jvm-调优的工具">说一下 JVM 调优的工具？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_14、如何判断对象可以被回收">14、如何判断对象可以被回收？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_15、-jvm的永久代中会发生垃圾回收么">15、 JVM的永久代中会发生垃圾回收么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_16、栈帧有哪些数据">16、栈帧有哪些数据？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_17、java的双亲委托机制是什么">17、Java的双亲委托机制是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_18、说一下堆栈的区别">18、说一下堆栈的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_19、队列和栈是什么-有什么区别">19、队列和栈是什么？有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_20、为对象分配内存">20、为对象分配内存</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_21、处理并发安全问题">21、处理并发安全问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_22、说一下-jvm-有哪些垃圾回收算法">22、说一下 JVM 有哪些垃圾回收算法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_23、分代概念">23、分代概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_24、为什么分代">24、为什么分代？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_25、jvm堆内存常用参数">25、JVM堆内存常用参数</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_26、类加载的过程">26、类加载的过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_27、java中的4种引用类型">27、Java中的4种引用类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1、什么是mysql">1、什么是MySQL</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_2、数据库三大范式">2、数据库三大范式</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_3、对慢查询怎么样优化过">3、对慢查询怎么样优化过？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_4、mysql有关权限的表都有哪几个">4、mysql有关权限的表都有哪几个</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_5、mysql由哪些部分组成">5、MySQL由哪些部分组成？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_6、优化数据库的方法">6、优化数据库的方法</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#优化查询过程中的数据访问">优化查询过程中的数据访问</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#优化长难的查询语句">优化长难的查询语句</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#优化特定类型的查询语句">优化特定类型的查询语句</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#优化关联查询">优化关联查询</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#优化子查询">优化子查询</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#优化group-by和distinct">优化GROUP BY和DISTINCT</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#优化limit分页">优化LIMIT分页</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#优化union查询">优化UNION查询</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_7、解释一下交叉连接、内连接、外连接">7、解释一下交叉连接、内连接、外连接</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#六种关联查询">六种关联查询</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#外连接-left-join-right-join">外连接（LEFT JOIN/RIGHT JOIN）</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#联合查询-union与union-all">联合查询（UNION与UNION ALL）</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#全连接-full-join">全连接（FULL JOIN）</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_8、为什么要使用notnull">8、为什么要使用NOTNULL？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_9、什么是索引">9、什么是索引？</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#索引有哪几种类型">索引有哪几种类型？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#索引的基本原理">索引的基本原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#索引设计的原则">索引设计的原则？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#创建索引的原则-重中之重">创建索引的原则（重中之重）</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#使用索引查询一定能提高查询的性能吗-为什么">使用索引查询一定能提高查询的性能吗？为什么</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_10、什么是事务">10、什么是事务？</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#mysql-事务隔离级别">MySQL 事务隔离级别</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_11、acid事务的特性">11、ACID事务的特性</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_12、并发事务带来了哪些问题">12、并发事务带来了哪些问题？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_13、mysql的四种隔离级别">13、MySQL的四种隔离级别</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#隔离级别与锁的关系">隔离级别与锁的关系</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_14、mysql存储引擎myisam与innodb区别">14、MySQL存储引擎MyISAM与InnoDB区别</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#myisam索引与innodb索引的区别">MyISAM索引与InnoDB索引的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#myisam与innodb区别">MyISAM与InnoDB区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#innodb引擎的4大特性">InnoDB引擎的4大特性</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_15、百万级别或以上的数据如何删除">15、百万级别或以上的数据如何删除</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_16、数据库为什么使用b-树而不是b树">16、数据库为什么使用B+树而不是B树</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_17、对mysql的锁了解吗">17、对MySQL的锁了解吗？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_18、为什么要使用视图-什么是视图">18、为什么要使用视图？什么是视图？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_19、视图有哪些特点">19、视图有哪些特点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_20、视图的使用场景有哪些">20、视图的使用场景有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_21、视图的优点">21、视图的优点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_22、视图的缺点">22、视图的缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_23、存储过程与函数">23、存储过程与函数</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_24、什么是触发器-触发器的使用场景有哪些">24、什么是触发器？触发器的使用场景有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_25、超键、候选键、主键、外键分别是什么">25、超键、候选键、主键、外键分别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_26、什么是子查询">26、什么是子查询？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_27、mysql中-in-和-exists-区别">27、mysql中 in 和 exists 区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_28、大表数据查询-怎么优化">28、大表数据查询，怎么优化？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_29、超大分页怎么处理">29、超大分页怎么处理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_30、关心过业务系统里面的sql耗时吗-统计过慢查询吗-对慢查询都怎么优化过">30、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_31、char-和varchar-的区别">31、CHAR 和VARCHAR 的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_32、数据库索引的原理-为什么要用b-树-为什么不用二叉树">32、数据库索引的原理，为什么要用B+树，为什么不用二叉树？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_33、数据库自增主键可能遇到什么问题">33、数据库自增主键可能遇到什么问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_34、blob和text有什么区别">34、Blob和text有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_35、count-1-、count-与-count-列名-的区别">35、count(1)、count(*) 与 count(列名) 的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_36、查询语句执行流程">36、查询语句执行流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_37、mysql锁">37、MySQL锁</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1、全局锁">1、全局锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_2、表级锁">2、表级锁</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_3、行级锁">3、行级锁</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_38、什么是最左前缀原则-什么是最左匹配原则">38、什么是最左前缀原则？什么是最左匹配原则</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_39、什么是聚簇索引-何时使用聚簇索引与非聚簇索引">39、什么是聚簇索引？何时使用聚簇索引与非聚簇索引</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_40、联合索引是什么-为什么需要注意联合索引中的顺序">40、联合索引是什么？为什么需要注意联合索引中的顺序？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_41、sql语句主要分为哪几类">41、SQL语句主要分为哪几类</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_42、超键、候选键、主键、外键分别是什么">42、超键、候选键、主键、外键分别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_43、sql-约束有哪几种">43、SQL 约束有哪几种？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_44、varchar-50-中50的涵义">44、varchar(50)中50的涵义</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_45、int-20-中20的涵义">45、int(20)中20的涵义</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_46、为什么要尽量设定一个主键">46、为什么要尽量设定一个主键？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_47、mysql的复制原理以及流程">47、MySQL的复制原理以及流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_48、mysql主从复制的作用">48、MySQL主从复制的作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_49、mysql主从复制工作原理">49、MySQL主从复制工作原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_50、什么是死锁-怎么解决">50、什么是死锁？怎么解决？</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_51、数据库的乐观锁和悲观锁是什么-怎么实现的">51、数据库的乐观锁和悲观锁是什么？怎么实现的？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_51、drop、delete与truncate的区别">51、drop、delete与truncate的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_52、union与unionall的区别">52、UNION与UNIONALL的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_53、按照锁的粒度分数据库锁有哪些">53、按照锁的粒度分数据库锁有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_54、数据库中有六种触发器">54、数据库中有六种触发器</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_55、hash索引和b-树索引有什么区别或者说优劣呢">55、Hash索引和B+树索引有什么区别或者说优劣呢?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#spring">Spring</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1、什么是spring">1、什么是Spring：</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_2、你们项目中为什么使用spring框架">2、你们项目中为什么使用Spring框架？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_3、autowired和resource关键字的区别">3、Autowired和Resource关键字的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_4、依赖注入的方式有几种-各是什么">4、依赖注入的方式有几种，各是什么?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_5、说说你对spring的ioc是怎么理解的">5、说说你对Spring的IOC是怎么理解的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_6、谈谈你对spring的aop理解">6、谈谈你对Spring的AOP理解</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_7、spring-aop和aspectj-aop有什么区别">7、Spring AOP和AspectJ AOP有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_8、在spring-aop-中-关注点和横切关注的区别是什么">8、在Spring AOP 中，关注点和横切关注的区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_9、什么是通知呢-有哪些类型呢">9、什么是通知呢？有哪些类型呢？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_10、解释一下spring-bean的生命周期">10、解释一下spring bean的生命周期</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_11、解释spring支持的几种bean的作用域">11、解释Spring支持的几种bean的作用域？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_12、静态代理和动态代理的区别">12、静态代理和动态代理的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_13、jdk动态代理和cglib动态代理的区别">13、JDK动态代理和CGLIB动态代理的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_14、spring框架中都用到了哪些设计模式">14、Spring框架中都用到了哪些设计模式？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_15、说说spring-中-applicationcontext-和-beanfactory-的区别">15、说说Spring 中 ApplicationContext 和 BeanFactory 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_16、spring-框架中的单例-bean-是线程安全的么">16、Spring 框架中的单例 Bean 是线程安全的么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_17、spring-是怎么解决循环依赖的">17、Spring 是怎么解决循环依赖的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_18、spring-管理事务的方式有几种">18、Spring 管理事务的方式有几种？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_19、spring-事务中的隔离级别有哪几种">19、Spring 事务中的隔离级别有哪几种?</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#springmvc">SpringMVC</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1、springmvc的执行流程">1、SpringMVC的执行流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_2、springmvc中的拦截器和servlet中的filter过滤器的区别">2、SpringMVC中的拦截器和Servlet中的Filter过滤器的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_3、什么是spring-mvc-简单介绍下你对spring-mvc的理解">3、什么是Spring MVC？简单介绍下你对Spring MVC的理解？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_4、spring-mvc的控制器是不是单例模式-如果是-有什么问题-怎么解决">4、Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_5、mvc是什么-mvc设计模式的好处有哪些">5、MVC是什么？MVC设计模式的好处有哪些</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_6、spring-mvc常用的注解有哪些">6、Spring MVC常用的注解有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_7、spring-mvc怎么样设定重定向和转发的">7、Spring MVC怎么样设定重定向和转发的？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#mybatis">MyBatis</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1、介绍一下mybatis">1、介绍一下MyBatis：</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_2、orm是什么">2、ORM是什么</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_3、为什么说mybatis是半自动orm映射工具-它与全自动的区别在哪里">3、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_4、传统jdbc开发存在的问题">4、传统JDBC开发存在的问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_5、jdbc编程有哪些不足之处-mybatis是如何解决这些问题的">5、JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_6、mybatis优缺点">6、Mybatis优缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_7、hibernate-和-mybatis-的区别">7、Hibernate 和 MyBatis 的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_8、mybatis编程步骤是什么样的">8、MyBatis编程步骤是什么样的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_9、请说说mybatis的工作原理">9、请说说MyBatis的工作原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_10、mybatis都有哪些executor执行器-它们之间的区别是什么">10、Mybatis都有哪些Executor执行器？它们之间的区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_11、mybatis是否支持延迟加载-如果支持-它的实现原理是什么">11、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_12、mybatis-和-的区别">12、MyBatis#{}和${}的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_13、mybatis如何获取生成的主键">13、MyBatis如何获取生成的主键</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_14、使用mybatis的mapper接口调用时有哪些要求">14、使用MyBatis的mapper接口调用时有哪些要求？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_16、mybatis实现一对一-一对多有几种方式-怎么操作的">16、MyBatis实现一对一，一对多有几种方式，怎么操作的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_17、mybatis动态sql是做什么的-都有哪些动态sql-能简述一下动态sql的执行原理不">17、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_18、mybatis是如何进行分页的-分页插件的原理是什么">18、Mybatis是如何进行分页的？分页插件的原理是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_19、mybatis的一级、二级缓存">19、Mybatis的一级、二级缓存</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#ssm">SSM</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1、ssm分工">1、SSM分工：</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1、什么是springboot">1、什么是SpringBoot</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_2、spring-boot-有哪些优点">2、Spring Boot 有哪些优点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_3、spring-boot-的核心注解是哪个-它主要由哪几个注解组成的">3、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_4、spring-boot-自动配置原理是什么">4、Spring Boot 自动配置原理是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_5、spring-boot-配置加载顺序详解">5、Spring Boot 配置加载顺序详解</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_6、yaml-配置的优势在哪里">6、YAML 配置的优势在哪里 ?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_7、spring-boot-中如何解决跨域问题">7、Spring Boot 中如何解决跨域问题 ?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_8、springboot打成的jar和普通的jar有什么区别">8、SpringBoot打成的jar和普通的jar有什么区别?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_9、什么是yaml">9、什么是YAML？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_10、spring-boot、spring-mvc-和-spring-有什么区别">10、Spring Boot、Spring MVC 和 Spring 有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_11、spring-boot-中如何解决跨域问题">11、Spring Boot 中如何解决跨域问题 ?</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_12、什么是-csrf-攻击">12、什么是 CSRF 攻击？</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_14、springboot支持哪些日志框架-推荐和默认的日志框架是哪个">14、SpringBoot支持哪些日志框架？推荐和默认的日志框架是哪个？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_15、springboot-starter的工作原理">15、SpringBoot Starter的工作原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_16、springboot多数据源事务如何管理">16、SpringBoot多数据源事务如何管理</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_17、springboot中如何实现定时任务">17、SpringBoot中如何实现定时任务 ?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_18、spring-boot-starter-parent有什么用">18、spring-boot-starter-parent有什么用?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1、什么是springcloud">1、什么是SpringCloud</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_2、互联网架构演进">2、互联网架构演进</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1、单体应用架构">1、单体应用架构</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_2、垂直应用架构">2、垂直应用架构</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_3、soa应用架构">3、SOA应用架构</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_4、微服务应用架构">4、微服务应用架构</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_3、什么是服务注册与服务发现。">3、什么是服务注册与服务发现。</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_4、springboot和springcloud的区别">4、SpringBoot和SpringCloud的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_5、spring-cloud的优缺点有哪些">5、Spring Cloud的优缺点有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_6、eureka的服务治理是什么">6、Eureka的服务治理是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_7、eureka的服务注册是什么">7、Eureka的服务注册是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_8、什么是spring-cloud-ribbon">8、什么是Spring Cloud Ribbon？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_9、nginx和ribbon的区别">9、Nginx和Ribbon的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_10、ribbon支持的负载均衡算法">10、Ribbon支持的负载均衡算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_11、服务器雪崩">11、服务器雪崩</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_12、hystrix熔断器">12、Hystrix熔断器</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_13、feign">13、Feign</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_14、gateway的作用">14、Gateway的作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_15、gateway的工作流程">15、Gateway的工作流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_16、gateway的路由规则">16、Gateway的路由规则</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_17、gateway的过滤使用">17、Gateway的过滤使用</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_18、什么是spring-cloud-alibaba">18、什么是Spring Cloud Alibaba?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_19、spring-cloud-alibaba有哪些功能">19、Spring Cloud Alibaba有哪些功能？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_20、spring-cloud-alibaba的常用组件有哪些">20、Spring Cloud Alibaba的常用组件有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_21、什么是nacos">21、什么是Nacos？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_22、nacos有什么作用">22、Nacos有什么作用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_23、什么是spring-cloud-seata">23、什么是Spring Cloud Seata？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1、为什么要用缓存">1、为什么要用缓存</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_2、使用-redis有哪些好处">2、使用 Redis有哪些好处？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_3、什么是-redis">3、什么是 Redis？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_4、为什么redis单线程模型效率也能那么高">4、为什么Redis单线程模型效率也能那么高？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_5、为什么-redis-需要把所有数据放到内存中">5、为什么 Redis 需要把所有数据放到内存中？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_6、redis-的同步机制了解是什么">6、Redis 的同步机制了解是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_7、说一下redis有什么优点和缺点">7、说一下Redis有什么优点和缺点</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_8、redis的淘汰策略">8、Redis的淘汰策略</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_9、redis-为什么设计成单线程的">9、Redis 为什么设计成单线程的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_10、redis五种数据类型">10、Redis五种数据类型</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_11、redis集群一般需要几台服务器">11、Redis集群一般需要几台服务器？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_12、什么是缓存穿透-如何避免">12、什么是缓存穿透，如何避免</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_13、什么是缓存雪崩-如何避免">13、什么是缓存雪崩，如何避免</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_14、redis-的持久化机制是什么-各自的优缺点">14、Redis 的持久化机制是什么？各自的优缺点？</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#rdb">RDB：</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#aof">AOF：</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#rabbitmq">RabbitMQ</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1、mq的优势">1、MQ的优势</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_2、你们项目中用到过-mq-吗-谈谈你对-mq-的理解">2、你们项目中用到过 MQ 吗？谈谈你对 MQ 的理解？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_3、常用的mq">3、常用的MQ</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_4、mq消费者消费消息的顺序一致性问题">4、MQ消费者消费消息的顺序一致性问题？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_5、rabbitmq如何保证数据一致性">5、RabbitMQ如何保证数据⼀致性？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_6、如何确保消息正确地发送至rabbitmq">6、如何确保消息正确地发送⾄RabbitMQ？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_7、如何避免消息重复投递或重复消费">7、如何避免消息重复投递或重复消费？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_8、rabbitmq的工作模式">8、RabbitMQ的工作模式</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#elasticsearch">ElasticSearch</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1、elasticsearch-了解多少-说说你们公司-es-的集群架构-索引数据大小-分片有多少-以及一些调优手段">1、elasticsearch 了解多少，说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_2、为什么要使用elasticsearch">2、为什么要使用elasticsearch</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_3、项目中如何使用elasticsearch">3、项目中如何使用elasticsearch</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_4、谈谈分词与倒排索引的原理">4、谈谈分词与倒排索引的原理</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#sharing-jdbc">Sharing-JDBC</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1、shards-replicas分片和复制">1、Shards&amp;Replicas分片和复制：</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_2、、分库分表">2、、分库分表</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_3、垂直分库">3、垂直分库</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_4、水平分库">4、水平分库</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_5、垂直分表">5、垂直分表</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_6、水平分表">6、水平分表</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_7、sharing-jdbc定义">7、Sharing-JDBC定义</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#docker">Docker</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1、简介">1、简介</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_2、docker基本概念">2、Docker基本概念</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1-1-概述">1.1 概述</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1-2-数组">1.2 数组</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1-3-栈">1.3 栈</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1-3-1-概述">1.3.1 概述</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1-4-队列">1.4 队列</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1-5-链表">1.5 链表</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1-6-树">1.6 树</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1-6-1-树">1.6.1 树</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1-6-2-二叉树">1.6.2 二叉树</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1-6-3-满二叉树">1.6.3 满二叉树</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1-6-4-完全二叉树">1.6.4 完全二叉树</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1-6-5-二叉查找树">1.6.5 二叉查找树</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1-6-6-平衡二叉树">1.6.6 平衡二叉树</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1-6-7-红黑树">1.6.7 红黑树</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1-7-哈希表">1.7 哈希表</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1-7-2-哈希冲突">1.7.2 哈希冲突</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1-8-对比">1.8 对比</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_2、简单算法">2、简单算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_3、懒汉和饿汉">3、懒汉和饿汉</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#冒泡排序">冒泡排序</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#选择排序">选择排序</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#二分法查找">二分法查找</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1、oa工作流activiti">1、OA工作流Activiti</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#定义-业务过程部分或整体-在计算机应用环境下的自动化">定义：业务过程部分或整体，在计算机应用环境下的自动化</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#工作流管理系统">工作流管理系统：</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#主要作用">主要作用：</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_2、微信登录">2、微信登录</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_3、微信支付">3、微信支付</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_4、单点登录">4、单点登录</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_5、并发量大的话如何处理">5、并发量大的话如何处理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_6、预计吞吐量">6、预计吞吐量</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_7、文件上传如何处理断点续传">7、文件上传如何处理断点续传？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_8、redis分布式锁怎么实现的-当同时有多个······他是怎么处理的">8、redis分布式锁怎么实现的，当同时有多个······他是怎么处理的</a></li><li><ul class="toc-list"><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_1、实现分布式锁的思路">1、实现分布式锁的思路</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level3 toc-link level3" href="/toLeoJavaer/#_2、redisson">2、Redisson</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1、什么是servlet">1、什么是Servlet</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_2、什么是servlet对象的生命周期">2、什么是Servlet对象的生命周期</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_3、jsp九大内置对象">3、JSP九大内置对象</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_4、jsp和servlet的区别">4、JSP和Servlet的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_5、转发和重定向的区别">5、转发和重定向的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_6、session-和-cookie-有什么区别">6、session 和 cookie 有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_7、get和post的区别">7、get和post的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_8、说一下-session-的工作原理">8、说一下 session 的工作原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_9、简述-tcp-和-udp的区别">9、简述 TCP 和 UDP的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_10、什么是三次握手-四次挥手">10、什么是三次握手，四次挥手 ？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#四次挥手">四次挥手</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_11、tcp-为什么要三次握手-两次不行吗-为什么">11、tcp 为什么要三次握手，两次不行吗？为什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1、git和svn的区别">1、Git和SVN的区别</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_2、什么是git">2、什么是Git</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_3、git的工作流程">3、Git的工作流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1、什么是maven">1、什么是maven？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_2、说说maven有什么优缺点">2、说说maven有什么优缺点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_3、讲一下maven的生命周期">3、讲一下maven的生命周期</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_4、说说你熟悉哪些maven命令">4、说说你熟悉哪些maven命令？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_5、">5、</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_1、为什么从上家公司离职">1、为什么从上家公司离职？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_2、你对加班怎么看待">2、你对加班怎么看待？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_3、如果公司录用你-你会在公司工作多久">3、如果公司录用你,你会在公司工作多久?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_4、你最大的优缺点">4、你最大的优缺点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_5、希望去怎么样的公司">5、希望去怎么样的公司?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_6、你工作中遇到哪些bug-怎么解决的">6、你工作中遇到哪些bug,怎么解决的?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_7、和同事或经理起冲突怎么办">7、和同事或经理起冲突怎么办?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_8、三到五年的规划">8、三到五年的规划?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_9、上家公司的人员组成">9、上家公司的人员组成?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_10、项目经理给了一个超出你能力的需求-你怎么办">10、项目经理给了一个超出你能力的需求，你怎么办？</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_11、你和别人比-你觉得他们强的地方在哪里">11、你和别人比,你觉得他们强的地方在哪里?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_12、你对自己评价如何">12、你对自己评价如何?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_13、你还有什么问题要问">13、你还有什么问题要问?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_14、你能为我们公司带来什么">14、你能为我们公司带来什么?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_15、能不能接受出差-有没有打算做项目经理">15、能不能接受出差?有没有打算做项目经理?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_16、如果你刚入职-将会如何开展工作">16、如果你刚入职,将会如何开展工作?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_17、谈谈你对跳槽的看法">17、谈谈你对跳槽的看法?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_18、你的朋友对你评价">18、你的朋友对你评价?</a></li><!----><!--]--><!--[--><li class="toc-item"><a class="vp-link toc-link level2 toc-link level2" href="/toLeoJavaer/#_19、说说开发中-你的性格、经验、视野、基础如何">19、说说开发中，你的性格、经验、视野、基础如何?</a></li><!----><!--]--></ul><div class="toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><h1 id="一、java基础" tabindex="-1"><a class="header-anchor" href="#一、java基础" aria-hidden="true">#</a> 一、Java基础</h1><h2 id="_1、java-语言有哪些特点" tabindex="-1"><a class="header-anchor" href="#_1、java-语言有哪些特点" aria-hidden="true">#</a> 1、Java 语言有哪些特点</h2><ol><li><p>简单易学；</p></li><li><p>面向对象（封装，继承，多态）；</p></li><li><p>平台无关性（ Java 虚拟机实现平台无关性）；</p></li><li><p>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</p></li><li><p>可靠性；</p></li><li><p>安全性；</p></li><li><p>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）。</p></li><li><p>编译与解释并存；</p></li></ol><h2 id="_2、jvm、jre和jdk的关系" tabindex="-1"><a class="header-anchor" href="#_2、jvm、jre和jdk的关系" aria-hidden="true">#</a> 2、JVM、JRE和JDK的关系</h2><p>JVM<br> Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p><p>JRE<br> Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p><p>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p><p>JDK<br> Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230205143341812.png" alt="image-20230205143341812" style="zoom:67%;"><h2 id="_3、字符型常量和字符串常量的区别" tabindex="-1"><a class="header-anchor" href="#_3、字符型常量和字符串常量的区别" aria-hidden="true">#</a> 3、字符型常量和字符串常量的区别?</h2><ol><li><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符</li><li><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li><strong>占内存大小</strong> ： 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： <code>char</code> 在 Java 中占两个字节</strong>),</li></ol><h2 id="_4、注释有哪几种" tabindex="-1"><a class="header-anchor" href="#_4、注释有哪几种" aria-hidden="true">#</a> 4、注释有哪几种</h2><p>Java 中的注释有三种：</p><ol><li>单行注释</li><li>多行注释</li><li>文档注释。</li></ol><h2 id="_5、标识符和关键字的区别" tabindex="-1"><a class="header-anchor" href="#_5、标识符和关键字的区别" aria-hidden="true">#</a> 5、标识符和关键字的区别</h2><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了标识符，简单来说，标识符就是一个名字。但是有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这种特殊的标识符就是关键字。因此，关键字是被赋予特殊含义的标识符。比如，在我们的日常生活中 ，“警察局”这个名字已经被赋予了特殊的含义，所以如果你开一家店，店的名字不能叫“警察局”，“警察局”就是我们日常生活中的关键字。</p><p>Java 中常见的关键字</p><table><thead><tr><th>分类</th><th>关键字</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td>类，方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td></td></tr><tr><td>程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td></td><td></td></tr><tr><td>错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td>包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td></td><td>short</td><td>null</td><td>true</td><td>false</td><td></td><td></td><td></td></tr><tr><td>变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td>保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>Final</strong></p><p>(1) 类不能被继承</p><p>(2) 子类中，方法不能被重写，JVM会尝试将其关联。</p><p>(3) 变量为常量，编译阶段存储在常量池中。</p><p><strong>Static</strong></p><p>(1) 修饰的类可以直接通过类来调用，而不需要new</p><p>(2) 修饰的方法块，JVM会有限加载。</p><p>(3) 修饰的变量，分配在内存堆上，引用时指向同一个地质，而不会重新分配内存空间。</p><h2 id="_6、自增自减运算符" tabindex="-1"><a class="header-anchor" href="#_6、自增自减运算符" aria-hidden="true">#</a> 6、自增自减运算符</h2><p>在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（--）。</p><p>++ 和 -- 运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 <code>b = ++a</code> 时，先自增（自己增加 1），再赋值（赋值给 b）；当 <code>b = a++</code> 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”。</p><h2 id="_7、continue、break-和-return-的区别" tabindex="-1"><a class="header-anchor" href="#_7、continue、break-和-return-的区别" aria-hidden="true">#</a> 7、continue、break 和 return 的区别</h2><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p><ol><li><code>continue</code> ：指跳出当前的这一次循环，继续下一次循环。</li><li><code>break</code> ：指跳出整个循环体，继续执行循环下面的语句。</li></ol><p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p><ol><li><code>return;</code> ：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><code>return value;</code> ：return 一个特定值，用于有返回值函数的方法</li></ol><h2 id="_8、静态方法为什么不能调用非静态成员" tabindex="-1"><a class="header-anchor" href="#_8、静态方法为什么不能调用非静态成员" aria-hidden="true">#</a> 8、静态方法为什么不能调用非静态成员?</h2><p>这个需要结合 JVM 的相关知识，主要原因如下：</p><ol><li><p>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p></li><li><p>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p></li></ol><h2 id="_9、静态方法和实例方法有何不同" tabindex="-1"><a class="header-anchor" href="#_9、静态方法和实例方法有何不同" aria-hidden="true">#</a> 9、静态方法和实例方法有何不同？</h2><p><strong>1、调用方式</strong></p><p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p><p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p><p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p><p><strong>2、访问类成员是否存在限制</strong></p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p><h2 id="_10、重载和重写的区别" tabindex="-1"><a class="header-anchor" href="#_10、重载和重写的区别" aria-hidden="true">#</a> 10、重载和重写的区别</h2><ol><li>重载发生在本类，重写发生在父类与子类之间；</li><li>重载的方法名必须相同，重写的方法名相同且返回值类型必须相同；</li><li>重载的参数列表不同，重写的参数列表必须相同。</li><li>重写抛出的异常要比父类抛出的异常要大，访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li></ol><h2 id="_11、-和-equals-的区别" tabindex="-1"><a class="header-anchor" href="#_11、-和-equals-的区别" aria-hidden="true">#</a> 11、== 和 equals() 的区别</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/20230218214110.png" alt="image.png" tabindex="0" loading="lazy"><figcaption>image.png</figcaption></figure><h2 id="_12、hashcode-与-equals" tabindex="-1"><a class="header-anchor" href="#_12、hashcode-与-equals" aria-hidden="true">#</a> 12、hashCode() 与 equals()</h2><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p><p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p><p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></p><ul><li><p>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</p></li><li><p>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法返回 <code>true</code>，我们才认为这两个对象相等。</p></li><li><p>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</p></li></ul><h2 id="_13、为什么重写-equals-时必须重写-hashcode-方法" tabindex="-1"><a class="header-anchor" href="#_13、为什么重写-equals-时必须重写-hashcode-方法" aria-hidden="true">#</a> 13、为什么重写 equals() 时必须重写 hashCode() 方法？</h2><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p><strong>思考</strong> ：重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p><p><strong>总结</strong> ：</p><ul><li><p><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p></li><li><p>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code> java规定：
如果两个对象的hashCode()相等，那么他们的equals()不一定相等。
如果两个对象的equals()相等，那么他们的hashCode()必定相等。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="_14、基本数据类型" tabindex="-1"><a class="header-anchor" href="#_14、基本数据类型" aria-hidden="true">#</a> 14、基本数据类型</h2><p>Java 中有 8 种基本数据类型，分别为：</p><ol><li>6 种数字类型 ：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code>。</li></ol><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><table><thead><tr><th>基本类型</th><th>位数</th><th>字节</th><th>默认值</th></tr></thead><tbody><tr><td><code>int</code></td><td>32</td><td>4</td><td>0</td></tr><tr><td><code>short</code></td><td>16</td><td>2</td><td>0</td></tr><tr><td><code>long</code></td><td>64</td><td>8</td><td>0L</td></tr><tr><td><code>byte</code></td><td>8</td><td>1</td><td>0</td></tr><tr><td><code>char</code></td><td>16</td><td>2</td><td>&#39;u0000&#39;</td></tr><tr><td><code>float</code></td><td>32</td><td>4</td><td>0f</td></tr><tr><td><code>double</code></td><td>64</td><td>8</td><td>0d</td></tr><tr><td><code>boolean</code></td><td>1</td><td>1</td><td>false</td></tr></tbody></table><p>另外，对于 <code>boolean</code>，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p><p><strong>注意：</strong></p><ol><li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li><li><code>char a = &#39;h&#39;</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号。</li></ol><p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</p><p>包装类型不赋值就是 <code>Null</code> ，而基本类型有默认值且不是 <code>Null</code>。</p><p>另外，这个问题建议还可以先从 JVM 层面来分析。</p><p>基本数据类型直接存放在 Java 虚拟机栈中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。</p><h2 id="_15、包装类型的常量池技术" tabindex="-1"><a class="header-anchor" href="#_15、包装类型的常量池技术" aria-hidden="true">#</a> 15、包装类型的常量池技术</h2><p>Java 基本类型的包装类的大部分都实现了常量池技术。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p><strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p><h2 id="_16、内部类" tabindex="-1"><a class="header-anchor" href="#_16、内部类" aria-hidden="true">#</a> 16、内部类</h2><h3 id="什么是内部类" tabindex="-1"><a class="header-anchor" href="#什么是内部类" aria-hidden="true">#</a> 什么是内部类？</h3><p>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是<strong>内部类</strong>。内部类本身就是类的一个属性，与其他属性定义方式一致。</p><h3 id="内部类的分类" tabindex="-1"><a class="header-anchor" href="#内部类的分类" aria-hidden="true">#</a> 内部类的分类</h3><p>内部类可以分为四种：<strong>成员内部类、局部内部类、匿名内部类和静态内部类</strong>。</p><h3 id="静态内部类" tabindex="-1"><a class="header-anchor" href="#静态内部类" aria-hidden="true">#</a> 静态内部类</h3><p>定义在类内部的静态类，就是静态内部类。</p><h3 id="成员内部类" tabindex="-1"><a class="header-anchor" href="#成员内部类" aria-hidden="true">#</a> 成员内部类</h3><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p><h3 id="局部内部类" tabindex="-1"><a class="header-anchor" href="#局部内部类" aria-hidden="true">#</a> 局部内部类</h3><p>定义在方法中的内部类，就是局部内部类。</p><h3 id="匿名内部类" tabindex="-1"><a class="header-anchor" href="#匿名内部类" aria-hidden="true">#</a> 匿名内部类</h3><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p><p>除了没有名字，匿名内部类还有以下特点：</p><ul><li>匿名内部类必须继承一个抽象类或者实现一个接口。</li><li>匿名内部类不能定义任何静态成员和静态方法。</li><li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li></ul><h3 id="内部类的优点" tabindex="-1"><a class="header-anchor" href="#内部类的优点" aria-hidden="true">#</a> 内部类的优点</h3><p>我们为什么要使用内部类呢？因为它有以下优点：</p><ul><li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li><li>内部类不为同一包的其他类所见，具有很好的封装性；</li><li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li><li>匿名内部类可以很方便的定义回调。</li></ul><h3 id="为什么局部内部类和厦名内部类只能访问局部final变量" tabindex="-1"><a class="header-anchor" href="#为什么局部内部类和厦名内部类只能访问局部final变量" aria-hidden="true">#</a> 为什么局部内部类和厦名内部类只能访问局部final变量？</h3><blockquote><p>因为局部内部类和匿名内部类是在方法体内部定义的，而局部变量是在方法体内部定义的，而且局部变量的生命周期只在方法体内部，当方法体执行完毕后，局部变量就会被销毁，而局部内部类和匿名内部类可能会在方法体外部使用，所以为了保证局部内部类和匿名内部类可以正常使用，只能访问局部final变量，因为final变量的生命周期比局部变量更长，所以可以保证局部内部类和匿名内部类可以正常使用。</p></blockquote><h2 id="_17、成员变量与局部变量的区别有哪些" tabindex="-1"><a class="header-anchor" href="#_17、成员变量与局部变量的区别有哪些" aria-hidden="true">#</a> 17、成员变量与局部变量的区别有哪些？</h2><ul><li><p><strong>语法形式</strong> ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</p></li><li><p><strong>存储方式</strong> ：从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</p></li><li><p><strong>生存时间</strong> ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p></li><li><p><strong>默认值</strong> ：从变量是否有默认值来看，成员变量如果没有被赋初，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p></li></ul><h2 id="_18、创建一个对象用什么运算符-对象实体与对象引用有何不同" tabindex="-1"><a class="header-anchor" href="#_18、创建一个对象用什么运算符-对象实体与对象引用有何不同" aria-hidden="true">#</a> 18、创建一个对象用什么运算符?对象实体与对象引用有何不同?</h2><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p><p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p><h3 id="_19、对象的相等与指向他们的引用相等-两者有什么不同" tabindex="-1"><a class="header-anchor" href="#_19、对象的相等与指向他们的引用相等-两者有什么不同" aria-hidden="true">#</a> 19、对象的相等与指向他们的引用相等,两者有什么不同?</h3><ul><li><p>对象的相等一般比较的是内存中存放的内容是否相等。</p></li><li><p>引用相等一般比较的是他们指向的内存地址是否相等。</p></li></ul><h2 id="_20、一个类的构造方法的作用是什么-若一个类没有声明构造方法-该程序能正确执行吗" tabindex="-1"><a class="header-anchor" href="#_20、一个类的构造方法的作用是什么-若一个类没有声明构造方法-该程序能正确执行吗" aria-hidden="true">#</a> 20、一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗?</h2><p>构造方法主要作用是完成对类对象的初始化工作。</p><p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p><h2 id="_21、构造方法有哪些特点-是否可被-override" tabindex="-1"><a class="header-anchor" href="#_21、构造方法有哪些特点-是否可被-override" aria-hidden="true">#</a> 21、构造方法有哪些特点？是否可被 override?</h2><p>构造方法特点如下：</p><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p><h2 id="_22、面向对象三大特征" tabindex="-1"><a class="header-anchor" href="#_22、面向对象三大特征" aria-hidden="true">#</a> 22、面向对象三大特征</h2><h3 id="封装" tabindex="-1"><a class="header-anchor" href="#封装" aria-hidden="true">#</a> 封装</h3><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p><h3 id="继承" tabindex="-1"><a class="header-anchor" href="#继承" aria-hidden="true">#</a> 继承</h3><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><h3 id="多态" tabindex="-1"><a class="header-anchor" href="#多态" aria-hidden="true">#</a> 多态</h3><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p><strong>多态的特点:</strong></p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><h3 id="面向对象五大基本原则是什么" tabindex="-1"><a class="header-anchor" href="#面向对象五大基本原则是什么" aria-hidden="true">#</a> 面向对象五大基本原则是什么</h3><ul><li>单一职责原则SRP(Single Responsibility Principle)<br> 类的功能要单一，不能包罗万象，跟杂货铺似的。</li><li>开放封闭原则OCP(Open－Close Principle)<br> 一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</li><li>里式替换原则LSP(the Liskov Substitution Principle LSP)<br> 子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</li><li>依赖倒置原则DIP(the Dependency Inversion Principle DIP)<br> 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</li><li>接口分离原则ISP(the Interface Segregation Principle ISP)<br> 设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</li></ul><h2 id="_23、深拷贝和浅拷贝区别了解吗-什么是引用拷贝" tabindex="-1"><a class="header-anchor" href="#_23、深拷贝和浅拷贝区别了解吗-什么是引用拷贝" aria-hidden="true">#</a> 23、深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h2><ul><li><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p></li><li><p><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p></li><li><p><strong>引用拷贝</strong>： 两个不同的引用指向同一个对象。</p><figure><img src="https://snailclimb.gitee.io/javaguide/docs/java/basis/images/shallow&amp;deep-copy.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure></li></ul><h2 id="_24、string、stringbuffer、stringbuilder-的区别-string-为什么是不可变的" tabindex="-1"><a class="header-anchor" href="#_24、string、stringbuffer、stringbuilder-的区别-string-为什么是不可变的" aria-hidden="true">#</a> 24、String、StringBuffer、StringBuilder 的区别？String 为什么是不可变的?</h2><p><strong>可变性</strong></p><p>String内部的value值是final修饰的，所以它是不可变类。所以每次修改String的值，都会产生一个新的对象。StringBuffer和StringBuilder是可变类，字符串的变更不会产生新的对象。</p><p><strong>线程安全性</strong></p><p>String是不可变类，所以它是线程安全的。StringBuffer是线程安全的，因为它每个操作方法都加了synchronized同步关键字。StringBuilder不是线程安全的，所以在多线程环境下对字符串进行操作，应该使用StringBuffer，否则使用StringBuilder</p><p><strong>性能</strong></p><p>String的性能是最的低的，因为不可变意味着在做字符串拼接和修改的时候，需要重新创建新的对象以及分配内存。其次是StringBuffer要比String性能高，因为它的可变性使得字符串可以直接被修改最后是StringBuilder，它比StringBuffer的性能高，因为StringBuffer加了同步锁。</p><p><strong>存储方面</strong></p><p>String存储在字符串常量池里面StringBuffer和StringBuilder存储在堆内存空间。</p><p><strong>总结：</strong></p><ol><li><p>操作少量的数据: 适用 <code>String</code></p></li><li><p>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></p></li><li><p>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></p></li></ol><h2 id="_25、字符串拼接用-还是-stringbuilder" tabindex="-1"><a class="header-anchor" href="#_25、字符串拼接用-还是-stringbuilder" aria-hidden="true">#</a> 25、字符串拼接用“+” 还是 StringBuilder?</h2><p>Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的元素符。</p><p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p><h2 id="_26、字符串常量池的作用了解吗" tabindex="-1"><a class="header-anchor" href="#_26、字符串常量池的作用了解吗" aria-hidden="true">#</a> 26、字符串常量池的作用了解吗？</h2><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">String</span> aa <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 放在常量池中</span>
<span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token string">&quot;ab&quot;</span><span class="token punctuation">;</span> <span class="token comment">// 从常量池中查找</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aa<span class="token operator">==</span>bb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_27、final" tabindex="-1"><a class="header-anchor" href="#_27、final" aria-hidden="true">#</a> 27、final</h2><h3 id="final-有什么用" tabindex="-1"><a class="header-anchor" href="#final-有什么用" aria-hidden="true">#</a> final 有什么用？</h3><p>用于修饰类、属性和方法；</p><ul><li>被final修饰的类不可以被继承</li><li>被final修饰的方法不可以被重写</li><li>被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li></ul><h3 id="final-finally-finalize区别" tabindex="-1"><a class="header-anchor" href="#final-finally-finalize区别" aria-hidden="true">#</a> final finally finalize区别</h3><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。</li></ul><h2 id="_28、泛型" tabindex="-1"><a class="header-anchor" href="#_28、泛型" aria-hidden="true">#</a> 28、泛型</h2><p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p><h3 id="泛型的分类" tabindex="-1"><a class="header-anchor" href="#泛型的分类" aria-hidden="true">#</a> 泛型的分类</h3><p>泛型一般有三种使用方式: 泛型类、泛型接口、泛型方法。</p><p><strong>1.泛型类</strong>：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span>
<span class="token comment">//在实例化泛型类时，必须指定T的具体类型</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Generic</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">T</span> key<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Generic</span><span class="token punctuation">(</span><span class="token class-name">T</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> key<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如何实例化泛型类：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Generic</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> genericInteger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Generic</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">123456</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>2.泛型接口</strong> ：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Generator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现泛型接口，不指定类型：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">GeneratorImpl</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Generator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现泛型接口，指定类型：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">GeneratorImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Generator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3.泛型方法</strong> ：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inputArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">E</span> element <span class="token operator">:</span> inputArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s &quot;</span><span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 创建不同类型数组： Integer, Double 和 Character</span>
<span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> intArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> stringArray <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;World&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">printArray</span><span class="token punctuation">(</span>intArray<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printArray</span><span class="token punctuation">(</span>stringArray<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="常用的通配符有哪些" tabindex="-1"><a class="header-anchor" href="#常用的通配符有哪些" aria-hidden="true">#</a> 常用的通配符有哪些？</h3><p><strong>常用的通配符为： T，E，K，V，？</strong></p><ul><li>？ 表示不确定的 Java 类型</li><li>T (type) 表示具体的一个 Java 类型</li><li>K V (key value) 分别代表 Java 键值中的 Key Value</li><li>E (element) 代表 Element</li></ul><h3 id="你的项目中哪里用到了泛型" tabindex="-1"><a class="header-anchor" href="#你的项目中哪里用到了泛型" aria-hidden="true">#</a> 你的项目中哪里用到了泛型？</h3><ul><li><p>可用于定义通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</p></li><li><p>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型</p></li><li><p>用于构建集合工具类。参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法</p></li></ul><h2 id="_29、反射" tabindex="-1"><a class="header-anchor" href="#_29、反射" aria-hidden="true">#</a> 29、反射</h2><h3 id="_1、谈谈你对反射的理解" tabindex="-1"><a class="header-anchor" href="#_1、谈谈你对反射的理解" aria-hidden="true">#</a> 1、谈谈你对反射的理解？</h3><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><h3 id="_2、反射机制优缺点" tabindex="-1"><a class="header-anchor" href="#_2、反射机制优缺点" aria-hidden="true">#</a> 2、反射机制优缺点</h3><ul><li><strong>优点</strong> ： <ul><li>增加程序的灵活性，可以在运行的过程中动态对类进行修改和操作</li><li>提高代码的复用率，比如动态代理，就是用到了反射来实现</li><li>可以在运行时轻松获取任意一个类的方法、属性，并且还能通过反射进行</li><li>动态调用</li></ul></li><li><strong>缺点</strong> ： <ul><li>反射会涉及到动态类型的解析，所以JVM无法对这些代码进行优化，导致性能要比非反射调用更低。</li><li>使用反射以后，代码的可读性会下降</li><li>反射可以绕过一些限制访问的属性或者方法，可能会导致破坏了代码本身的抽象性</li></ul></li></ul><h3 id="_3、反射的应用场景" tabindex="-1"><a class="header-anchor" href="#_3、反射的应用场景" aria-hidden="true">#</a> 3、反射的应用场景</h3><p>①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；</p><p>②Spring框架也用到很多反射机制， 经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p><p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p><p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p><p>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p><h2 id="_30、注解" tabindex="-1"><a class="header-anchor" href="#_30、注解" aria-hidden="true">#</a> 30、注解</h2><p><code>Annontation</code> （注解） 是Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量。</p><p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">SOURCE</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Override</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Override</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li></ul><p>JDK 提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p><h2 id="_31、i-o" tabindex="-1"><a class="header-anchor" href="#_31、i-o" aria-hidden="true">#</a> 31、I/O</h2><h3 id="什么是序列化-什么是反序列化" tabindex="-1"><a class="header-anchor" href="#什么是序列化-什么是反序列化" aria-hidden="true">#</a> 什么是序列化?什么是反序列化?</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><p>简单来说：</p><ul><li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p><p>维基百科是如是介绍序列化的：</p><blockquote><p><strong>序列化</strong>（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p></blockquote><p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/a478c74d-2c48-40ae-9374-87aacf05188c.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="java-序列化中如果有些字段不想进行序列化-怎么办" tabindex="-1"><a class="header-anchor" href="#java-序列化中如果有些字段不想进行序列化-怎么办" aria-hidden="true">#</a> Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h3 id="获取用键盘输入常用的两种方法" tabindex="-1"><a class="header-anchor" href="#获取用键盘输入常用的两种方法" aria-hidden="true">#</a> 获取用键盘输入常用的两种方法</h3><p>方法 1：通过 <code>Scanner</code></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Scanner</span> input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s  <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
input<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法 2：通过 <code>BufferedReader</code></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">BufferedReader</span> input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Copy</span> <span class="token keyword">to</span> <span class="token namespace">clipboardErrorCopied</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="java-中-io-流分为几种" tabindex="-1"><a class="header-anchor" href="#java-中-io-流分为几种" aria-hidden="true">#</a> Java 中 IO 流分为几种?</h3><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java IO 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p>按操作方式分类结构图：</p><figure><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-操作方式分类.png" alt="IO-操作方式分类" tabindex="0" loading="lazy"><figcaption>IO-操作方式分类</figcaption></figure><p>按操作对象分类结构图：</p><figure><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/IO-操作对象分类.png" alt="IO-操作对象分类" tabindex="0" loading="lazy"><figcaption>IO-操作对象分类</figcaption></figure><h3 id="既然有了字节流-为什么还要有字符流" tabindex="-1"><a class="header-anchor" href="#既然有了字节流-为什么还要有字符流" aria-hidden="true">#</a> 既然有了字节流,为什么还要有字符流?</h3><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好</p><h2 id="_32、java-中-3-种常见-io-模型" tabindex="-1"><a class="header-anchor" href="#_32、java-中-3-种常见-io-模型" aria-hidden="true">#</a> 32、Java 中 3 种常见 IO 模型</h2><h3 id="bio-blocking-i-o" tabindex="-1"><a class="header-anchor" href="#bio-blocking-i-o" aria-hidden="true">#</a> BIO (Blocking I/O)</h3><p><strong>BIO 属于同步阻塞 IO 模型</strong> 。</p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p><p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><h3 id="nio-non-blocking-new-i-o" tabindex="-1"><a class="header-anchor" href="#nio-non-blocking-new-i-o" aria-hidden="true">#</a> NIO (Non-blocking/New I/O)</h3><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。</p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</p><blockquote><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持</p><ul><li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul></blockquote><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><h3 id="aio" tabindex="-1"><a class="header-anchor" href="#aio" aria-hidden="true">#</a> AIO</h3><p>也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p><p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p><figure><img src="https://images.xiaozhuanlan.com/photo/2020/33b193457c928ae02217480f994814b6.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="_33、" tabindex="-1"><a class="header-anchor" href="#_33、" aria-hidden="true">#</a> 33、</h2><h2 id="_34、-和-的区别" tabindex="-1"><a class="header-anchor" href="#_34、-和-的区别" aria-hidden="true">#</a> 34、&amp;和&amp;&amp;的区别</h2><p>&amp;是位运算符。&amp;&amp;是布尔逻辑运算符，在进行逻辑判断时用&amp;处理的前面为false后面的内容仍需处理，用&amp;&amp;处理的前面为false不再处理后面的内容。</p><h2 id="_35、抽象类和接口的区别" tabindex="-1"><a class="header-anchor" href="#_35、抽象类和接口的区别" aria-hidden="true">#</a> 35、抽象类和接口的区别?</h2><p>抽象类：</p><ol><li>抽象方法，只有行为的概念，没有具体的行为实现。使用abstract关键字修饰，没有方法体。子类必须重写这些抽象方法。</li><li>包含抽象方法的类，一定是抽象类。</li><li>抽象类只能被继承，一个类只能继承一个抽象类。</li></ol><p>接口：</p><ol><li><p>全部的方法都是抽象方法，属型都是常量</p></li><li><p>不能实例化，可以定义变量。</p></li><li><p>接口变量可以引用具体实现类的实例</p></li><li><p>接口只能被实现，一个具体类实现接口，必须实现全部的抽象方法</p></li><li><p>接口之间可以多实现</p></li><li><p>一个具体类可以实现多个接口，实现多继承现象</p></li></ol><h2 id="_36、this关键字的用法" tabindex="-1"><a class="header-anchor" href="#_36、this关键字的用法" aria-hidden="true">#</a> 36、this关键字的用法</h2><p>this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p><p>this的用法在java中大体可以分为3种：</p><p>1.普通的直接引用，this相当于是指向当前对象本身。</p><p>2.形参与成员名字重名，用this来区分</p><p>3.引用本类的构造函数</p><h2 id="_37、super关键字的用法" tabindex="-1"><a class="header-anchor" href="#_37、super关键字的用法" aria-hidden="true">#</a> 37、super关键字的用法</h2><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p><p>super注意点：</p><ol><li><p>super调用父类的构造方法，必须在构造方法的第一个</p></li><li><p>super必须只能出现在子类的方法或者构造方法中</p></li><li><p>super和this不能通知调用构造方法</p></li><li><p>我们可以在子类的方法或构造器中。通过使用“super.属性”或”super.方法“，显示的调用父类中的属性和方法，但是在通常情况下，通常省略“super&quot;关键字。</p></li><li><p>特殊情况下，当子类或父类中定义了同名的属性时，我们想要在子类中调用父类声明的属性，则必须显示的使用“super.属性”的方式，表明调用的是父类中声明的属性</p></li><li><p>特殊情况，当子类重写了父类的方法以后，我们想要在子类中调用父类被重写的方法时，则必须显示的使用”super.方法“的方式，表明调用的是父类中的方法。</p></li></ol><h2 id="_38、是否了解连接池-使用连接池有什么好处" tabindex="-1"><a class="header-anchor" href="#_38、是否了解连接池-使用连接池有什么好处" aria-hidden="true">#</a> 38、是否了解连接池，使用连接池有什么好处？</h2><p>数据库连接是非常消耗资源的，影响到程序的性能指标。连接池是用来分配、管理、释放数据库连接的，可以使应用程序重复使用同一个数据库连接，而不是每次都创建一个新的数据库连接。通过释放空闲时间较长的数据库连接避免数据库因为创建太多的连接而造成的连接遗漏问题，提高了程序性能。</p><h2 id="_39、hashcode-与equals-的相关规定" tabindex="-1"><a class="header-anchor" href="#_39、hashcode-与equals-的相关规定" aria-hidden="true">#</a> 39、hashCode（）与equals（）的相关规定</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230205212750204.png" alt="image-20230205212750204" tabindex="0" loading="lazy"><figcaption>image-20230205212750204</figcaption></figure><h1 id="二、java异常面试题" tabindex="-1"><a class="header-anchor" href="#二、java异常面试题" aria-hidden="true">#</a> 二、Java异常面试题</h1><h2 id="_1、异常的含义" tabindex="-1"><a class="header-anchor" href="#_1、异常的含义" aria-hidden="true">#</a> 1、异常的含义</h2><p>Java提供的一种识别及响应错误的一致性机制。</p><h2 id="_2、异常的作用" tabindex="-1"><a class="header-anchor" href="#_2、异常的作用" aria-hidden="true">#</a> 2、异常的作用</h2><p>使程序中异常处理代码和正常业务代码分离，保证代码更加优雅，提高程序健壮性。</p><p>异常类型：&quot;什么被抛出&quot;；异常堆栈：“在哪儿抛出”；异常信息：“为什么会抛出”。</p><h2 id="_3、运行时异常与一般异常" tabindex="-1"><a class="header-anchor" href="#_3、运行时异常与一般异常" aria-hidden="true">#</a> 3、运行时异常与一般异常</h2><table><thead><tr><th>运行时异常</th><th>一般异常</th></tr></thead><tbody><tr><td>虚拟机的通常操作中可能遇到的异常</td><td>程序运行过程中可能出现的非正常状态</td></tr><tr><td>Java编译器没有要求必须声明抛出</td><td>Java编译器要求方法必须声明抛出可能发生的非运行时异常</td></tr></tbody></table><h2 id="_4、-error-和-exception-区别是什么" tabindex="-1"><a class="header-anchor" href="#_4、-error-和-exception-区别是什么" aria-hidden="true">#</a> 4、 Error 和 Exception 区别是什么？</h2><ul><li>Error 类型的错误通常为虚拟机相关错误，如系统崩溃，内存不足，堆栈溢出等，编译器不会对这类错误进行检测，JAVA 应用程序也不应对这类错误进行捕获，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复；</li><li>Exception 类的错误是可以在应用程序中进行捕获并处理的，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</li></ul><h2 id="_5、throw-和-throws-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_5、throw-和-throws-的区别是什么" aria-hidden="true">#</a> 5、throw 和 throws 的区别是什么？</h2><ul><li>throw 关键字用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li><li>throws 关键字用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li></ul><h2 id="_6、jvm如何处理异常" tabindex="-1"><a class="header-anchor" href="#_6、jvm如何处理异常" aria-hidden="true">#</a> 6、JVM如何处理异常</h2><p>在一个方法中发生异常，这个方法会创建一个异常对象，转交给JVM(抛出)。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列的方法调用的有序列表叫做调用栈。</p><p>JVM会顺着调用栈去查看是否有可以处理异常的代码，有则调用。若没有，则将异常转交给默认的异常处理器，默认异常处理器打印出异常信息并终止应用程序。</p><h2 id="_7、java异常关键字" tabindex="-1"><a class="header-anchor" href="#_7、java异常关键字" aria-hidden="true">#</a> 7、Java异常关键字</h2><p>try：监听，监听包含的代码块，若发生异常则抛出。</p><p>catch：捕获异常，捕获try抛出的异常。</p><p>finally：语句块总会被执行，用于回收在try块里打开的物力资源（如数据库连接、网络连接、磁盘文件）。</p><h2 id="_8、final、finally、finalize-有什么区别" tabindex="-1"><a class="header-anchor" href="#_8、final、finally、finalize-有什么区别" aria-hidden="true">#</a> 8、final、finally、finalize 有什么区别？</h2><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。</li></ul><h2 id="_9、try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗" tabindex="-1"><a class="header-anchor" href="#_9、try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗" aria-hidden="true">#</a> 9、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h2><blockquote><p>答：会执行，在 return 前执行。</p><p>注意 ：</p><p>在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。</p></blockquote><h2 id="_10、-java常见异常有哪些" tabindex="-1"><a class="header-anchor" href="#_10、-java常见异常有哪些" aria-hidden="true">#</a> 10、 Java常见异常有哪些</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230205214256411.png" alt="image-20230205214256411" tabindex="0" loading="lazy"><figcaption>image-20230205214256411</figcaption></figure><h1 id="三、java集合面试题" tabindex="-1"><a class="header-anchor" href="#三、java集合面试题" aria-hidden="true">#</a> 三、Java集合面试题</h1><h2 id="_1、集合概述" tabindex="-1"><a class="header-anchor" href="#_1、集合概述" aria-hidden="true">#</a> 1、集合概述：</h2><p>用于存储数据的容器。</p><h2 id="_2、集合框架" tabindex="-1"><a class="header-anchor" href="#_2、集合框架" aria-hidden="true">#</a> 2、集合框架：</h2><p>集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。</p><p>任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。</p><h2 id="_3、集合和数组的区别" tabindex="-1"><a class="header-anchor" href="#_3、集合和数组的区别" aria-hidden="true">#</a> 3、集合和数组的区别：</h2><table><thead><tr><th></th><th>数组</th><th>集合</th></tr></thead><tbody><tr><td>长度</td><td>固定</td><td>可变</td></tr><tr><td>存储类型</td><td>基本数据类型、引用数据类型</td><td>引用数据类型</td></tr><tr><td>存储约束</td><td>必须存储想同数据类型</td><td>可以存储不同数据类型</td></tr></tbody></table><h2 id="_4、list、set两者的区别" tabindex="-1"><a class="header-anchor" href="#_4、list、set两者的区别" aria-hidden="true">#</a> 4、List、Set两者的区别</h2><p>List、Set都继承Collection,都是单链集合</p><table><thead><tr><th>List</th><th>Set</th></tr></thead><tbody><tr><td>无序无重复无索引</td><td>有序有重复有索引</td></tr><tr><td>可存入多个null</td><td>只可存入一个null</td></tr><tr><td>可以通过for循环、迭代器遍历</td><td>只能通过迭代器遍历</td></tr><tr><td>检索效率高</td><td>检索效率低</td></tr><tr><td>插入删除效率低，因为会引起其他元素位置变化</td><td>插入删除效率高</td></tr></tbody></table><h2 id="_5、hashmap、hashtable、hashset" tabindex="-1"><a class="header-anchor" href="#_5、hashmap、hashtable、hashset" aria-hidden="true">#</a> 5、HashMap、HashTable、HashSet</h2><table><thead><tr><th>Map</th></tr></thead><tbody><tr><td>键值对集合，存储间、值之间的映射</td></tr><tr><td>Key无序且唯一</td></tr><tr><td>value不要求有序，可重复</td></tr><tr><td>常用接口为HashMap、HashTable</td></tr></tbody></table><table><thead><tr><th></th><th>HashMap</th><th>HashTabale</th></tr></thead><tbody><tr><td>性能</td><td>高</td><td>低</td></tr><tr><td>线程</td><td>不安全</td><td>安全</td></tr><tr><td>可否存null</td><td>键和值都可为null</td><td>不可</td></tr><tr><td>迭代器不同</td><td></td><td></td></tr></tbody></table><table><thead><tr><th></th><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现接口</td><td>Map</td><td>Set</td></tr><tr><td>存储</td><td>键值对</td><td>对象</td></tr><tr><td>添加元素</td><td>put()</td><td>add()</td></tr><tr><td>hashCode计算</td><td>使用建计算HashCode</td><td>使用成员对象计算HashCode，相同返回true</td></tr><tr><td>性能</td><td>快，使用唯一的键获取对象</td><td>慢</td></tr></tbody></table><h2 id="_6、hashmap的存储原理" tabindex="-1"><a class="header-anchor" href="#_6、hashmap的存储原理" aria-hidden="true">#</a> 6、HashMap的存储原理</h2><p>定义：基于哈希表（关联数组）实现的Map。</p><p>原理：</p><p>基于Hash算法，通过put存储，get取值。传入key值时，根据key.hashCode()计算出hash值，再根据hash值将value保存到bucket中。</p><p>优先使用数组存储。当计算的hash值相同时，也就是hash冲突。此时转换为链表存储hash值相同的value。当链表长度大于8时，为提高寻址速度，改为红黑树存储。</p><h2 id="_7、迭代器lterator" tabindex="-1"><a class="header-anchor" href="#_7、迭代器lterator" aria-hidden="true">#</a> 7、迭代器lterator</h2><p>作用：提供遍历任何Collection的接口</p><p>特点：单向遍历，更加安全。若在遍历时集合元素被更改，就会抛出异常。</p><h2 id="_8、arraylist、linkedlist、vector" tabindex="-1"><a class="header-anchor" href="#_8、arraylist、linkedlist、vector" aria-hidden="true">#</a> 8、ArrayList、LinkedList、Vector</h2><table><thead><tr><th></th><th>ArrayList</th><th>LinkedList</th><th>Vector</th></tr></thead><tbody><tr><td>结构</td><td>基于动态数组</td><td>基于链表</td><td>基于动态数组</td></tr><tr><td>擅长</td><td>访问(get、set)移动数据</td><td>新增、删除(add、remove)移动指针</td><td>无</td></tr><tr><td>线程</td><td>不安全</td><td>不安全</td><td>安全</td></tr><tr><td>性能</td><td>强</td><td></td><td>弱</td></tr></tbody></table><h2 id="_9、集合框架底层数据结构" tabindex="-1"><a class="header-anchor" href="#_9、集合框架底层数据结构" aria-hidden="true">#</a> 9、集合框架底层数据结构</h2><ul><li>Collection <ol><li>List <ul><li>Arraylist： Object数组</li><li>LinkedList： 双向循环链表</li><li>Vector： Object数组</li></ul></li><li>Set <ul><li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li></ul></li><li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li><li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li></ol></li><li>Map <ul><li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li><li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： 红黑树（自平衡的排序二叉树</li></ul></li></ul><h2 id="_10、怎么确保一个集合不能被修改" tabindex="-1"><a class="header-anchor" href="#_10、怎么确保一个集合不能被修改" aria-hidden="true">#</a> 10、怎么确保一个集合不能被修改？</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230205211501596.png" alt="image-20230205211501596" tabindex="0" loading="lazy"><figcaption>image-20230205211501596</figcaption></figure><h2 id="_12、迭代器-iterator-是什么" tabindex="-1"><a class="header-anchor" href="#_12、迭代器-iterator-是什么" aria-hidden="true">#</a> 12、迭代器 Iterator 是什么？</h2><ul><li>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</li><li>因为所有Collection接口继承了Iterator迭代器</li></ul><h2 id="_13、iterator-和-listiterator-有什么区别" tabindex="-1"><a class="header-anchor" href="#_13、iterator-和-listiterator-有什么区别" aria-hidden="true">#</a> 13、Iterator 和 ListIterator 有什么区别？</h2><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li><li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul><h2 id="_14、list和set的区别" tabindex="-1"><a class="header-anchor" href="#_14、list和set的区别" aria-hidden="true">#</a> 14、List和Set的区别</h2><ul><li>List: 有序，按对象进入的顺序保存对象，可重复,允许多个Null元素对象，可以使用Iterator取出所有元素,在逐个遍历,还可以使用get(int index)获取指定下标的元素</li><li>Set: 无序,不可重复,最够允许有一个Null元素对象,取元素时只能用Iterator接口取得所有元素，在逐一遍历各个元素</li></ul><h2 id="_15、arraylist和linkedlist的区别" tabindex="-1"><a class="header-anchor" href="#_15、arraylist和linkedlist的区别" aria-hidden="true">#</a> 15、ArrayList和LinkedList的区别</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230205212453694.png" alt="image-20230205212453694" tabindex="0" loading="lazy"><figcaption>image-20230205212453694</figcaption></figure><h2 id="_16、hashmap和hasptable有什么区别" tabindex="-1"><a class="header-anchor" href="#_16、hashmap和hasptable有什么区别" aria-hidden="true">#</a> 16、HashMap和hasptable有什么区别</h2><ol><li>从功能特性的角度来说HashTable是线程安全的，而HashMap不是。</li><li>HashMap的性能要比HashTable更好，因为，HashTable采用了全局同步锁来保证安全性，对性能影响较大</li><li>从内部实现的角度来说HashTable使用数组加链表、HashMap采用了数组+链表+红黑树。</li><li>HashMap初始容量是16、HashTable初始容量是11</li><li>HashMap可以使用null作为key，HashMap会把null转化为0进行存储，而Hashtable不允许。</li><li>最后，他们两个的key的散列算法不同，HashTable直接是使用key的hashcode对数组长度做取模。而HashMap对key的hashcode做了二次散列，从而避免key的分布不均匀问题影响到查询性能。</li></ol><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230205212132766.png" alt="image-20230205212132766" tabindex="0" loading="lazy"><figcaption>image-20230205212132766</figcaption></figure><h2 id="_17、说一下hashmap的put方法" tabindex="-1"><a class="header-anchor" href="#_17、说一下hashmap的put方法" aria-hidden="true">#</a> 17、说一下HashMap的Put方法</h2><p>先说HashMap的Put方法的大体流程:</p><ol><li>根据Key通过哈希算法与与运算得出数组下标</li><li>如果数组下标位置元素为空,则将key和value封装为Entry对象 (JDK1.7中是Entry对象, JDK1.8中是Node对象)并放入该位置</li><li>如果数组下标位置元素不为空，则要分情况讨论 <ol><li>如果是JDK1.7,则先判断是否需要扩容,如果要扩容就进行扩容，如果不用扩容就生成Entry对象,并使用头插法添加到当前位置的链表中 <ol><li>如果是JDK1.8,则会先判断当前位置上的Node的类型，看是红黑树Node,还是链表Node</li><li>如果是红黑树Node,则将key和value封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key,如果存在则更新value</li><li>如果此位置上的Node对象是链表节点，则将key和value封装为一 个链表Node并通过尾插法插入到链表的最后位置去，因为是尾插法,所以需要遍历链表,在遍历链表的过程中会判断是否存在当前key,如果存在则更新value,当遍历完链表后，将新链表Node插入到链表中,插入到链表后，会看当前链表的节点个数,如果大于等于8,那么则会将该链表转成红黑树</li><li>将key和value封装为Node插入到链表或红黑树中后，再判断是否需要进行扩容,如果需要就扩容,如果不需要就结束PUT方法</li></ol></li></ol></li></ol><h2 id="_18、hashmap的扩容机制原理" tabindex="-1"><a class="header-anchor" href="#_18、hashmap的扩容机制原理" aria-hidden="true">#</a> 18、HashMap的扩容机制原理</h2><p><strong>1.7版本</strong></p><p>1.先生成新数组<br> 2.遍历原来数组中的每个位置上的链表上的每个元素<br> 3.取每个元素 的key,并基于新数组长度，计算出每个元素在新数组中的下标<br> 4.将元素添加到新数组中去<br> 5.所有元素转移完了之后，将新数组赋值给HashMap对象的table属性</p><p><strong>1.8版本</strong></p><ol><li>先生成新数组</li><li>遍历原来数组中的每个位置上的链表或红黑树</li><li>如果是链表，则直接将链表中的每个元索重新计算下标,并添加到新数组中去</li><li>如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元索元素在新数组中的下标位置。 <ol><li>统计每个下标位置的元素个数</li><li>如果该位置下的元素个数超过了8,则生成一个新的红黑树，并将根节点的添加到新数组的对应位置</li><li>如果该位置下的元素个数没有超过8,那么则生成一个链表, 并将链表的头节点添加到新数组的对应位置</li></ol></li></ol><p>5.所有元素转移完了之后,将新数组赋值给HashMap对象的table属性</p><h2 id="_19、说一下-arraylist-的优缺点" tabindex="-1"><a class="header-anchor" href="#_19、说一下-arraylist-的优缺点" aria-hidden="true">#</a> 19、说一下 ArrayList 的优缺点</h2><ul><li><p>ArrayList的优点如下：</p><ul><li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li><li>ArrayList 在顺序添加一个元素的时候非常方便。</li></ul></li><li><p>ArrayList 的缺点如下：</p><ul><li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</li><li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li><li>ArrayList 比较适合顺序添加、随机访问的场景。</li></ul><h3 id="arraylist的扩容机制" tabindex="-1"><a class="header-anchor" href="#arraylist的扩容机制" aria-hidden="true">#</a> ArrayList的扩容机制</h3><p>默认情况下，新的容量会是原容量的1.5倍。 新容量=旧容量右移一位（相当于除于2）在加上旧容量</p><blockquote><p>ArrayList 的底层是用动态数组来实现的。我们初始化一个ArrayList 集合还没有添加元素时，其实它是个空数组，只有当我们添加第一个元素时，内部会调用扩容方法并返回最小容量10，也就是说ArrayList 初始化容量为10。 当前数组长度小于最小容量的长度时（前期容量是10，当添加第11个元素时就就扩容），便开始可以扩容了，ArrayList 扩容的真正计算是在一个grow()里面，新数组大小是旧数组的1.5倍，如果扩容后的新数组大小还是小于最小容量，那新数组的大小就是最小容量的大小，后面会调用一个Arrays.copyof方法，这个方法是真正实现扩容的步骤。</p></blockquote></li></ul><h2 id="_20、如何实现数组和-list-之间的转换" tabindex="-1"><a class="header-anchor" href="#_20、如何实现数组和-list-之间的转换" aria-hidden="true">#</a> 20、如何实现数组和 List 之间的转换？</h2><ul><li>数组转 List：使用 Arrays. asList(array) 进行转换</li><li>List 转数组：使用 List 自带的 toArray() 方法。</li></ul><h2 id="_21、arraylist-和-vector-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_21、arraylist-和-vector-的区别是什么" aria-hidden="true">#</a> 21、ArrayList 和 Vector 的区别是什么？</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230205212519700.png" alt="image-20230205212519700" tabindex="0" loading="lazy"><figcaption>image-20230205212519700</figcaption></figure><h2 id="_22、说一下-hashset-的实现原理" tabindex="-1"><a class="header-anchor" href="#_22、说一下-hashset-的实现原理" aria-hidden="true">#</a> 22、说一下 HashSet 的实现原理？</h2><blockquote><p>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为present，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</p></blockquote><h2 id="_23、-hashset如何检查重复-hashset是如何保证数据不可重复的" tabindex="-1"><a class="header-anchor" href="#_23、-hashset如何检查重复-hashset是如何保证数据不可重复的" aria-hidden="true">#</a> 23、 HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h2><ul><li>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。</li><li>HashSet 中的add ()方法会使用HashMap 的put()方法。</li><li>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</li></ul><h2 id="_24、说一下hashmap的实现原理" tabindex="-1"><a class="header-anchor" href="#_24、说一下hashmap的实现原理" aria-hidden="true">#</a> 24、说一下HashMap的实现原理？</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230205212832233.png" alt="image-20230205212832233" tabindex="0" loading="lazy"><figcaption>image-20230205212832233</figcaption></figure><h2 id="_25、hashmap在jdk1-7和jdk1-8中有哪些不同-hashmap的底层实现" tabindex="-1"><a class="header-anchor" href="#_25、hashmap在jdk1-7和jdk1-8中有哪些不同-hashmap的底层实现" aria-hidden="true">#</a> 25、HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</h2><p><strong>HashMap JDK1.8之前</strong></p><ul><li><p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230205213005614.png" alt="image-20230205213005614" style="zoom:67%;"></li></ul><p><strong>HashMap JDK1.8之后</strong></p><ul><li>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li></ul><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230205212953233.png" alt="image-20230205212953233" tabindex="0" loading="lazy"><figcaption>image-20230205212953233</figcaption></figure><h2 id="_26、说说什么是红黑树" tabindex="-1"><a class="header-anchor" href="#_26、说说什么是红黑树" aria-hidden="true">#</a> 26、说说什么是红黑树</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230205213218019.png" alt="image-20230205213218019" tabindex="0" loading="lazy"><figcaption>image-20230205213218019</figcaption></figure><h2 id="_27、能否使用任何类作为-map-的-key" tabindex="-1"><a class="header-anchor" href="#_27、能否使用任何类作为-map-的-key" aria-hidden="true">#</a> 27、能否使用任何类作为 Map 的 key？</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230205213333907.png" alt="image-20230205213333907" tabindex="0" loading="lazy"><figcaption>image-20230205213333907</figcaption></figure><h2 id="_28、hashmap-的长度为什么是2的幂次方" tabindex="-1"><a class="header-anchor" href="#_28、hashmap-的长度为什么是2的幂次方" aria-hidden="true">#</a> 28、HashMap 的长度为什么是2的幂次方</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230205213416274.png" alt="image-20230205213416274" tabindex="0" loading="lazy"><figcaption>image-20230205213416274</figcaption></figure><h2 id="_29、hashmap-与-hashtable-有什么区别" tabindex="-1"><a class="header-anchor" href="#_29、hashmap-与-hashtable-有什么区别" aria-hidden="true">#</a> 29、HashMap 与 HashTable 有什么区别？</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230205213522037.png" alt="image-20230205213522037" tabindex="0" loading="lazy"><figcaption>image-20230205213522037</figcaption></figure><h2 id="_30、array-和-arraylist-有何区别" tabindex="-1"><a class="header-anchor" href="#_30、array-和-arraylist-有何区别" aria-hidden="true">#</a> 30、Array 和 ArrayList 有何区别？</h2><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li><li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li></ul><h2 id="_31、comparable-和-comparator的区别" tabindex="-1"><a class="header-anchor" href="#_31、comparable-和-comparator的区别" aria-hidden="true">#</a> 31、comparable 和 comparator的区别？</h2><ul><li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li><li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</li><li>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</li></ul><h2 id="_32、collection和collections有什么区别" tabindex="-1"><a class="header-anchor" href="#_32、collection和collections有什么区别" aria-hidden="true">#</a> 32、Collection和Collections有什么区别？</h2><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h1 id="四、java线程面试题" tabindex="-1"><a class="header-anchor" href="#四、java线程面试题" aria-hidden="true">#</a> 四、Java线程面试题</h1><h3 id="_1、为什么要使用多线程" tabindex="-1"><a class="header-anchor" href="#_1、为什么要使用多线程" aria-hidden="true">#</a> 1、为什么要使用多线程？</h3><p>（1）充分发挥多核CPU的优势</p><p>（2）防止程序阻塞</p><p>（3）便于建模。</p><h3 id="_2、单线程和多线程的区别。" tabindex="-1"><a class="header-anchor" href="#_2、单线程和多线程的区别。" aria-hidden="true">#</a> 2、单线程和多线程的区别。</h3><p>（1）单核CPU中，每个时间片段，只能有一个线程运行。</p><p>（2）单线程程序执行效率更快，多线程用户响应时间更少。</p><h3 id="_3、进程和线程" tabindex="-1"><a class="header-anchor" href="#_3、进程和线程" aria-hidden="true">#</a> 3、进程和线程</h3><p>进程：程序（有指令和数据的文件）的一次执行过程。</p><p>线程：轻量级进程。进程的组成单元。同类多个线程共享同一块内存空间和一组资源。</p><h3 id="_4、并行和并发" tabindex="-1"><a class="header-anchor" href="#_4、并行和并发" aria-hidden="true">#</a> 4、并行和并发</h3><p>并发：一个CPU在多个线程之间快速切换，达到同时执行多个任务的目的。</p><p>并行：多个CPU可以同时执行一个进程中的多个线程。</p><h3 id="_5、线程的创建方式" tabindex="-1"><a class="header-anchor" href="#_5、线程的创建方式" aria-hidden="true">#</a> 5、线程的创建方式</h3><p><strong>方法一</strong>：继承Thread类，作为线程对象存在（继承Thread对象）</p><p><strong>方法二</strong>：实现runnable接口，作为线程任务存在</p><p><strong>方法三</strong>：匿名内部类创建线程对象</p><p><strong>方法四</strong>：创建带返回值的线程</p><p><strong>方法五</strong>：定时器Timer</p><p><strong>方法六</strong>：线程池创建线程</p><p><strong>方法七</strong>：利用java8新特性stream 实现并发</p><p><strong>让线程等待的方法</strong></p><p>Thread.sleep(200); //线程休息2ms</p><p>Object.wait()； //让线程进入等待，直到调用Object的notify或者notifyAll时，线程停止休眠</p><h3 id="_6、线程的六种状态" tabindex="-1"><a class="header-anchor" href="#_6、线程的六种状态" aria-hidden="true">#</a> 6、线程的六种状态（）</h3><p>（1）初始状态：线程构建，但还没有调用start()方法。</p><p>（2）运行状态：操作系统中的“就绪”和“运行”。</p><p>（3）阻塞状态：线程阻塞于锁。</p><p>（4）等待状态：当前线程需要等待其他线程做出特定动作（通知/中断）。</p><p>（5）超时等待状态：在特定的时间自行返回。</p><p>（6）终止状态：当前线程已执行完毕。</p><figure><img src="https://edu--learn.oss-cn-beijing.aliyuncs.com/weixin/Snipaste_2022-02-14_15-45-10.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h3 id="_7、如何停止一个正在运行的线程" tabindex="-1"><a class="header-anchor" href="#_7、如何停止一个正在运行的线程" aria-hidden="true">#</a> 7、如何停止一个正在运行的线程？</h3><p>（1）使用推出标致（当run()方法完成后线程终止，正常退出）。</p><p>（2）使用stop方法强行终止，（不推荐，过期作废）。</p><p>（3）使用interrupt方法中断线程</p><h3 id="_8、start-和run-方法的区别" tabindex="-1"><a class="header-anchor" href="#_8、start-和run-方法的区别" aria-hidden="true">#</a> 8、start()和run()方法的区别？</h3><p>Start()：调用后才能出现多线程的特性，不同线程的run()方法里面的代码交替执行。</p><p>run()：如果调用后，代码还是同步执行的，必须等待一个线程的run()方法里的代码全部执行完毕，另一个run()才能开始执行。</p><h3 id="_9、为什么调用start-方法的时候会执行run-方法-而不能直接调用run-方法" tabindex="-1"><a class="header-anchor" href="#_9、为什么调用start-方法的时候会执行run-方法-而不能直接调用run-方法" aria-hidden="true">#</a> 9、为什么调用start()方法的时候会执行run()方法，而不能直接调用run()方法？</h3><p>JVM执行start方法，会令其一条线程执行继承的thread的run方法，这才起到多线程的效果。</p><p>如果直接调用thread的run方法，其方法还是在运行的主线程中，没有起到多线程的效果。</p><h3 id="_10、什么是线程安全" tabindex="-1"><a class="header-anchor" href="#_10、什么是线程安全" aria-hidden="true">#</a> 10、什么是线程安全？</h3><p>多线程访问同一代码，而不会产生不确定的结果。</p><h3 id="_11、java中堆和栈的区别" tabindex="-1"><a class="header-anchor" href="#_11、java中堆和栈的区别" aria-hidden="true">#</a> 11、Java中堆和栈的区别？</h3><p>栈：在函数中定义的基本类型的变量和对象的引用变量都在函数的栈内存中。（用来存放执行程序）</p><p>堆：用于存放由new创建的对象和数组。</p><h3 id="_12、如何确保线程安全" tabindex="-1"><a class="header-anchor" href="#_12、如何确保线程安全" aria-hidden="true">#</a> 12、如何确保线程安全？</h3><p>（1）对非安全的代码进行“加锁”。</p><p>（2）使用线程安全的类。</p><p>（3）多线程高并发情况下，线程共享的变量改为“方法级的局部变量”。</p><h3 id="_13、线程的安全级别" tabindex="-1"><a class="header-anchor" href="#_13、线程的安全级别" aria-hidden="true">#</a> 13、线程的安全级别？</h3><p><strong>线程安全</strong>：在多 线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</p><p>（1）不可变：不可变的对象一定是线程安全的，永远也不需要额外的同步。</p><p>（2）无条件的线程安全：由类的规格说明所规定的的约束，在对象被多个线程访问时仍然有效，不管运行时环境如何排列，线程都不需要额外的同步。</p><p>（3）有条件的线程安全：有条件的线程安全类对于单独的操作可以是线程安全，但是某些操作序列可能需要额外的同步。</p><p>（4）非线程安全（线程兼容）：线程兼容类不是线程安全的，但是可以通过正确使用同步，在并发环境中安全地使用。</p><p>（5）线程对立：是那些不管是否采用了“同步措施”，都不能在多线程环境中并发使用的代码。</p><h3 id="_14、线程类的构造方法和静态块是被哪个线程调用的" tabindex="-1"><a class="header-anchor" href="#_14、线程类的构造方法和静态块是被哪个线程调用的" aria-hidden="true">#</a> 14、线程类的构造方法和静态块是被哪个线程调用的？</h3><p>是被new这个线程类所在的线程所调用的，而run里面的代码才是被线程自身调用。</p><h3 id="_15、线程池的作用" tabindex="-1"><a class="header-anchor" href="#_15、线程池的作用" aria-hidden="true">#</a> 15、线程池的作用</h3><p>（1）<strong>降低资源消耗。</strong>（重复利用已创建的线程降低线程创建和销毁所造成的消耗）</p><p>（2）<strong>提高响应速度。</strong>（任务到达时，任务可以不需要等到线程创建就能立即执行）</p><p>（3）<strong>提高线程的可管理性。</strong>（线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行同一的分配，调优和监控）</p><h3 id="_16、java中的死锁问题" tabindex="-1"><a class="header-anchor" href="#_16、java中的死锁问题" aria-hidden="true">#</a> 16、Java中的死锁问题</h3><p>死锁：死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p><p>必要条件：</p><p>（1）互斥条件：进程对所分配到的资源进行排他性使用。</p><p>（2）请求和保持条件：进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已经被其他进程占有。</p><p>（3）不剥夺条件：进程已获得的资源，在未使用完之前，不能被剥夺。</p><p>（4）环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。</p><p><strong>如何解决死锁问题</strong></p><p>程序出现死锁，是因为在多线程环境里面两个或两个以上的线程同时满足互斥条件、请求保持条件、不可抢占条件、循环等待条件。出现死锁以后，可以通过jstack命令去导出线程的dump日志，然后从dump日志里面定位到具体死锁的程序代码。通过修改程序代码去破坏这四个条件里面的任意一个，就可以解决死锁问题。当然，因为互斥条件因为是锁本身的特性，所以不能被破坏。</p><h3 id="_17、如何避免死锁和检测" tabindex="-1"><a class="header-anchor" href="#_17、如何避免死锁和检测" aria-hidden="true">#</a> 17、如何避免死锁和检测</h3><p>（1）预防死锁：破坏互斥关系、破坏请求和保持条件、破坏不剥夺条件、破坏循环等待条件。</p><p>（2）设置加锁顺序。</p><table><thead><tr><th>破坏互斥关系</th><th>无法破坏（临界资源需要互斥访问）</th></tr></thead><tbody><tr><td>破坏请求和保持条件</td><td>一次性申请所有的资源</td></tr><tr><td>破坏不剥夺条件</td><td>占用部分资源的线程进一步申请其他资源时，若申请不到，则主动释放它占有的资源</td></tr><tr><td>破坏循环等待条件</td><td>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。</td></tr></tbody></table><h3 id="_18、synchronized底层原理" tabindex="-1"><a class="header-anchor" href="#_18、synchronized底层原理" aria-hidden="true">#</a> 18、synchronized底层原理？</h3><p>同步代码块：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>synchronized(锁对象){
    需要同步执行的代码
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原理：一旦线程进入了该代码块，就持有锁，JVM会有监视器监视进入锁的线程，其他线程想进入代码，监视器就会拒绝访问；一旦持有锁的线程执行完代码，锁就会被释放，其他线程才可进入。</p><p>注意：任何对象都可以作为锁，必须是成员变量。</p><h3 id="_19、生产者消费者模型的作用是什么" tabindex="-1"><a class="header-anchor" href="#_19、生产者消费者模型的作用是什么" aria-hidden="true">#</a> 19、生产者消费者模型的作用是什么？</h3><p>（1）平衡生产者的生产能力和消费者的消费能力，提升整个系统的运行效率。</p><p>（2）解耦。</p><h3 id="_20、生产者消费者模式" tabindex="-1"><a class="header-anchor" href="#_20、生产者消费者模式" aria-hidden="true">#</a> 20、生产者消费者模式</h3><p>生产者是生产数据的线程，消费者是消费数据的线程。</p><p>如果生产者处理速度远快过消费数据的速度，那么生产者必须等待消费者处理完，才能继续生产数据。</p><p>反之，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这种生产消费能力不均衡的问题，所以便有了生产者和消费者模式。</p><h3 id="_21、创建线程池的几种方法" tabindex="-1"><a class="header-anchor" href="#_21、创建线程池的几种方法" aria-hidden="true">#</a> 21、创建线程池的几种方法</h3><p><strong>方式一：通过构造方法实现</strong></p><p><strong>方式二：通过****Executor</strong> <strong>框架的工具类<strong><strong>Executors</strong></strong>来实现</strong> 我们可以创建三种类型的</p><table><thead><tr><th>返回线程数量无限的线程池</th><th>ExecutorService newCachedThreadPool()</th></tr></thead><tbody><tr><td>返回固定长度的线程池，好处是可以控制并发量</td><td>ExecutorService newFixedThreadPool(int size)</td></tr><tr><td>返回单一线程的线程池</td><td>ExecutorService newSingleThreadExecutor()</td></tr><tr><td>返回可以调度的线程池</td><td>ScheduledExecutorService newScheduledThreadPool(int size)</td></tr></tbody></table><h3 id="_22、自定义线程池的配置" tabindex="-1"><a class="header-anchor" href="#_22、自定义线程池的配置" aria-hidden="true">#</a> 22、自定义线程池的配置</h3><p><strong>ThreadPoolExecutor的构造方法：</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>参数说明：</strong></p><table><thead><tr><th>corePoolSize</th><th>核心线程数</th></tr></thead><tbody><tr><td>maximumPoolSize</td><td>最大线程数</td></tr><tr><td>keepAliveTime</td><td>临时的线程能够存活的时间</td></tr><tr><td>unit</td><td>时间单位</td></tr><tr><td>workQueue</td><td>用于保存任务的阻塞队列</td></tr></tbody></table><p><strong>优化配置：</strong></p><ol><li><p>核心线程数大于或等于CPU内核的数量（如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1，如果是IO密集型任务，参考值可以设置为2*NCPU）获得CPU的内核数：Runtime.getRuntime().availableProcessors()</p></li><li><p>最大线程数和核心线程数配置一样，性能比较高，因为避免临时线程的创建和销毁</p></li><li><p>如果临时线程比较多，可以将存活时间配置稍微长点，减少临时线程的创建和销毁<br> 4、阻塞队列LinkedBlockingQueue的性能比较高</p></li></ol><h3 id="_23、什么是乐观锁和悲观锁" tabindex="-1"><a class="header-anchor" href="#_23、什么是乐观锁和悲观锁" aria-hidden="true">#</a> 23、什么是乐观锁和悲观锁</h3><ul><li>悲观锁<br> 想法悲观，认为当前的资源存在竞争，所以每次获得资源时都会上锁，阻塞住其它线程。<br> 数据库中的行锁、表锁、读锁、写锁都属于悲观锁，Java的synchronized和ReentrantLock也属于悲观锁。<br> 悲观锁会降低系统性能和吞吐量，提高数据的安全性，适用于多写少读的场景。</li><li>乐观锁<br> 想法乐观，认为当前的资源不存在竞争，所以每次获得资源时都不上锁<br> 乐观锁执行效率高，有利于提高系统吞吐量，适用于多读少写的场景。</li></ul><h3 id="_24、并发编程三要素是什么-在java程序中怎么保证多线程的运行安全" tabindex="-1"><a class="header-anchor" href="#_24、并发编程三要素是什么-在java程序中怎么保证多线程的运行安全" aria-hidden="true">#</a> 24、并发编程三要素是什么？在Java程序中怎么保证多线程的运行安全？</h3><table><thead><tr><th>三要素</th><th></th><th>出现安全问题的原因</th><th>解决办法</th></tr></thead><tbody><tr><td>原子性</td><td>一个或多个操作要么全部执行，要么全部执行失败。</td><td>线程切换</td><td>JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题</td></tr><tr><td>可见性</td><td>一个线程对共享变量的修改，另一个线程能够立刻看到。</td><td>缓存导致</td><td>synchronized、volatile、LOCK，可以解决可见性问题</td></tr><tr><td>有序性</td><td>程序执行的顺序按照代码的先后顺序执行。</td><td>编译优化</td><td>Happens-Before 规则可以解决有序性问题</td></tr></tbody></table><h3 id="_25、volatile-关键字" tabindex="-1"><a class="header-anchor" href="#_25、volatile-关键字" aria-hidden="true">#</a> 25、volatile 关键字</h3><p>用来确保将变量的更新操作通知到其他线程。可以将 volatile 看做一个轻量级的锁，但是又与锁有些不同：</p><ol><li>对于多线程，不是一种互斥关系</li><li>不能保证变量状态的“原子性操作”</li></ol><p>被volatile修饰的共享变量，就具有了以下两点特性：</p><ul><li>1.保证了不同线程对该变量操作的内存可见性;</li><li>2.禁止指令重排序</li></ul><h3 id="_26、乐观锁如何实现" tabindex="-1"><a class="header-anchor" href="#_26、乐观锁如何实现" aria-hidden="true">#</a> 26、乐观锁如何实现</h3><p>乐观锁常用的两种实现方式：</p><ol><li>版本号机制<br> 利用版本号version记录数据被修改的次数，当数据被修改时，version加一。当线程要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前version值相等时才更新，否则重试更新操作，直到更新成功。</li><li>CAS算法<br> Compare and Swap（比较与交换）<br> CAS涉及三个操作数： <ol><li>读写变量的内存位置</li><li>预期值</li><li>写入的新值<br> CAS实现过程是：先判断内存位置上的值是否和预期值一致，如果一致就修改为新值，否则不执行。</li></ol></li></ol><h3 id="_27、sleep方法和wait方法有什么区别和共同点" tabindex="-1"><a class="header-anchor" href="#_27、sleep方法和wait方法有什么区别和共同点" aria-hidden="true">#</a> 27、sleep方法和wait方法有什么区别和共同点</h3><p>两者最主要的区别在于：sleep() 方法没有释放锁，而 wait() 方法释放了锁 。<br> 两者都可以暂停线程的执行。<br> wait() 通常被用于线程间交互/通信，sleep() 通常被用于暂停执行。<br> wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。</p><h3 id="_28、cas算法" tabindex="-1"><a class="header-anchor" href="#_28、cas算法" aria-hidden="true">#</a> 28、CAS算法</h3><p>CAS (Compare-And-Swap 比较与交换) 是一种硬件对并发的支持，针对多处理器操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问。</p><ul><li>CAS 是一种无锁的非阻塞算法的实现。</li><li>CAS 包含了 3 个操作数：需要读写的内存值 V、进行比较的值 A、拟写入的新值 B</li><li>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作。</li></ul><p>这是一个模拟实现，是通过synchronizes加锁的阻塞算法，跟真正的CAS不同。</p><h1 id="五、java虚拟机面试题" tabindex="-1"><a class="header-anchor" href="#五、java虚拟机面试题" aria-hidden="true">#</a> 五、Java虚拟机面试题</h1><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230205193547603.png" alt="image-20230205193547603" tabindex="0" loading="lazy"><figcaption>image-20230205193547603</figcaption></figure><h2 id="_1、什么是java虚拟机-为何被称作-平台无关的编程语言" tabindex="-1"><a class="header-anchor" href="#_1、什么是java虚拟机-为何被称作-平台无关的编程语言" aria-hidden="true">#</a> 1、什么是Java虚拟机？为何被称作“平台无关的编程语言”？</h2><p>Java虚拟机是一个可以执行Java字节码（.class）的虚拟机进程。</p><p>Java源文件（.java）被编译成Java字节码（.class）。允许应用程序可以在任意平台。</p><p>因为Java虚拟机知道底层硬件平台的指令长度和其他特性。</p><h2 id="_2、java的内存结构" tabindex="-1"><a class="header-anchor" href="#_2、java的内存结构" aria-hidden="true">#</a> 2、Java的内存结构</h2><p>（1）Java堆：虚拟机启动时创建，存放对象实例（new）。各线程共享。</p><p>（2）方法区：存储加载的类的信息、常量、静态变量、编译后的代码等。各线程共享。</p><p>（3）程序计数器：当前线程所执行的字节码的行号指示器。线程私有。</p><p>（4）JVM栈：描述Java方法执行的内存模型，每个栈帧对应一个方法，线程私有。</p><p>（5）本地方法栈：为虚拟机使用到的Native方法服务。</p><figure><img src="https://edu--learn.oss-cn-beijing.aliyuncs.com/weixin/20200103213149526.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230205193831242.png" alt="image-20230205193831242" tabindex="0" loading="lazy"><figcaption>image-20230205193831242</figcaption></figure><p><strong>Java虚拟机会出现的两种错误 ：</strong></p><ol><li>StackOverFlowError： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError 错误。</li><li>OutOfMemoryError：若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError错误。</li></ol><p><strong>扩展：那么方法/函数如何调用？</strong></p><blockquote><p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，</p><p>每一次函数调用都会有一个对应的栈帧被压入 Java 栈，</p><p>每一个函数调用结束后，都会有一个栈帧被弹出。Java 方法有两种返回方式：</p><ol><li>return 语句。</li><li><ol start="2"><li>抛出异常。</li><li>不管哪种返回方式都会导致栈帧被弹出。</li></ol></li></ol></blockquote><h2 id="_3、内存分配" tabindex="-1"><a class="header-anchor" href="#_3、内存分配" aria-hidden="true">#</a> 3、内存分配</h2><p>（1）寄存器：无法控制。</p><p>（2）静态域：static定义的成员。</p><p>（3）常量池：编译时被确定并保存到.class文件中的（final）常量值和一些文本修饰的符号引用。</p><p>（4）非RAM存储：硬盘等永久存储空间。</p><p>（5）堆内存：new创建的对象和数组，由Java虚拟机自动垃圾回收器管理，存取速度慢。</p><p>栈内存：基本类型的变量和对象的引用变量（对内存空间的访问地址），速度快，可以共享，但是大小与生存周期必须确定，缺乏灵活性。</p><h2 id="_4、类加载器" tabindex="-1"><a class="header-anchor" href="#_4、类加载器" aria-hidden="true">#</a> 4、类加载器</h2><p>（1）启动类加载器：负责加载JDK\jre\lib下的文件。</p><p>（2）扩展类加载器：负责加载JDK\jre\lib\ext目录中的所有类库。</p><p>（3）应用程序类加载器：负责加载用户类路径所指定的类。</p><h2 id="_5、jvm如何加载class文件" tabindex="-1"><a class="header-anchor" href="#_5、jvm如何加载class文件" aria-hidden="true">#</a> 5、JVM如何加载class文件？</h2><p>类加载器：运行时查找和装入类文件中的类。</p><p>加载：把类的.class文件中的数据读入到内存之中（通过创建字节数组读入.class文件），然后产生与所加载类对应的Class对象。</p><p>连接：验证、准备（为静态变量分配内存并设置默认的初始值）和解析。</p><p>初始化：（1）如果类存在直接的父类，且这个父类还没有被初始化，则先初始化父类。</p><p>​ （2）如果类中存在初始化语句，就依次执行这些初始化语句。</p><h2 id="_6、java对象创建的过程" tabindex="-1"><a class="header-anchor" href="#_6、java对象创建的过程" aria-hidden="true">#</a> 6、Java对象创建的过程</h2><p>（1）拿到内存创建的指令（new 类名），来到方法区，根据new的参数，在常量池找到一个类的符号引用。</p><p>（2）检查符号引用，检查是否被加载、解析和初始化过。</p><p>（3）分配内存。</p><p>（4）初始化：抽象数据类型默认初始化为null，基本数据类型为0，布尔为false...</p><p>（5）调用对象的初始化方法。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/Snipaste_2022-02-16_19-25-59.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="_7、java对象的结构" tabindex="-1"><a class="header-anchor" href="#_7、java对象的结构" aria-hidden="true">#</a> 7、Java对象的结构</h2><p>（1）对象头：运行时数据、指针类型。</p><p>（2）实例数据：存储对象真正的有效信息。</p><p>（3）对齐填充：要求对象初始地址必须是8字节的整数倍。</p><h2 id="_8、类的生命周期" tabindex="-1"><a class="header-anchor" href="#_8、类的生命周期" aria-hidden="true">#</a> 8、类的生命周期</h2><ul><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>验证：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ul><h2 id="_9、什么情况下会发生栈溢出" tabindex="-1"><a class="header-anchor" href="#_9、什么情况下会发生栈溢出" aria-hidden="true">#</a> 9、什么情况下会发生栈溢出？</h2><p>栈的大小可以通过-Xss参数设置，当递归层次太深的时候就会发生栈溢出。（例循环、递归）。</p><h2 id="_10、java垃圾回收机制-gc是什么-为什么要gc" tabindex="-1"><a class="header-anchor" href="#_10、java垃圾回收机制-gc是什么-为什么要gc" aria-hidden="true">#</a> 10、Java垃圾回收机制,GC是什么？为什么要GC?</h2><p><strong>Java垃圾回收机制</strong>：低优先级，只有在JVM空闲和当前堆内存不足时，会执行。扫描出那些没有被引用过的类，将他们添加到要回收的集合中，进行回收。</p><p><strong>GC</strong> 是垃圾收集的意思。</p><p>Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的。</p><h2 id="_11、jvm新生代、老年代、持久代都存储些哪些东西" tabindex="-1"><a class="header-anchor" href="#_11、jvm新生代、老年代、持久代都存储些哪些东西" aria-hidden="true">#</a> 11、JVM新生代、老年代、持久代都存储些哪些东西？</h2><p>（1）新生代：new出的对象。</p><p>（2）老年代：新生代中经历了N次垃圾回收仍存活的对象、大对象直接存入、Survivor空间不足。</p><p>（3）持久代：指方法区。</p><h2 id="_12、java会存在内存泄漏吗" tabindex="-1"><a class="header-anchor" href="#_12、java会存在内存泄漏吗" aria-hidden="true">#</a> 12、Java会存在内存泄漏吗？</h2><p><strong>内存泄漏</strong>：指一个不再被程序使用的对象或变量一直被占据在内存中。</p><p><strong>情况</strong>：长生命周期的对象只有断声明周期对象的引用时，可能发生内存泄漏。对生命周期对象已经不需要，但是因为长生命周期对象对其的引用，而无法回收。</p><h2 id="_13、jvm调优有哪些" tabindex="-1"><a class="header-anchor" href="#_13、jvm调优有哪些" aria-hidden="true">#</a> 13、JVM调优有哪些？</h2><p>（1）设定堆内存大小。-Mmx：堆内存最大限制。</p><p>（2）设定新生代大小：（不能太小，否则会大量涌入老年代）</p><p>​ -XX:NewSize：新生代大小</p><p>​ -XX:NewRatio：新生代和老生代占比</p><p>​ -XX:SurvivorRatio：伊甸园空间和幸存者空间占比</p><p>（3）设定垃圾回收器：年轻代：-XX:+UseParNewGC</p><p>​ 老年代：-XX:+UseConcMarkSweepGC</p><h2 id="说一下-jvm-调优的工具" tabindex="-1"><a class="header-anchor" href="#说一下-jvm-调优的工具" aria-hidden="true">#</a> 说一下 JVM 调优的工具？</h2><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p><ul><li>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</li><li>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</li></ul><h2 id="_14、如何判断对象可以被回收" tabindex="-1"><a class="header-anchor" href="#_14、如何判断对象可以被回收" aria-hidden="true">#</a> 14、如何判断对象可以被回收？</h2><ol><li>引用计数法 <ol><li>在JDK1.2之前，使用的是引用计数器算法。在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数器的值就+1，当引用失效的时候，计数器的值就-1，当引用计数器被减为零的时候，标志着这个对象已经没有引用了，可以回收了</li></ol></li><li>可达性分析法 <ol><li>通过一系列的称为 GC Roots 的对象作为起点, 然后向下搜索; 搜索所走过的路径称为引用链/Reference Chain, 当一个对象到 GC Roots 没有任何引用链相连时, 即该对象不可达, 也就说明此对象是不可用的。</li></ol></li></ol><h2 id="_15、-jvm的永久代中会发生垃圾回收么" tabindex="-1"><a class="header-anchor" href="#_15、-jvm的永久代中会发生垃圾回收么" aria-hidden="true">#</a> 15、 JVM的永久代中会发生垃圾回收么？</h2><p>垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收（Full GC）。</p><p>注：Java 8 中已经移除了永久代，新加了一个叫做元数据区的native 内存区。</p><h2 id="_16、栈帧有哪些数据" tabindex="-1"><a class="header-anchor" href="#_16、栈帧有哪些数据" aria-hidden="true">#</a> 16、栈帧有哪些数据？</h2><p>每个线程栈里的元素就是“栈帧”。</p><p>局部变量表、操作数栈、动态连接、返回地址。</p><h2 id="_17、java的双亲委托机制是什么" tabindex="-1"><a class="header-anchor" href="#_17、java的双亲委托机制是什么" aria-hidden="true">#</a> 17、Java的双亲委托机制是什么？</h2><blockquote><p>每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 双亲委派模型 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。</p></blockquote><h2 id="_18、说一下堆栈的区别" tabindex="-1"><a class="header-anchor" href="#_18、说一下堆栈的区别" aria-hidden="true">#</a> 18、说一下堆栈的区别？</h2><table><thead><tr><th></th><th>栈</th><th>堆</th></tr></thead><tbody><tr><td>物理地址</td><td>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。</td><td>堆的物理地址分配对对象是不连续的。因此性能慢些。</td></tr><tr><td>内存分别</td><td>栈是连续的，所以分配的内存大小要在<code>编译期</code>就确认，大小是固定的。</td><td>堆因为是不连续的，所以分配的内存是在<code>运行期</code>确认的，因此大小不固定。一般堆大小远远大于栈。</td></tr><tr><td>存放的内容</td><td>栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。</td><td>堆存放的是对象的实例和数组。因此该区更关注的是数据的存储</td></tr><tr><td>PS</td><td>静态变量放在方法区</td><td>静态的对象还是放在堆。</td></tr><tr><td>程序的可见度</td><td>栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。</td><td>堆对于整个应用程序都是共享、可见的。</td></tr></tbody></table><h2 id="_19、队列和栈是什么-有什么区别" tabindex="-1"><a class="header-anchor" href="#_19、队列和栈是什么-有什么区别" aria-hidden="true">#</a> 19、队列和栈是什么？有什么区别？</h2><p>队列和栈都是被用来预存储数据的。</p><table><thead><tr><th style="text-align:center;"></th><th>队列</th><th>栈</th></tr></thead><tbody><tr><td style="text-align:center;">操作的名称</td><td>队列的插入称为入队，队列的删除称为出队。</td><td>栈的插入称为进栈，栈的删除称为出栈。</td></tr><tr><td style="text-align:center;">可操作的方式</td><td>队列是在队尾入队，队头出队，即两边都可操作。</td><td>而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。</td></tr><tr><td style="text-align:center;">操作的方法</td><td>队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。</td><td>而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。</td></tr></tbody></table><h2 id="_20、为对象分配内存" tabindex="-1"><a class="header-anchor" href="#_20、为对象分配内存" aria-hidden="true">#</a> 20、为对象分配内存</h2><p>指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。<br> 空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。</p><figure><img src="https://edu--learn.oss-cn-beijing.aliyuncs.com/weixin/Snipaste_2022-02-16_19-28-57.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="_21、处理并发安全问题" tabindex="-1"><a class="header-anchor" href="#_21、处理并发安全问题" aria-hidden="true">#</a> 21、处理并发安全问题</h2><p>对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）；<br> 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。通过-XX:+/-UserTLAB参数来设定虚拟机是否使用TLAB。<br><img src="https://edu--learn.oss-cn-beijing.aliyuncs.com/weixin/Snipaste_2022-02-16_19-27-19.png" alt="img" loading="lazy"></p><h2 id="_22、说一下-jvm-有哪些垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#_22、说一下-jvm-有哪些垃圾回收算法" aria-hidden="true">#</a> 22、说一下 JVM 有哪些垃圾回收算法？</h2><ul><li><p>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</p><table><thead><tr><th>优点</th><th>解决了标记-清理算法存在的内存碎片问题。</th></tr></thead><tbody><tr><td>缺点</td><td>仍需要进行局部对象移动，一定程度上降低了效率。</td></tr></tbody></table></li><li><p>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。 <strong>适用于新生代。</strong></p><table><thead><tr><th>优点</th><th>按顺序分配内存即可，实现简单、运行高效，不用考虑内存碎片。</th></tr></thead><tbody><tr><td>优点</td><td>解决了标记-清理算法存在的内存碎片问题。可用的内存大小缩小为原来的一半，对象存活率高时会频繁进行复制。</td></tr></tbody></table></li><li><p>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。<strong>适用于老年代。</strong></p><table><thead><tr><th>优点</th><th>解决了标记-清理算法存在的内存碎片问题。</th></tr></thead><tbody><tr><td>缺点</td><td>仍需要进行局部对象移动，一定程度上降低了效率。</td></tr></tbody></table></li><li><p>分代算法：根据对象的<strong>存活周期</strong>将内存划分为几块。一般包括<strong>年轻代</strong>、<strong>老年代</strong> 和 <strong>永久代</strong>，新生代基本采用复制算法，老年代采用标记整理算法。</p></li></ul><h2 id="_23、分代概念" tabindex="-1"><a class="header-anchor" href="#_23、分代概念" aria-hidden="true">#</a> 23、分代概念</h2><p>新生成的对象首先放到年轻代Eden区，当Eden空间满了，触发Minor GC，存活下来的对象移动到Survivor0区，Survivor0区满后触发执行Minor GC，Survivor0区存活对象移动到Suvivor1区，这样保证了一段时间内总有一个survivor区为空。经过多次Minor GC仍然存活的对象移动到老年代。<br> 老年代存储长期存活的对象，占满时会触发Major GC=Full GC，GC期间会停止所有线程等待GC完成，所以对响应要求高的应用尽量减少发生Major GC，避免响应超时。<br> Minor GC ： 清理年轻代<br> Major GC ： 清理老年代<br> Full GC ： 清理整个堆空间，包括年轻代和永久代<br> 所有GC都会停止应用所有线程。</p><h2 id="_24、为什么分代" tabindex="-1"><a class="header-anchor" href="#_24、为什么分代" aria-hidden="true">#</a> 24、为什么分代？</h2><p>将对象根据存活概率进行分类，对存活时间长的对象，放到固定区，从而减少扫描垃圾时间及GC频率。针对分类进行不同的垃圾回收算法，对算法扬长避短。</p><h2 id="_25、jvm堆内存常用参数" tabindex="-1"><a class="header-anchor" href="#_25、jvm堆内存常用参数" aria-hidden="true">#</a> 25、JVM堆内存常用参数</h2><table><thead><tr><th style="text-align:left;">参数</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">-Xms</td><td style="text-align:left;">堆内存初始大小，单位m、g</td></tr><tr><td style="text-align:left;">-Xmx（MaxHeapSize）</td><td style="text-align:left;">堆内存最大允许大小，一般不要大于物理内存的80%</td></tr><tr><td style="text-align:left;">-XX:PermSize</td><td style="text-align:left;">非堆内存初始大小，一般应用设置初始化200m，最大1024m就够了</td></tr><tr><td style="text-align:left;">-XX:MaxPermSize</td><td style="text-align:left;">非堆内存最大允许大小</td></tr><tr><td style="text-align:left;">-XX:NewSize（-Xns）</td><td style="text-align:left;">年轻代内存初始大小</td></tr><tr><td style="text-align:left;">-XX:MaxNewSize（-Xmn）</td><td style="text-align:left;">年轻代内存最大允许大小，也可以缩写</td></tr><tr><td style="text-align:left;">-XX:SurvivorRatio=8</td><td style="text-align:left;">年轻代中Eden区与Survivor区的容量比例值，默认为8，即8:1</td></tr><tr><td style="text-align:left;">-Xss</td><td style="text-align:left;">堆栈内存大小</td></tr></tbody></table><h2 id="_26、类加载的过程" tabindex="-1"><a class="header-anchor" href="#_26、类加载的过程" aria-hidden="true">#</a> 26、类加载的过程</h2><p>JVM的类加载分为5个阶段：加载、验证、准备、解析、初始化。在类初始化完成后就可以使用该类的信息，在一个类不再被需要时可以从JVM中卸载</p><ol><li><p>加载</p><ol><li>指JVM读取Class文件，并且根据Class文件描述创建java. lang. Class对象的过程。类加载过程主要包含将Class文件读取到运行时区域的方法区内，在堆中创建java.lang.Class 对象，并封装类在方法区的数据结构的过程，在i卖取Class文件时既可以通过文件的形式读取，也可以通过jar包、war包读取，还可以通过代理自动生成Class或其他方式读取。</li></ol></li><li><p>验证</p><ol><li>主要用于确保Class文件符合当前虚拟机的要求，保障虚拟机自身的安全，只有通过验证的Class文件才能被JVM加载。</li></ol></li><li><p>准备</p><ol><li>主要工作是在方法区中为类变量分配内存空间并设置类中变量的初始值。初始值指不同数据类型的默认值，这里需要注意final类型的变量和非final类型的变量在准备阶段的数据初始化过程不同。</li></ol></li><li><p>解析</p><ol><li>JVM会将常量池中的符号引用替换为直接引用。</li></ol></li><li><p>初始化</p><ol><li>要通过执行类构造器的＜client＞方法为类进行初始化。＜client＞方法是在编译阶段由编译器自动收集类中静态语句块和变量的赋值操作组成的。JVM规定，只有在父类的&lt;client＞方法都执行成功后，子类中的＜client＞方法才可以被执行。在一个类中既没有静态变量赋值操作也没有静态语句块时，编译器不会为该类生成＜client＞方法</li></ol></li></ol><h2 id="_27、java中的4种引用类型" tabindex="-1"><a class="header-anchor" href="#_27、java中的4种引用类型" aria-hidden="true">#</a> 27、Java中的4种引用类型</h2><ol><li>强引用：在Java中最常见的就是强引用。在把一个对象赋给一个引用变量时，这个引用变量就是一个强引用。有强引用的对象一定为可达性状态，所以不会被垃圾回收机制回收。因此，强引用是造成Java内存泄漏（Memory Link ）的主要原因。</li><li>软引用：软引用通过SoftReference类实现。如果一个对象只有软引用，则在系统内存空间不足时该对象将被回收。</li><li>弱引用：弱引用通过WeakReference类实现，如果一个对象只有弱引用，则在垃圾回收过程中一定会被回收。</li><li>虚引用：虚引用通过PhantomReference类实现，虚引用和引用队列联合使用，主要用于跟踪对象的垃圾回收状态。</li></ol><h1 id="六、mysql面试题" tabindex="-1"><a class="header-anchor" href="#六、mysql面试题" aria-hidden="true">#</a> 六、MySQL面试题</h1><h2 id="_1、什么是mysql" tabindex="-1"><a class="header-anchor" href="#_1、什么是mysql" aria-hidden="true">#</a> 1、什么是MySQL</h2><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p><h2 id="_2、数据库三大范式" tabindex="-1"><a class="header-anchor" href="#_2、数据库三大范式" aria-hidden="true">#</a> 2、数据库三大范式</h2><ol><li>第一范式：每个列都不可以再拆分。</li><li>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</li><li>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</li></ol><p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p><h2 id="_3、对慢查询怎么样优化过" tabindex="-1"><a class="header-anchor" href="#_3、对慢查询怎么样优化过" aria-hidden="true">#</a> 3、对慢查询怎么样优化过？</h2><p>（1）分析语句，看是否查询了多余的行并且抛弃掉了，是否加载了许多结果中不需要的列，对语句进行分析以及重写；</p><p>（2）分析语句的执行计划，获得其使用索引的情况，进行修改，使语句可以尽可能的命中索引；</p><p>（3）考虑数据量是否太大，可以考虑进行横向或者纵向分表。</p><h2 id="_4、mysql有关权限的表都有哪几个" tabindex="-1"><a class="header-anchor" href="#_4、mysql有关权限的表都有哪几个" aria-hidden="true">#</a> 4、mysql有关权限的表都有哪几个</h2><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p><ul><li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li><li>db权限表：记录各个帐号在各个数据库上的操作权限。</li><li>table_priv权限表：记录数据表级的操作权限。</li><li>columns_priv权限表：记录数据列级的操作权限。</li><li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li></ul><h2 id="_5、mysql由哪些部分组成" tabindex="-1"><a class="header-anchor" href="#_5、mysql由哪些部分组成" aria-hidden="true">#</a> 5、MySQL由哪些部分组成？</h2><p>（1）Server</p><p>连接器：管理连接、权限验证</p><p>分析器：词法分析，语法分析</p><p>优化器：执行计划生成，索引的选择</p><p>执行器：操作存储引擎，返回执行结果</p><p>（2）存储引擎</p><p>存储数据，提供读写接口。</p><h2 id="_6、优化数据库的方法" tabindex="-1"><a class="header-anchor" href="#_6、优化数据库的方法" aria-hidden="true">#</a> 6、优化数据库的方法</h2><p>（1）选取最合适的字段，尽可能减少定义阻断宽度，尽量NOTNULL。</p><p>（2）使用JOIN（连接）来代替子查询。</p><p>（3）使用UNION（联合）来代替手动创建临时表。</p><p>（4）事务处理。</p><p>（5）锁定表，优化事务处理。</p><p>（6）使用外键，优化锁定表。</p><p>（7）建立索引。</p><p>（8）优化查询语句。</p><h3 id="优化查询过程中的数据访问" tabindex="-1"><a class="header-anchor" href="#优化查询过程中的数据访问" aria-hidden="true">#</a> 优化查询过程中的数据访问</h3><ol><li>访问数据太多导致查询性能下降</li><li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li><li>确认MySQL服务器是否在分析大量不必要的数据行</li><li>避免犯如下SQL语句错误</li><li>查询不需要的数据。解决办法：使用limit解决</li><li>多表关联返回全部列。解决办法：指定列名</li><li>总是返回全部列。解决办法：避免使用SELECT *</li><li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li><li>是否在扫描额外的记录。解决办法：</li><li>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</li><li>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li><li>改变数据库和表的结构，修改数据表范式</li><li>重写SQL语句，让优化器可以以更优的方式执行查询。</li></ol><h3 id="优化长难的查询语句" tabindex="-1"><a class="header-anchor" href="#优化长难的查询语句" aria-hidden="true">#</a> 优化长难的查询语句</h3><ol><li>一个复杂查询还是多个简单查询</li><li>MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</li><li>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</li><li>切分查询</li><li>将一个大的查询分为多个小的相同的查询</li><li>一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</li><li>分解关联查询，让缓存的效率更高。</li><li>执行单个查询可以减少锁的竞争。</li><li>在应用层做关联更容易对数据库进行拆分。</li><li>查询效率会有大幅提升。</li><li>较少冗余记录的查询。</li></ol><h3 id="优化特定类型的查询语句" tabindex="-1"><a class="header-anchor" href="#优化特定类型的查询语句" aria-hidden="true">#</a> 优化特定类型的查询语句</h3><ol><li>count(<em>)会忽略所有的列，直接统计所有列数，不要使用count(列名)</em></li><li>MyISAM中，没有任何where条件的count(*)非常快。</li><li>当有where条件时，MyISAM的count统计不一定比其它引擎快。</li><li>可以使用explain查询近似值，用近似值替代count(*)</li><li>增加汇总表</li><li>使用缓存</li></ol><h3 id="优化关联查询" tabindex="-1"><a class="header-anchor" href="#优化关联查询" aria-hidden="true">#</a> 优化关联查询</h3><ul><li>确定ON或者USING子句中是否有索引。</li><li>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li></ul><h3 id="优化子查询" tabindex="-1"><a class="header-anchor" href="#优化子查询" aria-hidden="true">#</a> 优化子查询</h3><p>用关联查询替代</p><h3 id="优化group-by和distinct" tabindex="-1"><a class="header-anchor" href="#优化group-by和distinct" aria-hidden="true">#</a> 优化GROUP BY和DISTINCT</h3><ol><li>这两种查询据可以使用索引来优化，是最有效的优化方法</li><li>关联查询中，使用标识列分组的效率更高</li><li>如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</li><li>WITH ROLLUP超级聚合，可以挪到应用程序处理</li></ol><h3 id="优化limit分页" tabindex="-1"><a class="header-anchor" href="#优化limit分页" aria-hidden="true">#</a> 优化LIMIT分页</h3><ul><li>LIMIT偏移量大的时候，查询效率较低</li><li>可以记录上次查询的最大ID，下次查询时直接根据该ID来查询</li></ul><h3 id="优化union查询" tabindex="-1"><a class="header-anchor" href="#优化union查询" aria-hidden="true">#</a> 优化UNION查询</h3><p>UNION ALL的效率高于UNION</p><h2 id="_7、解释一下交叉连接、内连接、外连接" tabindex="-1"><a class="header-anchor" href="#_7、解释一下交叉连接、内连接、外连接" aria-hidden="true">#</a> 7、解释一下交叉连接、内连接、外连接</h2><p>（1）交叉连接（笛卡尔积）：不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。</p><p>（2）内连接：只有条件的交叉连接，根据某个条件筛选出符合的记录。</p><p>（3）外连接：不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行。</p><h3 id="六种关联查询" tabindex="-1"><a class="header-anchor" href="#六种关联查询" aria-hidden="true">#</a> 六种关联查询</h3><ul><li>交叉连接（CROSS JOIN）</li><li>内连接（INNER JOIN）</li><li>外连接（LEFT JOIN/RIGHT JOIN）</li><li>联合查询（UNION与UNION ALL）</li><li>全连接（FULL JOIN）</li></ul><h3 id="外连接-left-join-right-join" tabindex="-1"><a class="header-anchor" href="#外连接-left-join-right-join" aria-hidden="true">#</a> 外连接（LEFT JOIN/RIGHT JOIN）</h3><p><strong>左外连接</strong>：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN<br><strong>右外连接</strong>：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</p><h3 id="联合查询-union与union-all" tabindex="-1"><a class="header-anchor" href="#联合查询-union与union-all" aria-hidden="true">#</a> 联合查询（UNION与UNION ALL）</h3><ul><li>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</li><li>如果使用UNION ALL，不会合并重复的记录行</li><li>效率 UNION 高于 UNION ALL</li></ul><h3 id="全连接-full-join" tabindex="-1"><a class="header-anchor" href="#全连接-full-join" aria-hidden="true">#</a> 全连接（FULL JOIN）</h3><ul><li>MySQL不支持全连接</li><li>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li></ul><h2 id="_8、为什么要使用notnull" tabindex="-1"><a class="header-anchor" href="#_8、为什么要使用notnull" aria-hidden="true">#</a> 8、为什么要使用NOTNULL？</h2><p>Null值会占用更多的字节，并且会在程序中造成很多与预期不符的结果。</p><h2 id="_9、什么是索引" tabindex="-1"><a class="header-anchor" href="#_9、什么是索引" aria-hidden="true">#</a> 9、什么是索引？</h2><p>是一种数据结构，可以帮助我们快速的进行数据的查找。</p><p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p><p>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。</p><p>索引是一个文件，它是要占据物理空间的。</p><p><strong>优点</strong>：（1）提高数据检索的效率，降低数据库的IO成本。</p><p>​ （2）通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</p><p><strong>缺点</strong>：（1）降低更新表的速度。</p><p>​ （2）索引也是一张表，该表保存了主键与索引字段，并且指向实体表的记录，所以索引表也需要占用空间。</p><p>​ (3)创建索引和维护索引需要消耗时间，并且随着数据了的增加，所消耗的时间也会增加。</p><h3 id="索引有哪几种类型" tabindex="-1"><a class="header-anchor" href="#索引有哪几种类型" aria-hidden="true">#</a> 索引有哪几种类型？</h3><p><strong>主键索引:</strong> 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p><p><strong>唯一索引:</strong> 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p><p><strong>普通索引:</strong> 基本的索引类型，没有唯一性的限制，允许为NULL值。</p><p><strong>全文索引：</strong> 是目前搜索引擎使用的一种关键技术。</p><h3 id="索引的基本原理" tabindex="-1"><a class="header-anchor" href="#索引的基本原理" aria-hidden="true">#</a> 索引的基本原理</h3><ol><li>把创建了索引的列的内容进行排序</li><li>对排序结果生成倒排表</li><li>在倒排表内容上拼上数据地址链</li><li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li></ol><h3 id="索引设计的原则" tabindex="-1"><a class="header-anchor" href="#索引设计的原则" aria-hidden="true">#</a> 索引设计的原则？</h3><ol><li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li><li>基数较小的类，索引效果较差，没有必要在此列建立索引</li><li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li><li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li></ol><h3 id="创建索引的原则-重中之重" tabindex="-1"><a class="header-anchor" href="#创建索引的原则-重中之重" aria-hidden="true">#</a> 创建索引的原则（重中之重）</h3><p>索引虽好，但也不是无限制的使用，最好符合一下几个原则</p><p>1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p><p>2）较频繁作为查询条件的字段才去创建索引</p><p>3）更新频繁字段不适合创建索引</p><p>4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p><p>5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p><p>6）定义有外键的数据列一定要建立索引。</p><p>7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p><p>8）对于定义为text、image和bit的数据类型的列不要建立索引。</p><h3 id="使用索引查询一定能提高查询的性能吗-为什么" tabindex="-1"><a class="header-anchor" href="#使用索引查询一定能提高查询的性能吗-为什么" aria-hidden="true">#</a> 使用索引查询一定能提高查询的性能吗？为什么</h3><p>通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p><ul><li>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li><li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li><li>基于非唯一性索引的检索</li></ul><h2 id="_10、什么是事务" tabindex="-1"><a class="header-anchor" href="#_10、什么是事务" aria-hidden="true">#</a> 10、什么是事务？</h2><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><h3 id="mysql-事务隔离级别" tabindex="-1"><a class="header-anchor" href="#mysql-事务隔离级别" aria-hidden="true">#</a> MySQL 事务隔离级别</h3><ul><li>未提交读 - 读到其它事务未提交的数据（最新的版本） <ul><li>错误现象：有脏读、不可重复读、幻读现象</li></ul></li><li>提交读（RC） - 读到其它事务已提交的数据（最新已提交的版本） <ul><li>错误现象：有不可重复读、幻读现象</li><li>使用场景：希望看到最新的有效值</li></ul></li><li>可重复读（RR） - 在事务范围内，多次读能够保证一致性（快照建立时最新已提交版本） <ul><li>错误现象：有幻读现象，可以用加锁避免</li><li>使用场景：事务内要求更强的一致性，但看到的未必是最新的有效值</li></ul></li><li>串行读 - 在事务范围内，仅有读读可以并发，读写或写写会阻塞其它事务，用这种办法保证更强的一致性 <ul><li>错误现象：无</li></ul></li></ul><h2 id="_11、acid事务的特性" tabindex="-1"><a class="header-anchor" href="#_11、acid事务的特性" aria-hidden="true">#</a> 11、ACID事务的特性</h2><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230206131028026.png" alt="image-20230206131028026" style="zoom:80%;"><p>原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p><p>一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</p><p>隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p><p>持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p><h2 id="_12、并发事务带来了哪些问题" tabindex="-1"><a class="header-anchor" href="#_12、并发事务带来了哪些问题" aria-hidden="true">#</a> 12、并发事务带来了哪些问题？</h2><p>（1）脏读：一个事务对数据进行了修改，还未提交到数据库；另一个事务使用了未修改的数据，依据这个脏数据所做的操作可能是不正确的。</p><p>（2）丢失修改：两个事务同时访问并修改同一个数据，那么第一个事务修改的结果就会被丢失。</p><p>（3）不可重复读：在一个事务内多次读取同一数据。在这个事务结束之前，另一个事务进修改了数据，那么第一个事务两次读取的数据就会不一样了。</p><p>（4）幻读：发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据，在随后的查询中，第一个事务就会发现多了一些原本不存在的数据。</p><h2 id="_13、mysql的四种隔离级别" tabindex="-1"><a class="header-anchor" href="#_13、mysql的四种隔离级别" aria-hidden="true">#</a> 13、MySQL的四种隔离级别</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230206131720416.png" alt="image-20230206131720416" tabindex="0" loading="lazy"><figcaption>image-20230206131720416</figcaption></figure><p>（1）读未提交：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p><p>（2）读已提交：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p><p>（3）可重复读：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p><p>（4）可串行化：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p><h3 id="隔离级别与锁的关系" tabindex="-1"><a class="header-anchor" href="#隔离级别与锁的关系" aria-hidden="true">#</a> 隔离级别与锁的关系</h3><blockquote><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p><p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p><p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p><p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p></blockquote><h2 id="_14、mysql存储引擎myisam与innodb区别" tabindex="-1"><a class="header-anchor" href="#_14、mysql存储引擎myisam与innodb区别" aria-hidden="true">#</a> 14、MySQL存储引擎MyISAM与InnoDB区别</h2><p>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p><p>常用的存储引擎有以下：</p><ul><li>Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li><li>MyIASM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</li><li>MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li></ul><h3 id="myisam索引与innodb索引的区别" tabindex="-1"><a class="header-anchor" href="#myisam索引与innodb索引的区别" aria-hidden="true">#</a> MyISAM索引与InnoDB索引的区别？</h3><ul><li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li><li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li><li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li><li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li></ul><h3 id="myisam与innodb区别" tabindex="-1"><a class="header-anchor" href="#myisam与innodb区别" aria-hidden="true">#</a> MyISAM与InnoDB区别</h3><blockquote><ul><li>InnoDB支持事务，MyISAM不支持事务</li><li>InnoDB支持外键，MyISAM不支持外键</li><li>InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持</li><li>select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB就需要全表扫描。</li><li>Innodb不支持全文索引，而MyISAM支持全文索引（5.7以后的InnoDB也支持全文索引）</li><li>InnoDB支持表、行级锁，而MyISAM支持表级锁。</li><li>InnoDB表必须有主键，而MyISAM可以没有主键</li><li>Innodb表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小，。</li><li>Innodb按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。</li><li>InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引</li></ul></blockquote><h3 id="innodb引擎的4大特性" tabindex="-1"><a class="header-anchor" href="#innodb引擎的4大特性" aria-hidden="true">#</a> InnoDB引擎的4大特性</h3><ul><li>插入缓冲（insert buffer)</li><li>二次写(double write)</li><li>自适应哈希索引(ahi)</li><li>预读(read ahead)</li></ul><h2 id="_15、百万级别或以上的数据如何删除" tabindex="-1"><a class="header-anchor" href="#_15、百万级别或以上的数据如何删除" aria-hidden="true">#</a> 15、百万级别或以上的数据如何删除</h2><ol><li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li><li>然后删除其中无用数据（此过程需要不到两分钟）</li><li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li><li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li></ol><h2 id="_16、数据库为什么使用b-树而不是b树" tabindex="-1"><a class="header-anchor" href="#_16、数据库为什么使用b-树而不是b树" aria-hidden="true">#</a> 16、数据库为什么使用B+树而不是B树</h2><ul><li>B树只适合随机检索</li><li>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。</li><li>B+树的查询效率更加稳定。</li><li>B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。</li><li>增删文件（节点）时，效率更高。</li></ul><h2 id="_17、对mysql的锁了解吗" tabindex="-1"><a class="header-anchor" href="#_17、对mysql的锁了解吗" aria-hidden="true">#</a> 17、对MySQL的锁了解吗？</h2><p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</p><p><strong>什么是死锁？怎么解决？</strong><br> 死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p><strong>常见的解决死锁的方法</strong></p><p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p><p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p><p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p><p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p><p><strong>数据库的乐观锁和悲观锁是什么？怎么实现的？</strong></p><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p><p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p><h2 id="_18、为什么要使用视图-什么是视图" tabindex="-1"><a class="header-anchor" href="#_18、为什么要使用视图-什么是视图" aria-hidden="true">#</a> 18、为什么要使用视图？什么是视图？</h2><p>为了提高复杂SQL语句的复用性和表操作的安全性。</p><p>一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。</p><p>视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</p><h2 id="_19、视图有哪些特点" tabindex="-1"><a class="header-anchor" href="#_19、视图有哪些特点" aria-hidden="true">#</a> 19、视图有哪些特点？</h2><ul><li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li><li>视图是由基本表(实表)产生的表(虚表)。</li><li>视图的建立和删除不影响基本表。</li><li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li><li>当视图来自多个基本表时，不允许添加和删除数据。</li></ul><h2 id="_20、视图的使用场景有哪些" tabindex="-1"><a class="header-anchor" href="#_20、视图的使用场景有哪些" aria-hidden="true">#</a> 20、视图的使用场景有哪些？</h2><ul><li>重用SQL语句；</li><li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li><li>使用表的组成部分而不是整个表；</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul><h2 id="_21、视图的优点" tabindex="-1"><a class="header-anchor" href="#_21、视图的优点" aria-hidden="true">#</a> 21、视图的优点</h2><ol><li>查询简单化。视图能简化用户的操作</li><li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li><li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li></ol><h2 id="_22、视图的缺点" tabindex="-1"><a class="header-anchor" href="#_22、视图的缺点" aria-hidden="true">#</a> 22、视图的缺点</h2><ul><li><p>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p></li><li><p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</p></li><li><p>这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\SUM\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）</p></li></ul><h2 id="_23、存储过程与函数" tabindex="-1"><a class="header-anchor" href="#_23、存储过程与函数" aria-hidden="true">#</a> 23、存储过程与函数</h2><p>什么是存储过程？有哪些优缺点？<br> 存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><p><strong>优点</strong></p><p>1）存储过程是预编译过的，执行效率高。</p><p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p><p>3）安全性高，执行存储过程需要有一定权限的用户。</p><p>4）存储过程可以重复使用，减少数据库开发人员的工作量。</p><p><strong>缺点</strong></p><p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p><p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p><p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p><p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p><h2 id="_24、什么是触发器-触发器的使用场景有哪些" tabindex="-1"><a class="header-anchor" href="#_24、什么是触发器-触发器的使用场景有哪些" aria-hidden="true">#</a> 24、什么是触发器？触发器的使用场景有哪些？</h2><p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p><p>使用场景</p><ul><li>可以通过数据库中的相关表实现级联更改。</li><li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li><li>例如可以生成某些业务的编号。</li><li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li><li>大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li></ul><h2 id="_25、超键、候选键、主键、外键分别是什么" tabindex="-1"><a class="header-anchor" href="#_25、超键、候选键、主键、外键分别是什么" aria-hidden="true">#</a> 25、超键、候选键、主键、外键分别是什么？</h2><ul><li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>候选键：是最小超键，即没有冗余元素的超键。</li><li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>外键：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h2 id="_26、什么是子查询" tabindex="-1"><a class="header-anchor" href="#_26、什么是子查询" aria-hidden="true">#</a> 26、什么是子查询？</h2><ol><li>条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果</li><li>嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</li></ol><h2 id="_27、mysql中-in-和-exists-区别" tabindex="-1"><a class="header-anchor" href="#_27、mysql中-in-和-exists-区别" aria-hidden="true">#</a> 27、mysql中 in 和 exists 区别？</h2><p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p><h2 id="_28、大表数据查询-怎么优化" tabindex="-1"><a class="header-anchor" href="#_28、大表数据查询-怎么优化" aria-hidden="true">#</a> 28、大表数据查询，怎么优化？</h2><ol><li>优化shema、sql语句+索引；</li><li>第二加缓存，memcached, redis；</li><li>主从复制，读写分离；</li><li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li><li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li></ol><h2 id="_29、超大分页怎么处理" tabindex="-1"><a class="header-anchor" href="#_29、超大分页怎么处理" aria-hidden="true">#</a> 29、超大分页怎么处理？</h2><ul><li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li><li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li></ul><h2 id="_30、关心过业务系统里面的sql耗时吗-统计过慢查询吗-对慢查询都怎么优化过" tabindex="-1"><a class="header-anchor" href="#_30、关心过业务系统里面的sql耗时吗-统计过慢查询吗-对慢查询都怎么优化过" aria-hidden="true">#</a> 30、关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h2><ul><li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li><li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。<br> 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li></ul><h2 id="_31、char-和varchar-的区别" tabindex="-1"><a class="header-anchor" href="#_31、char-和varchar-的区别" aria-hidden="true">#</a> 31、CHAR 和VARCHAR 的区别？</h2><blockquote><ul><li>CHAR 和 VARCHAR <strong>类型在存储和检索方面有所不同</strong></li><li>CHAR 列长度固定为创建表时声明的长度， 长度值范围是 1 到 255 当 CHAR 值被存储时， 它们被用空格填充到特定长度， 检索 CHAR 值时需删除尾随空格。</li></ul></blockquote><h2 id="_32、数据库索引的原理-为什么要用b-树-为什么不用二叉树" tabindex="-1"><a class="header-anchor" href="#_32、数据库索引的原理-为什么要用b-树-为什么不用二叉树" aria-hidden="true">#</a> 32、数据库索引的原理，为什么要用B+树，为什么不用二叉树？</h2><blockquote><p><strong>为什么不是一般二叉树？</strong></p><p>如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p><p><strong>为什么不是平衡二叉树呢？</strong></p><p>我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。</p><p><strong>那为什么不是B树而是B+树呢？</strong></p><ul><li>B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。innodb中页的默认大小是16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。</li><li>B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。</li></ul></blockquote><h2 id="_33、数据库自增主键可能遇到什么问题" tabindex="-1"><a class="header-anchor" href="#_33、数据库自增主键可能遇到什么问题" aria-hidden="true">#</a> 33、数据库自增主键可能遇到什么问题</h2><ul><li>使用自增主键对数据库做分库分表，可能出现诸如主键重复等的问题。解决方案的话，简单点的话可以考虑使用UUID解决，复杂的可以考虑前面提到的分布式主键方案</li><li>自增主键会产生表锁，从而引发问题</li><li>自增主键可能用完问题。</li></ul><h2 id="_34、blob和text有什么区别" tabindex="-1"><a class="header-anchor" href="#_34、blob和text有什么区别" aria-hidden="true">#</a> 34、Blob和text有什么区别？</h2><ul><li>Blob用于存储二进制数据，而Text用于存储大字符串。</li><li>Blob值被视为二进制字符串（字节字符串）,它们没有字符集，并且排序和比较基于列值中的字节的数值。</li><li>text值被视为非二进制字符串（字符字符串）。它们有一个字符集，并根据字符集的排序规则对值进行排序和比较</li></ul><h2 id="_35、count-1-、count-与-count-列名-的区别" tabindex="-1"><a class="header-anchor" href="#_35、count-1-、count-与-count-列名-的区别" aria-hidden="true">#</a> 35、count(1)、count(*) 与 count(列名) 的区别？</h2><blockquote><ul><li>count(*)：包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li><li>count(1)：包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL</li><li>count(列名)：只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是指空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li></ul></blockquote><h2 id="_36、查询语句执行流程" tabindex="-1"><a class="header-anchor" href="#_36、查询语句执行流程" aria-hidden="true">#</a> 36、查询语句执行流程</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230206113648340.png" alt="image-20230206113648340" tabindex="0" loading="lazy"><figcaption>image-20230206113648340</figcaption></figure><ol><li>连接器：负责建立连接、检查权限、连接超时时间由 wait_timeout 控制，默认 8 小时</li><li>查询缓存：会将 SQL 和查询结果以键值对方式进行缓存，修改操作会以表单位导致缓存失效</li><li>分析器：词法、语法分析</li><li>优化器：决定用哪个索引，决定表的连接顺序等</li><li>执行器：根据存储引擎类型，调用存储引擎接口</li><li>存储引擎：数据的读写接口，索引、表都在此层实现</li></ol><h2 id="_37、mysql锁" tabindex="-1"><a class="header-anchor" href="#_37、mysql锁" aria-hidden="true">#</a> 37、MySQL锁</h2><h3 id="_1、全局锁" tabindex="-1"><a class="header-anchor" href="#_1、全局锁" aria-hidden="true">#</a> 1、全局锁</h3><p>用作全量备份时，保证<strong>表与表之间的数据一致性</strong></p><p>如果不加任何包含，数据备份时就可能产生不一致的情况，如下图所示</p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230206113816398.png" alt="image-20230206113816398" style="zoom:80%;"><ul><li>使用全局读锁锁定所有数据库的所有表。这时会阻塞其它所有 DML 以及 DDL 操作，这样可以避免备份过程中的数据不一致。接下来可以执行备份，最后用 unlock tables 来解锁</li></ul><h3 id="_2、表级锁" tabindex="-1"><a class="header-anchor" href="#_2、表级锁" aria-hidden="true">#</a> 2、表级锁</h3><h4 id="_1、表锁" tabindex="-1"><a class="header-anchor" href="#_1、表锁" aria-hidden="true">#</a> 1、表锁</h4><blockquote><ul><li>语法：加锁 lock tables 表名 read/write，解锁 unlock tables</li><li>缺点：粒度较粗，在 InnoDB 引擎很少使用</li></ul></blockquote><h4 id="_2、元数据锁" tabindex="-1"><a class="header-anchor" href="#_2、元数据锁" aria-hidden="true">#</a> 2、元数据锁</h4><blockquote><ul><li><p>即 metadata-lock（MDL），主要是为<strong>了避免 DML 与 DDL 冲突</strong>，DML 的元数据锁之间不互斥</p></li><li><p>加元数据锁的几种情况</p><ul><li><code>lock tables read/write</code>，类型为 SHARED_READ_ONLY 和 SHARED_NO_READ_WRITE</li><li><code>alter table</code>，类型为 EXCLUSIVE，与其它 MDL 都互斥</li><li><code>select，select … lock in share mode</code>，类型为 SHARED_READ</li><li><code>insert，update，delete，select for update</code>，类型为 SHARED_WRITE</li></ul></li><li><p>查看元数据锁（适用于 MySQL 8.0 以上版本）</p><p><code>select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks;</code></p></li></ul></blockquote><h3 id="_3、行级锁" tabindex="-1"><a class="header-anchor" href="#_3、行级锁" aria-hidden="true">#</a> 3、行级锁</h3><ul><li>种类 <ul><li>行锁 – 在 RC 下，锁住的是行，防止其他事务对此行 update 或 delete</li><li>间隙锁 – 在 RR 下，锁住的是间隙，防止其他事务在这个间隙 insert 产生幻读</li><li>临键锁 – 在 RR 下，锁住的是前面间隙+行，特定条件下可优化为行锁</li></ul></li><li>查看行级锁 <ul><li><code>select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks where object_name=&#39;表名&#39;;</code></li></ul></li></ul><blockquote><p><em><strong>注意</strong></em></p><ul><li>它们锁定的其实都是<strong>索引</strong>上的行与间隙，根据索引的有序性来确定间隙</li></ul></blockquote><h2 id="_38、什么是最左前缀原则-什么是最左匹配原则" tabindex="-1"><a class="header-anchor" href="#_38、什么是最左前缀原则-什么是最左匹配原则" aria-hidden="true">#</a> 38、什么是最左前缀原则？什么是最左匹配原则</h2><ul><li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li><li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li><li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li></ul><h2 id="_39、什么是聚簇索引-何时使用聚簇索引与非聚簇索引" tabindex="-1"><a class="header-anchor" href="#_39、什么是聚簇索引-何时使用聚簇索引与非聚簇索引" aria-hidden="true">#</a> 39、什么是聚簇索引？何时使用聚簇索引与非聚簇索引</h2><ul><li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li><li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因。</li></ul><h2 id="_40、联合索引是什么-为什么需要注意联合索引中的顺序" tabindex="-1"><a class="header-anchor" href="#_40、联合索引是什么-为什么需要注意联合索引中的顺序" aria-hidden="true">#</a> 40、联合索引是什么？为什么需要注意联合索引中的顺序？</h2><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p><p><strong>具体原因为:</strong></p><p>MySQL使用索引时需要索引有序，假设现在建立了&quot;name，age，school&quot;的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p><p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p><h2 id="_41、sql语句主要分为哪几类" tabindex="-1"><a class="header-anchor" href="#_41、sql语句主要分为哪几类" aria-hidden="true">#</a> 41、SQL语句主要分为哪几类</h2><blockquote><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p><p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p><p>数据查询语言DQL（Data Query Language）SELECT</p><p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p><p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p><p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p><p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p><p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p></blockquote><h2 id="_42、超键、候选键、主键、外键分别是什么" tabindex="-1"><a class="header-anchor" href="#_42、超键、候选键、主键、外键分别是什么" aria-hidden="true">#</a> 42、超键、候选键、主键、外键分别是什么？</h2><ul><li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一</li><li>超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>候选键：是最小超键，即没有冗余元素的超键。</li><li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>外键：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h2 id="_43、sql-约束有哪几种" tabindex="-1"><a class="header-anchor" href="#_43、sql-约束有哪几种" aria-hidden="true">#</a> 43、SQL 约束有哪几种？</h2><blockquote><ol><li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li><li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li>CHECK: 用于控制字段的值范围。</li></ol></blockquote><h2 id="_44、varchar-50-中50的涵义" tabindex="-1"><a class="header-anchor" href="#_44、varchar-50-中50的涵义" aria-hidden="true">#</a> 44、varchar(50)中50的涵义</h2><blockquote><p>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</p></blockquote><h2 id="_45、int-20-中20的涵义" tabindex="-1"><a class="header-anchor" href="#_45、int-20-中20的涵义" aria-hidden="true">#</a> 45、int(20)中20的涵义</h2><blockquote><p>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；</p><p>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</p></blockquote><h2 id="_46、为什么要尽量设定一个主键" tabindex="-1"><a class="header-anchor" href="#_46、为什么要尽量设定一个主键" aria-hidden="true">#</a> 46、为什么要尽量设定一个主键？</h2><blockquote><p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p></blockquote><h2 id="_47、mysql的复制原理以及流程" tabindex="-1"><a class="header-anchor" href="#_47、mysql的复制原理以及流程" aria-hidden="true">#</a> 47、MySQL的复制原理以及流程</h2><blockquote><p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p></blockquote><h2 id="_48、mysql主从复制的作用" tabindex="-1"><a class="header-anchor" href="#_48、mysql主从复制的作用" aria-hidden="true">#</a> 48、MySQL主从复制的作用</h2><blockquote><ol><li>主数据库出现问题，可以切换到从数据库。</li><li>可以进行数据库层面的读写分离。</li><li>可以在从数据库上进行日常备份。</li></ol></blockquote><h2 id="_49、mysql主从复制工作原理" tabindex="-1"><a class="header-anchor" href="#_49、mysql主从复制工作原理" aria-hidden="true">#</a> 49、MySQL主从复制工作原理</h2><blockquote><ul><li>在主库上把数据更高记录到二进制日志</li><li>从库将主库的日志复制到自己的中继日志</li><li>从库读取中继日志的事件，将其重放到从库数据中</li></ul></blockquote><h2 id="_50、什么是死锁-怎么解决" tabindex="-1"><a class="header-anchor" href="#_50、什么是死锁-怎么解决" aria-hidden="true">#</a> 50、什么是死锁？怎么解决？</h2><blockquote><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p>常见的解决死锁的方法</p><p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p><p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p><p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p><p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p></blockquote><h3 id="_51、数据库的乐观锁和悲观锁是什么-怎么实现的" tabindex="-1"><a class="header-anchor" href="#_51、数据库的乐观锁和悲观锁是什么-怎么实现的" aria-hidden="true">#</a> 51、数据库的乐观锁和悲观锁是什么？怎么实现的？</h3><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。</p><p><strong>两种锁的使用场景</strong></p><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p><p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p><h2 id="_51、drop、delete与truncate的区别" tabindex="-1"><a class="header-anchor" href="#_51、drop、delete与truncate的区别" aria-hidden="true">#</a> 51、drop、delete与truncate的区别</h2><p><code>三者都是表示删除，但是三者都有一些差别：</code></p><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230207095219639.png" alt="image-20230207095219639" style="zoom:150%;"><p>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用 delete；在保留表而删除所有数据的时候用truncate。</p><h2 id="_52、union与unionall的区别" tabindex="-1"><a class="header-anchor" href="#_52、union与unionall的区别" aria-hidden="true">#</a> 52、UNION与UNIONALL的区别？</h2><blockquote><p>如果使用UNION ALL，不会合并重复的记录行 效率 UNION 高于 UNION ALL</p></blockquote><h2 id="_53、按照锁的粒度分数据库锁有哪些" tabindex="-1"><a class="header-anchor" href="#_53、按照锁的粒度分数据库锁有哪些" aria-hidden="true">#</a> 53、按照锁的粒度分数据库锁有哪些？</h2><blockquote><p>在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p><p>MyISAM和InnoDB存储引擎使用的锁：</p><p>MyISAM采用表级锁(table-level locking)。</p><p>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</p></blockquote><p><strong>行级锁，表级锁和页级锁对比</strong></p><ol><li>行级锁 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。 <ol><li>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li></ol></li><li>表级锁 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。 <ol><li>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</li></ol></li><li>页级锁 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。 <ol><li>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li></ol></li></ol><h2 id="_54、数据库中有六种触发器" tabindex="-1"><a class="header-anchor" href="#_54、数据库中有六种触发器" aria-hidden="true">#</a> 54、数据库中有六种触发器</h2><blockquote><ul><li>Before Insert</li><li>After Insert</li><li>Before Update</li><li>After Update</li><li>Before Delete</li><li>After Delete</li></ul></blockquote><h2 id="_55、hash索引和b-树索引有什么区别或者说优劣呢" tabindex="-1"><a class="header-anchor" href="#_55、hash索引和b-树索引有什么区别或者说优劣呢" aria-hidden="true">#</a> 55、Hash索引和B+树索引有什么区别或者说优劣呢?</h2><p>首先要知道Hash索引和B+树索引的底层实现原理:</p><p>hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.</p><p>那么可以看出他们有以下的不同:hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.</p><blockquote><p>因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.</p></blockquote><ol><li><p>hash索引不支持使用索引进行排序,原理同上.</p></li><li><p>hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测.AAAA和AAAAB的索引没有相关性.</p></li><li><p>hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.</p></li><li><p>hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.</p><p><strong>因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.</strong></p></li></ol><h1 id="七、ssm面试题" tabindex="-1"><a class="header-anchor" href="#七、ssm面试题" aria-hidden="true">#</a> 七、SSM面试题</h1><h2 id="spring" tabindex="-1"><a class="header-anchor" href="#spring" aria-hidden="true">#</a> Spring</h2><h3 id="_1、什么是spring" tabindex="-1"><a class="header-anchor" href="#_1、什么是spring" aria-hidden="true">#</a> 1、什么是Spring：</h3><p>Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯。</p><h3 id="_2、你们项目中为什么使用spring框架" tabindex="-1"><a class="header-anchor" href="#_2、你们项目中为什么使用spring框架" aria-hidden="true">#</a> 2、你们项目中为什么使用Spring框架？</h3><ul><li>轻量：Spring 是轻量的，基本的版本大约2MB。</li><li>控制反转：Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。</li><li>面向切面的编程(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</li><li>容器：Spring 包含并管理应用中对象的生命周期和配置。</li><li>MVC框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</li><li>事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务</li><li>异常处理：Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</li></ul><h3 id="_3、autowired和resource关键字的区别" tabindex="-1"><a class="header-anchor" href="#_3、autowired和resource关键字的区别" aria-hidden="true">#</a> 3、Autowired和Resource关键字的区别？</h3><p>Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><ol><li>共同点两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</li><li>不同点（1）@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</li><li>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。</li><li>（2）@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</li></ol><h3 id="_4、依赖注入的方式有几种-各是什么" tabindex="-1"><a class="header-anchor" href="#_4、依赖注入的方式有几种-各是什么" aria-hidden="true">#</a> 4、依赖注入的方式有几种，各是什么?</h3><ol><li>构造器注入 将被依赖对象通过构造函数的参数注入给依赖对象，并且在初始化对象的时候注入。优点： 对象初始化完成后便可获得可使用的对象。缺点： 当需要注入的对象很多时，构造器参数列表将会很长； 不够灵活。若有多种注入方式，每种方式只需注入指定几个依赖，那么就需要提供多个重载的构造函数，麻烦。</li><li>setter方法注入 IoC Service Provider通过调用成员变量提供的setter函数将被依赖对象注入给依赖类。优点： 灵活。可以选择性地注入需要的对象。缺点： 依赖对象初始化完成后由于尚未注入被依赖对象，因此还不能使用。</li><li>通过接口</li></ol><h3 id="_5、说说你对spring的ioc是怎么理解的" tabindex="-1"><a class="header-anchor" href="#_5、说说你对spring的ioc是怎么理解的" aria-hidden="true">#</a> 5、说说你对Spring的IOC是怎么理解的？</h3><ol><li>IOC就是控制反转，是指创建对象的控制权的转移。以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系。对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IoC容器来动态注入对象需要的外部资源。</li><li>最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</li><li>Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</li></ol><h3 id="_6、谈谈你对spring的aop理解" tabindex="-1"><a class="header-anchor" href="#_6、谈谈你对spring的aop理解" aria-hidden="true">#</a> 6、谈谈你对Spring的AOP理解</h3><ul><li>AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。</li><li>Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK动态代理去创建代理对象；而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGlib动态代理生成一个被代理对象的子类来作为代理。</li><li>当然也可以使用AspectJ，Spring AOP中已经集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整的AOP框架了。使用AOP之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样可以大大简化代码量。我们需要增加新功能也方便，提高了系统的扩展性。日志功能、事务管理和权限管理等场景都用到了AOP。</li></ul><h3 id="_7、spring-aop和aspectj-aop有什么区别" tabindex="-1"><a class="header-anchor" href="#_7、spring-aop和aspectj-aop有什么区别" aria-hidden="true">#</a> 7、Spring AOP和AspectJ AOP有什么区别？</h3><ul><li>Spring AOP是属于运行时增强，而AspectJ是编译时增强。</li><li>Spring AOP基于代理（Proxying），而AspectJ基于字节码操作（Bytecode Manipulation）。</li><li>Spring AOP已经集成了AspectJ，AspectJ应该算得上是Java生态系统中最完整的AOP框架了。</li><li>AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单。如果我们的切面比较少，那么两者性能差异不大。</li><li>但是，当切面太多的话，最好选择AspectJ，它比SpringAOP快很多。</li></ul><h3 id="_8、在spring-aop-中-关注点和横切关注的区别是什么" tabindex="-1"><a class="header-anchor" href="#_8、在spring-aop-中-关注点和横切关注的区别是什么" aria-hidden="true">#</a> 8、在Spring AOP 中，关注点和横切关注的区别是什么？</h3><ul><li>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。 横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。那什么是连接点呢？连接点代表一个应用程序的某个位置，在这个位置我们可以插入一个AOP切面，它实际上是个应用程序执行Spring AOP的位置。</li><li>切入点是什么？切入点是一个或一组连接点，通知将在这些位置执行。可以通过表达式或匹配的方式指明切入点。</li></ul><h3 id="_9、什么是通知呢-有哪些类型呢" tabindex="-1"><a class="header-anchor" href="#_9、什么是通知呢-有哪些类型呢" aria-hidden="true">#</a> 9、什么是通知呢？有哪些类型呢？</h3><p>通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。</p><p>Spring切面可以应用五种类型的通知：</p><ul><li>before：前置通知，在一个方法执行前被调用。</li><li>after: 在方法执行之后调用的通知，无论方法执行是否成功。</li><li>after-returning: 仅当方法成功完成后执行的通知。</li><li>after-throwing: 在方法抛出异常退出时执行的通知。</li><li>around: 在方法执行之前和之后调用的通知。</li></ul><h3 id="_10、解释一下spring-bean的生命周期" tabindex="-1"><a class="header-anchor" href="#_10、解释一下spring-bean的生命周期" aria-hidden="true">#</a> 10、解释一下spring bean的生命周期</h3><ul><li>Bean 容器找到配置文件中 Spring Bean 的定义。</li><li>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</li><li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li><li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li><li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li><li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li><li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><h3 id="_11、解释spring支持的几种bean的作用域" tabindex="-1"><a class="header-anchor" href="#_11、解释spring支持的几种bean的作用域" aria-hidden="true">#</a> 11、解释Spring支持的几种bean的作用域？</h3><ol><li>singleton：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。</li><li>prototype：每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li>request：每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li>session： 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li>global-session：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li></ol><h3 id="_12、静态代理和动态代理的区别" tabindex="-1"><a class="header-anchor" href="#_12、静态代理和动态代理的区别" aria-hidden="true">#</a> 12、<strong>静态代理和动态代理的区别</strong></h3><p>静态代理：只能代理一种业务，如果有多种业务需要编写多个代理类</p><p>动态代理：通过反射机制动态生成代理类，不需要手动编写，能够代理多种业务，更加灵活。</p><h3 id="_13、jdk动态代理和cglib动态代理的区别" tabindex="-1"><a class="header-anchor" href="#_13、jdk动态代理和cglib动态代理的区别" aria-hidden="true">#</a> 13、JDK动态代理和CGLIB动态代理的区别</h3><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：</p><ul><li>JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例, 生成目标类的代理对象。</li><li>如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。</li></ul><blockquote><p>静态代理与动态代理区别在于生成AOP代理对象的时机不同，相对来说AspectJ的静态代理方式具有更好的性能，但是AspectJ需要特定的编译器进行处理，而Spring AOP则无需特定的编译器处理。</p></blockquote><h3 id="_14、spring框架中都用到了哪些设计模式" tabindex="-1"><a class="header-anchor" href="#_14、spring框架中都用到了哪些设计模式" aria-hidden="true">#</a> 14、Spring框架中都用到了哪些设计模式？</h3><ol><li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配</li></ol><h3 id="_15、说说spring-中-applicationcontext-和-beanfactory-的区别" tabindex="-1"><a class="header-anchor" href="#_15、说说spring-中-applicationcontext-和-beanfactory-的区别" aria-hidden="true">#</a> 15、说说Spring 中 ApplicationContext 和 BeanFactory 的区别</h3><h3 id="_16、spring-框架中的单例-bean-是线程安全的么" tabindex="-1"><a class="header-anchor" href="#_16、spring-框架中的单例-bean-是线程安全的么" aria-hidden="true">#</a> 16、Spring 框架中的单例 Bean 是线程安全的么？</h3><p><strong>Spring 框架并没有对单例 Bean 进行任何多线程的封装处理。</strong></p><ol><li>关于单例 Bean 的线程安全和并发问题，需要开发者自行去搞定。</li><li>单例的线程安全问题，并不是 Spring 应该去关心的。Spring 应该做的是，提供根据配置，创建单例 Bean 或多例 Bean 的功能。</li></ol><blockquote><p>但实际上，大部分的 Spring Bean 并没有可变的状态，所以在某种程度上说 Spring 的单例Bean 是线程安全的。如果你的 Bean 有多种状态的话，就需要自行保证线程安全。最浅显的解决办法，就是将多态 Bean 的作用域（Scope）由 Singleton 变更为 Prototype。</p></blockquote><h3 id="_17、spring-是怎么解决循环依赖的" tabindex="-1"><a class="header-anchor" href="#_17、spring-是怎么解决循环依赖的" aria-hidden="true">#</a> 17、Spring 是怎么解决循环依赖的？</h3><p>循环依赖是指一个或多个Bean实例之间存在直接或间接的依赖关系，构成循环调用。通常表现为三种形态。互相依赖，也就是A依赖B，B依赖A</p><p>Spring设计了三级缓存来解决循环依赖问题。</p><ul><li>第一级缓存里面存储完整的Bean实例，这些实例是可以直接被使用的。</li><li>第二级缓存里面存储的是实例化以后，但是还没有设置属性值的Bean实例，也就是Bean里面的依赖注入还没有做。</li><li>第三级缓存用来存放Bean工厂，它主要用来生成原始Bean对象并且放到第二级缓存里面。三级缓存的核心思想，就是把Bean的实例化，和Bean里面的依赖注入进行分离。</li><li>采用一级缓存存储完整的Bean实例，采用二级缓存来存储不完整的Bean实例，通过不完整的Bean实例作为突破口，解决循环依赖的问题。至于第三级缓存，主要是解决代理对象的循环依赖问题</li></ul><h3 id="_18、spring-管理事务的方式有几种" tabindex="-1"><a class="header-anchor" href="#_18、spring-管理事务的方式有几种" aria-hidden="true">#</a> 18、Spring 管理事务的方式有几种？</h3><ol><li><strong>编程式事务</strong> ：在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li><li><strong>声明式事务</strong> ：在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li></ol><h3 id="_19、spring-事务中的隔离级别有哪几种" tabindex="-1"><a class="header-anchor" href="#_19、spring-事务中的隔离级别有哪几种" aria-hidden="true">#</a> 19、Spring 事务中的隔离级别有哪几种?</h3><ul><li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li><li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li><li><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li><li><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别</li></ul><h2 id="springmvc" tabindex="-1"><a class="header-anchor" href="#springmvc" aria-hidden="true">#</a> SpringMVC</h2><h3 id="_1、springmvc的执行流程" tabindex="-1"><a class="header-anchor" href="#_1、springmvc的执行流程" aria-hidden="true">#</a> 1、SpringMVC的执行流程</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230209083915471.png" alt="image-20230209083915471" tabindex="0" loading="lazy"><figcaption>image-20230209083915471</figcaption></figure><ol><li>用户发送请求给前端控制器</li><li>前端控制器将请求的URL发送给处理器映射</li><li>处理器映射将请求里面的handler（包装的信息和方法）返回给前端控制器</li><li>前端控制器发送handler给适配器，适配器执行handler里的方法</li><li>适配器执行完毕后返回逻辑视图给前端控制器</li><li>前端控制器再将逻辑视图发送给视图解析器，解析成物理视图返回给前端控制器</li><li>前端控制器渲染视图，发送视图给用户</li></ol><h3 id="_2、springmvc中的拦截器和servlet中的filter过滤器的区别" tabindex="-1"><a class="header-anchor" href="#_2、springmvc中的拦截器和servlet中的filter过滤器的区别" aria-hidden="true">#</a> 2、SpringMVC中的拦截器和Servlet中的Filter过滤器的区别？</h3><p>拦截器：用于过滤请求，只能在SpringMVC中使用，效率高</p><p>过滤器：拦截范围更大</p><h3 id="_3、什么是spring-mvc-简单介绍下你对spring-mvc的理解" tabindex="-1"><a class="header-anchor" href="#_3、什么是spring-mvc-简单介绍下你对spring-mvc的理解" aria-hidden="true">#</a> 3、什么是Spring MVC？简单介绍下你对Spring MVC的理解？</h3><blockquote><p>首先，SpringMVC是是属于SpringFramework生态里面的一个模块，它是在Servlet基础上构建并且使用MVC模式设计的一个Web框架，主要的目的是简化传统Servlet+JSP模式下的Web开发方式。其次，SpringMVC的整体架构设计对JavaWeb里面的MVC架构模式做了增强和扩展，主要有几个方面。把传统MVC框架里面的Controller控制器做了拆分，分成了前端控制器DispatcherServlet和后端控制器Controller。把Model模型拆分成业务层Service和数据访问层Repository。在视图层，可以支持不同的视图，比如Freemark、velocity、JSP等等。所以，SpringMVC天生就是为了MVC模式而设计的，因此在开发MVC应用的时候会更加方便和灵活。SpringMVC的具体工作流程是，浏览器的请求首先会经过SpringMVC里面的核心控制器DispatcherServlet，它负责对请求进行分发到对应的Controller。Controller里面处理完业务逻辑之后，返回ModeAndView。然后DispatcherServlet寻找一个或者多个ViewResolver视图解析器，找到ModeAndView指定的视图，并把数据显示到客户端。</p></blockquote><h3 id="_4、spring-mvc的控制器是不是单例模式-如果是-有什么问题-怎么解决" tabindex="-1"><a class="header-anchor" href="#_4、spring-mvc的控制器是不是单例模式-如果是-有什么问题-怎么解决" aria-hidden="true">#</a> 4、Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？</h3><p>答：是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。</p><h3 id="_5、mvc是什么-mvc设计模式的好处有哪些" tabindex="-1"><a class="header-anchor" href="#_5、mvc是什么-mvc设计模式的好处有哪些" aria-hidden="true">#</a> 5、MVC是什么？MVC设计模式的好处有哪些</h3><p>mvc是一种设计模式（设计模式就是日常开发中编写代码的一种好的方法和经验的总结）。模型（model）-视图（view）-控制器（controller），三层架构的设计模式。用于实现前端页面的展现与后端业务数据处理的分离。</p><p><strong>mvc设计模式的好处</strong></p><ol><li>分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。</li><li>有利于系统的并行开发，提升开发效率。</li></ol><h3 id="_6、spring-mvc常用的注解有哪些" tabindex="-1"><a class="header-anchor" href="#_6、spring-mvc常用的注解有哪些" aria-hidden="true">#</a> 6、Spring MVC常用的注解有哪些？</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230212224145023.png" alt="image-20230212224145023" tabindex="0" loading="lazy"><figcaption>image-20230212224145023</figcaption></figure><h3 id="_7、spring-mvc怎么样设定重定向和转发的" tabindex="-1"><a class="header-anchor" href="#_7、spring-mvc怎么样设定重定向和转发的" aria-hidden="true">#</a> 7、Spring MVC怎么样设定重定向和转发的？</h3><ol><li>转发：在返回值前面加&quot;forward:&quot;，譬如&quot;forward:user.do?name=method4&quot;</li><li>重定向：在返回值前面加&quot;redirect:&quot;，如&quot;redirect:<a href="http://www.baidu.com" target="_blank" rel="noopener noreferrer">http://www.baidu.com<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>&quot;</li></ol><h2 id="mybatis" tabindex="-1"><a class="header-anchor" href="#mybatis" aria-hidden="true">#</a> MyBatis</h2><h3 id="_1、介绍一下mybatis" tabindex="-1"><a class="header-anchor" href="#_1、介绍一下mybatis" aria-hidden="true">#</a> 1、介绍一下MyBatis：</h3><p>MyBatis 是一款优秀的持久层框架，一个半 ORM（对象关系映射）框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><h3 id="_2、orm是什么" tabindex="-1"><a class="header-anchor" href="#_2、orm是什么" aria-hidden="true">#</a> 2、ORM是什么</h3><p>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p><h3 id="_3、为什么说mybatis是半自动orm映射工具-它与全自动的区别在哪里" tabindex="-1"><a class="header-anchor" href="#_3、为什么说mybatis是半自动orm映射工具-它与全自动的区别在哪里" aria-hidden="true">#</a> 3、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</p><p>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><h3 id="_4、传统jdbc开发存在的问题" tabindex="-1"><a class="header-anchor" href="#_4、传统jdbc开发存在的问题" aria-hidden="true">#</a> 4、传统JDBC开发存在的问题</h3><ul><li>频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池解决这个问题。但是使用jdbc需要自己实现连接池。</li><li>sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大，一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。</li><li>使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。</li><li>结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便</li></ul><h3 id="_5、jdbc编程有哪些不足之处-mybatis是如何解决这些问题的" tabindex="-1"><a class="header-anchor" href="#_5、jdbc编程有哪些不足之处-mybatis是如何解决这些问题的" aria-hidden="true">#</a> 5、JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h3><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230212221427378.png" alt="image-20230212221427378" tabindex="0" loading="lazy"><figcaption>image-20230212221427378</figcaption></figure><h3 id="_6、mybatis优缺点" tabindex="-1"><a class="header-anchor" href="#_6、mybatis优缺点" aria-hidden="true">#</a> 6、Mybatis优缺点</h3><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230212221513223.png"><h3 id="_7、hibernate-和-mybatis-的区别" tabindex="-1"><a class="header-anchor" href="#_7、hibernate-和-mybatis-的区别" aria-hidden="true">#</a> 7、Hibernate 和 MyBatis 的区别</h3><p><strong>相同点</strong></p><p>都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。</p><p><strong>不同点</strong></p><p>映射关系</p><ul><li>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单</li><li>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂</li></ul><p><strong>SQL优化和移植性</strong></p><ul><li>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。</li><li>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。</li></ul><p><strong>开发难易程度和学习成本</strong></p><ul><li>Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如：办公自动化系统</li><li>MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互联网电子商务系统</li></ul><p><strong>总结</strong></p><ul><li>MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，</li><li>Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。</li></ul><h3 id="_8、mybatis编程步骤是什么样的" tabindex="-1"><a class="header-anchor" href="#_8、mybatis编程步骤是什么样的" aria-hidden="true">#</a> 8、MyBatis编程步骤是什么样的？</h3><p>1、 创建SqlSessionFactory</p><p>2、 通过SqlSessionFactory创建SqlSession</p><p>3、 通过sqlsession执行数据库操作</p><p>4、 调用session.commit()提交事务</p><p>5、 调用session.close()关闭会话</p><h3 id="_9、请说说mybatis的工作原理" tabindex="-1"><a class="header-anchor" href="#_9、请说说mybatis的工作原理" aria-hidden="true">#</a> 9、请说说MyBatis的工作原理</h3><ol><li>读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</li><li>加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</li><li>造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</li><li>创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</li><li>Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</li><li>MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</li><li>输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。</li><li>输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</li></ol><h3 id="_10、mybatis都有哪些executor执行器-它们之间的区别是什么" tabindex="-1"><a class="header-anchor" href="#_10、mybatis都有哪些executor执行器-它们之间的区别是什么" aria-hidden="true">#</a> 10、Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h3><ul><li>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。 <ul><li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li><li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</li><li>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li></ul></li></ul><p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p><h3 id="_11、mybatis是否支持延迟加载-如果支持-它的实现原理是什么" tabindex="-1"><a class="header-anchor" href="#_11、mybatis是否支持延迟加载-如果支持-它的实现原理是什么" aria-hidden="true">#</a> 11、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h3><blockquote><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p></blockquote><h3 id="_12、mybatis-和-的区别" tabindex="-1"><a class="header-anchor" href="#_12、mybatis-和-的区别" aria-hidden="true">#</a> 12、MyBatis#{}和${}的区别</h3><ul><li>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</li><li>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</li><li>Mybatis在处理时 ， 是 原 值 传 入 ， 就 是 把 {}时，是原值传入，就是把时，是原值传入，就是把{}替换成变量的值，相当于JDBC中的Statement编译。</li><li>变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上单引号 ‘’</li><li>#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</li><li>#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</li></ul><h3 id="_13、mybatis如何获取生成的主键" tabindex="-1"><a class="header-anchor" href="#_13、mybatis如何获取生成的主键" aria-hidden="true">#</a> 13、MyBatis如何获取生成的主键</h3><p><strong>对于支持主键自增的数据库（MySQL）</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230212223456678.png" alt="image-20230212223456678" tabindex="0" loading="lazy"><figcaption>image-20230212223456678</figcaption></figure><h3 id="_14、使用mybatis的mapper接口调用时有哪些要求" tabindex="-1"><a class="header-anchor" href="#_14、使用mybatis的mapper接口调用时有哪些要求" aria-hidden="true">#</a> 14、使用MyBatis的mapper接口调用时有哪些要求？</h3><ol><li>Mapper接口方法名和mapper.xml中定义的每个sql的id相同。</li><li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同。</li><li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同。</li><li>Mapper.xml文件中的namespace即是mapper接口的类路径。</li></ol><h3 id="_16、mybatis实现一对一-一对多有几种方式-怎么操作的" tabindex="-1"><a class="header-anchor" href="#_16、mybatis实现一对一-一对多有几种方式-怎么操作的" aria-hidden="true">#</a> 16、MyBatis实现一对一，一对多有几种方式，怎么操作的？</h3><blockquote><p>有联合查询和嵌套查询。联合查询是几个表联合查询，只查询一次，通过在resultMap里面的association，collection节点配置一对一，一对多的类就可以完成</p><p>嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，也是通过配置association，collection，但另外一个表的查询通过select节点配置。</p></blockquote><h3 id="_17、mybatis动态sql是做什么的-都有哪些动态sql-能简述一下动态sql的执行原理不" tabindex="-1"><a class="header-anchor" href="#_17、mybatis动态sql是做什么的-都有哪些动态sql-能简述一下动态sql的执行原理不" aria-hidden="true">#</a> 17、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h3><blockquote><p>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。</p><p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p></blockquote><h3 id="_18、mybatis是如何进行分页的-分页插件的原理是什么" tabindex="-1"><a class="header-anchor" href="#_18、mybatis是如何进行分页的-分页插件的原理是什么" aria-hidden="true">#</a> 18、Mybatis是如何进行分页的？分页插件的原理是什么？</h3><blockquote><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。<br> 举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</p></blockquote><h3 id="_19、mybatis的一级、二级缓存" tabindex="-1"><a class="header-anchor" href="#_19、mybatis的一级、二级缓存" aria-hidden="true">#</a> 19、Mybatis的一级、二级缓存</h3><ol><li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</li><li>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<!----> ；</li><li>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</li></ol><h2 id="ssm" tabindex="-1"><a class="header-anchor" href="#ssm" aria-hidden="true">#</a> SSM</h2><h3 id="_1、ssm分工" tabindex="-1"><a class="header-anchor" href="#_1、ssm分工" aria-hidden="true">#</a> 1、SSM分工：</h3><p>（1）Spring 作为基础框架，整合其他框架</p><p>（2）SpringMVC 作为Web开发框架，提供服务期开发支持</p><p>（3）MyBatis 作为ORM框架，提供数据库开发支持</p><h1 id="八、springboot面试题" tabindex="-1"><a class="header-anchor" href="#八、springboot面试题" aria-hidden="true">#</a> 八、SpringBoot面试题</h1><h2 id="_1、什么是springboot" tabindex="-1"><a class="header-anchor" href="#_1、什么是springboot" aria-hidden="true">#</a> 1、什么是SpringBoot</h2><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p><h2 id="_2、spring-boot-有哪些优点" tabindex="-1"><a class="header-anchor" href="#_2、spring-boot-有哪些优点" aria-hidden="true">#</a> 2、Spring Boot 有哪些优点？</h2><ol><li>容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。</li><li>开箱即用，远离繁琐的配置。</li><li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li><li>没有代码生成，也不需要XML配置。</li><li>避免大量的 Maven 导入和各种版本冲突。</li></ol><h2 id="_3、spring-boot-的核心注解是哪个-它主要由哪几个注解组成的" tabindex="-1"><a class="header-anchor" href="#_3、spring-boot-的核心注解是哪个-它主要由哪几个注解组成的" aria-hidden="true">#</a> 3、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h2><blockquote><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p><p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</p><p>@ComponentScan：Spring组件扫描。</p></blockquote><h2 id="_4、spring-boot-自动配置原理是什么" tabindex="-1"><a class="header-anchor" href="#_4、spring-boot-自动配置原理是什么" aria-hidden="true">#</a> 4、Spring Boot 自动配置原理是什么？</h2><ul><li><p>自动装配，简单来说就是自动把第三方组件的Bean装载到SpringIOC器里面，不需要开发人员再去写Bean的装配配置。</p></li><li><p>在SpringBoot应用里面，只需要在启动类加上@SpringBootApplication注解就可以实现自动装配。</p></li><li><p>@SpringBootApplication是一个复合注解，真正实现自动装配的注解是@EnableAutoConfiguration。</p><p><strong>自动装配的实现主要依靠三个核心关键技术。</strong></p></li><li><p>引入Starter启动依赖组件的时候，这个组件里面必须要包含@Configuration配置类，在这个配置类里面通过@Bean注解声明需要装配到IOC容器的Bean对象。</p></li><li><p>这个配置类是放在第三方的jar包里面，然后通过SpringBoot中的约定优于配置思想，把这个配置类的全路径放在classpath:/META-INF/spring.factories文件中。这样SpringBoot就可以知道第三方jar包里面的配置类的位置，这个步骤主要是用到了Spring里面的SpringFactoriesLoader来完成的。</p></li><li><p>SpringBoot拿到所第三方jar包里面声明的配置类以后，再通过Spring提供的ImportSelector接口，实现对这些配置类的动态加载。</p></li><li><p>在我看来，SpringBoot是约定优于配置这一理念下的产物，所以在很多的地方，都会看到这类的思想。它的出现，让开发人员更加聚焦在了业务代码的编写上，而不需要去关心和业务无关的配置。</p></li><li><p>其实，自动装配的思想，在SpringFramework3.x版本里面的@Enable注解，就有了实现的雏形。@Enable注解是模块驱动的意思，我们只需要增加某个@Enable注解，就自动打开某个功能，而不需要针对这个功能去做Bean的配置，@Enable底层也是帮我们去自动完成这个模块相关Bean的注入。以上，就是我对SpringBoot自动装配机制的理解。</p></li></ul><h2 id="_5、spring-boot-配置加载顺序详解" tabindex="-1"><a class="header-anchor" href="#_5、spring-boot-配置加载顺序详解" aria-hidden="true">#</a> 5、Spring Boot 配置加载顺序详解</h2><p>1、properties文件；</p><p>2、YAML文件；</p><p>3、系统环境变量；</p><p>4、命令行参数；</p><h2 id="_6、yaml-配置的优势在哪里" tabindex="-1"><a class="header-anchor" href="#_6、yaml-配置的优势在哪里" aria-hidden="true">#</a> 6、YAML 配置的优势在哪里 ?</h2><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p><ol><li>配置有序，在一些特殊的场景下，配置有序很关键</li><li>支持数组，数组中的元素可以是基本数据类型也可以是对象</li><li>简洁</li></ol><h2 id="_7、spring-boot-中如何解决跨域问题" tabindex="-1"><a class="header-anchor" href="#_7、spring-boot-中如何解决跨域问题" aria-hidden="true">#</a> 7、Spring Boot 中如何解决跨域问题 ?</h2><blockquote><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p></blockquote><h2 id="_8、springboot打成的jar和普通的jar有什么区别" tabindex="-1"><a class="header-anchor" href="#_8、springboot打成的jar和普通的jar有什么区别" aria-hidden="true">#</a> 8、SpringBoot打成的jar和普通的jar有什么区别?</h2><p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，</p><p>这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p><p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直、接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOT-INF\classes目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p><h2 id="_9、什么是yaml" tabindex="-1"><a class="header-anchor" href="#_9、什么是yaml" aria-hidden="true">#</a> 9、什么是YAML？</h2><p>YAML是一种人类可读的数据序列化语言。它通常用于配置文件。 与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML文件就更加结构化，而且更少混淆。可以看出YAML具有分层配置数据。</p><h2 id="_10、spring-boot、spring-mvc-和-spring-有什么区别" tabindex="-1"><a class="header-anchor" href="#_10、spring-boot、spring-mvc-和-spring-有什么区别" aria-hidden="true">#</a> 10、Spring Boot、Spring MVC 和 Spring 有什么区别？</h2><table><thead><tr><th><strong>Spring</strong></th><th>Spring最重要的特征是依赖注入。所有 SpringModules 不是依赖注入就是 IOC 控制反转。当我们恰当的使用 DI 或者是 IOC 的时候，我们可以开发松耦合应用。松耦合应用的单元测试可以很容易的进行。</th></tr></thead><tbody><tr><td><strong>Spring MVC</strong></td><td>Spring MVC 提供了一种分离式的方法来开发 Web 应用。通过运用像 DispatcherServelet，MoudlAndView 和 ViewResolver 等一些简单的概念，开发 Web 应用将会变的非常简单。</td></tr><tr><td><strong>SpringBoot</strong></td><td>Spring 和 SpringMVC 的问题在于需要配置大量的参数。</td></tr></tbody></table><h2 id="_11、spring-boot-中如何解决跨域问题" tabindex="-1"><a class="header-anchor" href="#_11、spring-boot-中如何解决跨域问题" aria-hidden="true">#</a> 11、Spring Boot 中如何解决跨域问题 ?</h2><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resourcesharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现</p><p>WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p><h3 id="_12、什么是-csrf-攻击" tabindex="-1"><a class="header-anchor" href="#_12、什么是-csrf-攻击" aria-hidden="true">#</a> 12、什么是 CSRF 攻击？</h3><blockquote><p>CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</p></blockquote><h2 id="_14、springboot支持哪些日志框架-推荐和默认的日志框架是哪个" tabindex="-1"><a class="header-anchor" href="#_14、springboot支持哪些日志框架-推荐和默认的日志框架是哪个" aria-hidden="true">#</a> 14、SpringBoot支持哪些日志框架？推荐和默认的日志框架是哪个？</h2><blockquote><p>Spring Boot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，如果你使用 Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架，但是不管是那种日志框架他都支持将配置文件输出到控制台或者文件中。</p></blockquote><h2 id="_15、springboot-starter的工作原理" tabindex="-1"><a class="header-anchor" href="#_15、springboot-starter的工作原理" aria-hidden="true">#</a> 15、SpringBoot Starter的工作原理</h2><blockquote><p>我个人理解SpringBoot就是由各种Starter组合起来的，我们自己也可以开发Starter在sprinBoot启动时由@SpringBootApplication注解会自动去maven中读取每个starter中的spring.factories文件,该文件里配置了所有需要被创建spring容器中的bean，并且进行自动配置把bean注入SpringContext中 //（SpringContext是Spring的配置文件）</p></blockquote><h2 id="_16、springboot多数据源事务如何管理" tabindex="-1"><a class="header-anchor" href="#_16、springboot多数据源事务如何管理" aria-hidden="true">#</a> 16、SpringBoot多数据源事务如何管理</h2><ul><li>第一种方式是在service层的@TransactionManager中使用transactionManager指定DataSourceConfig中配置的事务</li><li>第二种是使用jta-atomikos实现分布式事务管理</li></ul><h2 id="_17、springboot中如何实现定时任务" tabindex="-1"><a class="header-anchor" href="#_17、springboot中如何实现定时任务" aria-hidden="true">#</a> 17、SpringBoot中如何实现定时任务 ?</h2><ul><li>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一-个则是使用第三方框架 Quartz。</li><li>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</li></ul><h2 id="_18、spring-boot-starter-parent有什么用" tabindex="-1"><a class="header-anchor" href="#_18、spring-boot-starter-parent有什么用" aria-hidden="true">#</a> 18、spring-boot-starter-parent有什么用?</h2><blockquote><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 springboot-starter-parent ，spring-boot-starter-parent 主要有如下作用：1. 定义了 Java 编译版本为 1.8 。2. 使用 UTF-8 格式编码。3. 继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。4. 执行打包操作的配置。5. 自动化的资源过滤。6. 自动化的插件配置。7. 针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</p></blockquote><h1 id="九、springcloud微服务面试题" tabindex="-1"><a class="header-anchor" href="#九、springcloud微服务面试题" aria-hidden="true">#</a> 九、SpringCloud微服务面试题</h1><h2 id="_1、什么是springcloud" tabindex="-1"><a class="header-anchor" href="#_1、什么是springcloud" aria-hidden="true">#</a> 1、什么是SpringCloud</h2><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><h2 id="_2、互联网架构演进" tabindex="-1"><a class="header-anchor" href="#_2、互联网架构演进" aria-hidden="true">#</a> 2、互联网架构演进</h2><h3 id="_1、单体应用架构" tabindex="-1"><a class="header-anchor" href="#_1、单体应用架构" aria-hidden="true">#</a> 1、<strong>单体应用架构</strong></h3><p>项目所有功能模块放在一个工程中编码、编译、打包部署在一个tomcat容器中。</p><p>简单实用、便于维护、成本低。</p><p>**优点：**高效开发、架构简单、易于测试、易于部署。</p><p>**缺点：**可靠性差、复杂性高、扩展能力受限。</p><h3 id="_2、垂直应用架构" tabindex="-1"><a class="header-anchor" href="#_2、垂直应用架构" aria-hidden="true">#</a> 2、<strong>垂直应用架构</strong></h3><p>为了业务之间互不影响，提高效率、减少组件之间的依赖。</p><p><strong>优点</strong>：流量分担解决并发问题；</p><p>可以针对不同模块进行优化；</p><p>方便水平扩展、负载均衡、容错率高；</p><p>系统间相互独立，互不影响，业务迭代更高效。</p><p>**缺点：**服务之间相互调用，端口发生改变得手动改变；</p><p>搭建集群之后，实现负载均衡比较复杂；</p><p>服务之间调用方式不统一；</p><p>服务监控不到位。</p><h3 id="_3、soa应用架构" tabindex="-1"><a class="header-anchor" href="#_3、soa应用架构" aria-hidden="true">#</a> 3、<strong>SOA应用架构</strong></h3><p>Dubbo 高性能、轻量级的开源java RPC框架，可以和Spring框架无缝集成。</p><p><strong>核心功能：面向接口的远程方法调用；</strong></p><p>​ <strong>智能容错和负载均衡；</strong></p><p>​ <strong>服务自动注册和发现。</strong></p><p>**优点：**分布式、松耦合、扩展灵活、可重用。</p><p><strong>缺点</strong>：服务抽取力度较大，服务调用方和提供耦合度较高。</p><h3 id="_4、微服务应用架构" tabindex="-1"><a class="header-anchor" href="#_4、微服务应用架构" aria-hidden="true">#</a> 4、<strong>微服务应用架构</strong></h3><p>拆分粒度更小，服务更独立。<strong>微小、独立、轻量级通信。</strong></p><p><strong>重点</strong>：业务需要彻底组件化服务化。</p><p><strong>优点：</strong></p><p>微小，便于特定服务的聚焦，解耦、便于实施敏捷开发。</p><p>便于重用和模块之间的组装</p><p>独立，松耦合，不同的微服务可以使用不同的语言开发。</p><p>更容易引进新的技术。</p><p><strong>缺点：</strong></p><p>分布式复杂难以管理。</p><p>分布式链路跟踪难。</p><h2 id="_3、什么是服务注册与服务发现。" tabindex="-1"><a class="header-anchor" href="#_3、什么是服务注册与服务发现。" aria-hidden="true">#</a> 3、什么是服务注册与服务发现。</h2><p>服务注册：提供者将所提供服务的信息（服务器IP和端口、访问协议）</p><p>服务发现：消费者从中获取到服务列表。</p><p>Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。</p><h2 id="_4、springboot和springcloud的区别" tabindex="-1"><a class="header-anchor" href="#_4、springboot和springcloud的区别" aria-hidden="true">#</a> 4、SpringBoot和SpringCloud的区别？</h2><ul><li>SpringBoot专注于快速方便的开发单个个体微服务。</li><li>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，</li><li>为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</li><li>SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系</li><li>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。</li></ul><h2 id="_5、spring-cloud的优缺点有哪些" tabindex="-1"><a class="header-anchor" href="#_5、spring-cloud的优缺点有哪些" aria-hidden="true">#</a> 5、Spring Cloud的优缺点有哪些？</h2><blockquote><p><strong>优点：</strong></p><ol><li>服务拆分粒度更细，有利于资源重复利用，有利于提高开发效率</li><li>可以更精准的制定优化服务方案，提高系统的可维护性</li><li>微服务架构采用去中心化思想，服务之间采用Restful等轻量级通讯，比ESB更轻量</li><li>适于互联网时代，产品迭代周期更短</li></ol><p><strong>缺点：</strong></p><ol><li>微服务过多，治理成本高，不利于维护系统</li><li>分布式系统开发的成本高（容错，分布式事务等）对团队挑战大</li></ol><p>总的来说优点大过于缺点，目前看来SpringCloud是一套非常完善的分布式框架，目前很多企业开始用微服务、Spring Cloud的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习 Spring Cloud 是一个不错的选择。</p></blockquote><h2 id="_6、eureka的服务治理是什么" tabindex="-1"><a class="header-anchor" href="#_6、eureka的服务治理是什么" aria-hidden="true">#</a> 6、Eureka的服务治理是什么？</h2><p>Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理。</p><p>在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。</p><h2 id="_7、eureka的服务注册是什么" tabindex="-1"><a class="header-anchor" href="#_7、eureka的服务注册是什么" aria-hidden="true">#</a> 7、Eureka的服务注册是什么？</h2><blockquote><p>Eureka采用了CS的设计架构，Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。</p></blockquote><blockquote><p>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址))</p></blockquote><h2 id="_8、什么是spring-cloud-ribbon" tabindex="-1"><a class="header-anchor" href="#_8、什么是spring-cloud-ribbon" aria-hidden="true">#</a> 8、什么是Spring Cloud Ribbon？</h2><blockquote><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套<strong>客户端负载均衡</strong>的工具。简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。</p></blockquote><h2 id="_9、nginx和ribbon的区别" tabindex="-1"><a class="header-anchor" href="#_9、nginx和ribbon的区别" aria-hidden="true">#</a> 9、Nginx和Ribbon的区别</h2><blockquote><p>Nginx是反向代理同时可以实现负载均衡，nginx拦截客户端请求采用负载均衡策略根据upstream配置进行转发，相当于请求通过nginx服务器进行转发。Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作</p></blockquote><h2 id="_10、ribbon支持的负载均衡算法" tabindex="-1"><a class="header-anchor" href="#_10、ribbon支持的负载均衡算法" aria-hidden="true">#</a> 10、<strong>Ribbon支持的负载均衡算法</strong></h2><ol><li>轮询策略</li><li>随机策略</li><li>重试策略</li><li>最小连接数策略</li><li>可用过略策略</li><li>区域权衡策略</li></ol><h2 id="_11、服务器雪崩" tabindex="-1"><a class="header-anchor" href="#_11、服务器雪崩" aria-hidden="true">#</a> 11、服务器雪崩</h2><p>一种因“服务提供者不可用”导致“服务调用这不可用”，并将不可用逐渐扩大的现象。</p><p><strong>形成原因：</strong></p><p>（1）服务提供者不可用（硬件故障、程序bug、缓存击穿、用户大量请求）</p><p>（2）重试加大请求流量（用户重试、代码逻辑重试）</p><p>（3）服务调者不可用（同步等待造成的资源耗尽）</p><p><strong>解决方案：</strong></p><p>（1）服务器熔断</p><p>（2）服务降级</p><p>（3）服务限流</p><h2 id="_12、hystrix熔断器" tabindex="-1"><a class="header-anchor" href="#_12、hystrix熔断器" aria-hidden="true">#</a> 12、Hystrix熔断器</h2><p>一个延迟和容错库，用于隔离访问远程系统、服务或者第三方库，防止级联失败，提升系统的可用性与容错性。</p><ol><li>包裹请求</li><li>跳闸机制</li><li>资源隔离</li><li>监控</li><li>回退机制</li><li>自我修复</li></ol><h3 id="_13、feign" tabindex="-1"><a class="header-anchor" href="#_13、feign" aria-hidden="true">#</a> 13、<strong>Feign</strong></h3><p>轻量级HTTP服务客户端（发送请求、远程调用）。</p><p>本质：封装了Http调用流程，更符合面向接口化的编程习惯，类似于Dubbo的服务调用。</p><p><strong>对熔断的支持：</strong></p><p>客户端工程配置文件中开启支持，超时时长设置。</p><p>（1）开启Hystrix后，Feign中的方法进行一个管理，一旦出问题就进入对应的回退逻辑处理。</p><p>（2）当有两个超时时间设置，熔断的时候根据两个时间的最小值进行。</p><h2 id="_14、gateway的作用" tabindex="-1"><a class="header-anchor" href="#_14、gateway的作用" aria-hidden="true">#</a> 14、Gateway的作用</h2><p>网关的作用是负载均衡、路由转发、请求过虑等。项目中网关与Nginx配合使用</p><h2 id="_15、gateway的工作流程" tabindex="-1"><a class="header-anchor" href="#_15、gateway的工作流程" aria-hidden="true">#</a> 15、<strong>Gateway的工作流程</strong></h2><figure><img src="https://edu--learn.oss-cn-beijing.aliyuncs.com/weixin/图片3.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="_16、gateway的路由规则" tabindex="-1"><a class="header-anchor" href="#_16、gateway的路由规则" aria-hidden="true">#</a> 16、Gateway的路由规则</h2><figure><img src="https://edu--learn.oss-cn-beijing.aliyuncs.com/weixin/图片4.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="_17、gateway的过滤使用" tabindex="-1"><a class="header-anchor" href="#_17、gateway的过滤使用" aria-hidden="true">#</a> 17、Gateway的过滤使用</h2><figure><img src="https://edu--learn.oss-cn-beijing.aliyuncs.com/weixin/图片5.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><figure><img src="https://edu--learn.oss-cn-beijing.aliyuncs.com/weixin/图片6.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>GlobalFilter全局过滤器是程序员使用比较多的过滤器，可以在过滤器中完成鉴权、流量控制、IP黑白名单、权限控制、日志监控等。</p><h2 id="_18、什么是spring-cloud-alibaba" tabindex="-1"><a class="header-anchor" href="#_18、什么是spring-cloud-alibaba" aria-hidden="true">#</a> 18、什么是Spring Cloud Alibaba?</h2><blockquote><p>Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p></blockquote><h2 id="_19、spring-cloud-alibaba有哪些功能" tabindex="-1"><a class="header-anchor" href="#_19、spring-cloud-alibaba有哪些功能" aria-hidden="true">#</a> 19、Spring Cloud Alibaba有哪些功能？</h2><blockquote><ul><li><strong>服务限流降级</strong>：默认支持 WebServlet、WebFlux, OpenFeign、RestTemplate、Spring Cloud Gateway, Zuul, Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li><li><strong>服务注册与发现</strong>：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li><li><strong>分布式配置管理</strong>：支持分布式系统中的外部化配置，配置更改时自动刷新。</li><li><strong>消息驱动能力</strong>：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li><li><strong>分布式事务</strong>：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。</li><li><strong>阿里云对象存储</strong>：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li><strong>分布式任务调度</strong>：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li><li><strong>阿里云短信服务</strong>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ul></blockquote><h2 id="_20、spring-cloud-alibaba的常用组件有哪些" tabindex="-1"><a class="header-anchor" href="#_20、spring-cloud-alibaba的常用组件有哪些" aria-hidden="true">#</a> 20、Spring Cloud Alibaba的常用组件有哪些？</h2><blockquote><p><strong><a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener noreferrer">Sentinel (opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></strong>：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><p><strong><a href="https://github.com/alibaba/Nacos" target="_blank" rel="noopener noreferrer">Nacos (opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></strong>：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p><p><strong><a href="https://rocketmq.apache.org/" target="_blank" rel="noopener noreferrer">RocketMQ (opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></strong>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</p><p><strong><a href="https://github.com/apache/dubbo" target="_blank" rel="noopener noreferrer">Dubbo (opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></strong>：Apache Dubbo™ 是一款高性能 Java RPC 框架。</p><p><strong><a href="https://github.com/seata/seata" target="_blank" rel="noopener noreferrer">Seata (opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></strong>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</p><p><strong><a href="https://www.aliyun.com/product/oss" target="_blank" rel="noopener noreferrer">Alibaba Cloud OSS (opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></strong>: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</p><p><strong><a href="https://help.aliyun.com/document_detail/43136.html" target="_blank" rel="noopener noreferrer">Alibaba Cloud SchedulerX (opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></strong>: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</p><p><strong><a href="https://www.aliyun.com/product/sms" target="_blank" rel="noopener noreferrer">Alibaba Cloud SMS (opens new window)<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></strong>: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</p></blockquote><h2 id="_21、什么是nacos" tabindex="-1"><a class="header-anchor" href="#_21、什么是nacos" aria-hidden="true">#</a> 21、什么是Nacos？</h2><blockquote><p>前面组件中也有简单介绍；Nacos命名的由来：前四个字母分别是Naming和Configuration的前两个字母，后面的s是Service</p><p>Nacos是一个易于使用的动态服务发现，配置和服务管理平台，用于构建云本机应用程序。使用Spring Cloud Alibaba Nacos Discovery，您可以基于Spring Cloud的编程模型快速访问Nacos服务注册功能。</p><p><code>Nacos</code>就是注册中心+配置中心的组合</p></blockquote><h2 id="_22、nacos有什么作用" tabindex="-1"><a class="header-anchor" href="#_22、nacos有什么作用" aria-hidden="true">#</a> 22、Nacos有什么作用？</h2><blockquote><ul><li>替代<code>Eureka</code>做服务注册</li><li>替代<code>Config</code>做配置中心</li></ul><ol><li><strong>服务发现与服务健康检查</strong> Nacos使服务更容易注册，并通过DNS或HTTP接口发现其他服务，Nacos还提供服务的实时健康检查，以防 止向不健康的主机或服务实例发送请求。</li><li><strong>动态配置管理</strong> 动态配置服务允许您在所有环境中以集中和动态的方式管理所有服务的配置。Nacos消除了在更新配置时重新 部署应用程序，这使配置的更改更加高效和灵活。</li><li><strong>动态DNS服务</strong> Nacos提供基于DNS 协议的服务发现能力，旨在支持异构语言的服务发现，支持将注册在Nacos上的服务以 域名的方式暴露端点，让三方应用方便的查阅及发现。</li><li><strong>服务和元数据管理</strong> Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周 期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略。</li></ol></blockquote><h2 id="_23、什么是spring-cloud-seata" tabindex="-1"><a class="header-anchor" href="#_23、什么是spring-cloud-seata" aria-hidden="true">#</a> 23、什么是Spring Cloud Seata？</h2><blockquote><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p></blockquote><h1 id="十、redis面试题" tabindex="-1"><a class="header-anchor" href="#十、redis面试题" aria-hidden="true">#</a> 十、Redis面试题</h1><h2 id="_1、为什么要用缓存" tabindex="-1"><a class="header-anchor" href="#_1、为什么要用缓存" aria-hidden="true">#</a> 1、为什么要用缓存</h2><blockquote><p>使用缓存的目的就是提升读写性能。而实际业务场景下，更多的是为了提升读性能，带来更好的性能，带来更高的并发量。Redis的读写性能比Mysql好的多，我们就可以把Mysql中的热点数据缓存到Redis中，提升读取性能，同时也减轻了Mysql的读取压力。</p></blockquote><h2 id="_2、使用-redis有哪些好处" tabindex="-1"><a class="header-anchor" href="#_2、使用-redis有哪些好处" aria-hidden="true">#</a> 2、使用 Redis有哪些好处？</h2><p>具有以下好处：</p><ul><li>读取速度快，因为数据存在内存中，所以数据获取快；</li><li>支持多种数据结构，包括字符串、列表、集合、有序集合、哈希等；</li><li>支持事务，且操作遵守原子性，即对数据的操作要么都执行，要么都不支持；</li><li>还拥有其他丰富的功能，队列、主从复制、集群、数据持久化等功能。</li></ul><h2 id="_3、什么是-redis" tabindex="-1"><a class="header-anchor" href="#_3、什么是-redis" aria-hidden="true">#</a> 3、什么是 Redis？</h2><blockquote><p>Redis 是一个开源（BSD 许可）、基于内存、支持多种数据结构的存储系统，可以作为数据库、缓存和消息中间件。它支持的数据结构有字符串（strings）、哈希（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等，除此之外还支持 bitmaps、hyperloglogs 和地理空间（geospatial ）索引半径查询等功能。</p></blockquote><h2 id="_4、为什么redis单线程模型效率也能那么高" tabindex="-1"><a class="header-anchor" href="#_4、为什么redis单线程模型效率也能那么高" aria-hidden="true">#</a> 4、为什么Redis单线程模型效率也能那么高？</h2><ol><li>C语言实现，效率高</li><li>纯内存操作</li><li>基于非阻塞的IO复用模型机制</li><li>单线程的话就能避免多线程的频繁上下文切换问题</li><li>丰富的数据结构（全称采用hash结构，读取速度非常快，对数据存储进行了一些优化，比如亚索表，跳表等）</li></ol><h2 id="_5、为什么-redis-需要把所有数据放到内存中" tabindex="-1"><a class="header-anchor" href="#_5、为什么-redis-需要把所有数据放到内存中" aria-hidden="true">#</a> 5、为什么 Redis 需要把所有数据放到内存中？</h2><blockquote><p>Redis 将数据放在内存中有一个好处，那就是可以实现最快的对数据读取，如果数据存储在硬盘中，磁盘 I/O 会严重影响 Redis 的性能。而且 Redis 还提供了数据持久化功能，不用担心服务器重启对内存中数据的影响。其次现在硬件越来越便宜的情况下，Redis 的使用也被应用得越来越多，使得它拥有很大的优势。</p></blockquote><h2 id="_6、redis-的同步机制了解是什么" tabindex="-1"><a class="header-anchor" href="#_6、redis-的同步机制了解是什么" aria-hidden="true">#</a> 6、Redis 的同步机制了解是什么？</h2><blockquote><p>Redis 支持主从同步、从从同步。如果是第一次进行主从同步，主节点需要使用 bgsave 命令，再将后续修改操作记录到内存的缓冲区，等 RDB 文件全部同步到复制节点，复制节点接受完成后将RDB 镜像记载到内存中。等加载完成后，复制节点通知主节点将复制期间修改的操作记录同步到复制节点，即可完成同步过程。</p></blockquote><h2 id="_7、说一下redis有什么优点和缺点" tabindex="-1"><a class="header-anchor" href="#_7、说一下redis有什么优点和缺点" aria-hidden="true">#</a> 7、说一下Redis有什么优点和缺点</h2><p><strong>优点</strong></p><ul><li>速度快：因为数据存在内存中，类似于HashMap ，HashMap的优势就是查找和操作的时间复杂度都是O (1) 。</li><li>支持丰富的数据结构：支持 String ，List，Set，Sorted Set，Hash 五种基础的数据结构。</li><li>持久化存储：Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉</li><li>高可用：内置 Redis Sentinel ，提供高可用方案，实现主从故障自动转移。 内置Redis Cluster，提供集群方案，实现基于槽的分片方案，从而支持更大的 Redis 规模。</li><li>丰富的特性：Key过期、计数、分布式锁、消息队列等。</li></ul><p><strong>缺点</strong></p><ul><li>由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</li><li>如果进行完整重同步，由于需要生成 RDB文件，并进行传输，会占用主机的 CPU ，并会消耗现网的带宽。不过 Redis2.8 版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。</li><li>修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis不能提供服务。</li></ul><h2 id="_8、redis的淘汰策略" tabindex="-1"><a class="header-anchor" href="#_8、redis的淘汰策略" aria-hidden="true">#</a> 8、Redis的淘汰策略</h2><p>Redis中共有八种内存淘汰策略:</p><ol><li>Volatile-lru: 设置了过期时间的Key使用了LRU算法淘汰;</li><li>Allkeys-lru: 所有key使用LRU算法;</li><li>Volatile-lfu: 设置了过期时间的key使用了LFU算法淘汰;</li><li>Allkeys-lfu: 所有key使用了LFU算法淘汰;</li><li>Volatile-random: 设置了过期时间的key使用随机淘汰;</li><li>Allkeys-random: 所有key使用随机淘汰;</li><li>Volatile-ttl: 设置了过期时间的key根据过期时间淘汰,越早过期越早淘汰;</li><li>Noeviction: 默认策略,当内存达到设置的最大值时,所有申请内存的操作都会报错,(如set,ipush等),只读操作如get命令可以正常执行.</li></ol><p>主要是4种算法，针对不同的key,形成的策略。</p><p><strong>算法</strong>：</p><ol><li>lru 最近很少的使用的key（根据时间，最不常用的淘汰）</li><li>lfu 最近很少的使用的key (根据计数器，用的次数最少的key淘汰)</li><li>random 随机淘汰</li><li>ttl 快要过期的先淘汰</li></ol><h2 id="_9、redis-为什么设计成单线程的" tabindex="-1"><a class="header-anchor" href="#_9、redis-为什么设计成单线程的" aria-hidden="true">#</a> 9、Redis 为什么设计成单线程的？</h2><blockquote><p>多线程处理会涉及到锁，并且多线程处理会涉及到线程切···换而消耗 CPU。采用单线程，避免了不必要的上下文切换和竞争条件。其次 CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。</p></blockquote><h2 id="_10、redis五种数据类型" tabindex="-1"><a class="header-anchor" href="#_10、redis五种数据类型" aria-hidden="true">#</a> 10、Redis五种数据类型</h2><ul><li>String：key-value（做缓存）</li><li>Hash：key-fields-values（做缓存）</li><li>List：有顺序可重复Set：无顺序，不能重复</li><li>SortedSet：有顺序，不能重复</li></ul><h2 id="_11、redis集群一般需要几台服务器" tabindex="-1"><a class="header-anchor" href="#_11、redis集群一般需要几台服务器" aria-hidden="true">#</a> 11、Redis集群一般需要几台服务器？</h2><blockquote><p>因为redis集群至少需要三个节点,要保证集群的高可用,每个节点都要一个备份机.理论上也需要6台虚拟机</p></blockquote><h2 id="_12、什么是缓存穿透-如何避免" tabindex="-1"><a class="header-anchor" href="#_12、什么是缓存穿透-如何避免" aria-hidden="true">#</a> 12、什么是缓存穿透，如何避免</h2><ul><li>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key，请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透</li><li>解决方案 <ul><li>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存</li><li>对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤</li></ul></li></ul><h2 id="_13、什么是缓存雪崩-如何避免" tabindex="-1"><a class="header-anchor" href="#_13、什么是缓存雪崩-如何避免" aria-hidden="true">#</a> 13、什么是缓存雪崩，如何避免</h2><ul><li>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃</li><li>解决方案： <ul><li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待</li><li>做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</li><li>不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀</li></ul></li></ul><h2 id="_14、redis-的持久化机制是什么-各自的优缺点" tabindex="-1"><a class="header-anchor" href="#_14、redis-的持久化机制是什么-各自的优缺点" aria-hidden="true">#</a> 14、Redis 的持久化机制是什么？各自的优缺点？</h2><p>持久化机制：</p><ul><li>RDB（默认）<code>Redis DataBase</code></li><li>AOF <code>Append Only File</code></li></ul><h3 id="rdb" tabindex="-1"><a class="header-anchor" href="#rdb" aria-hidden="true">#</a> RDB：</h3><p>RDB是Redis默认的持久化方式。</p><p>工作机制：每隔一段时间，就把内存中的数据保存到硬盘上的指定文件中。对应产生的数据文件为dump.rdb</p><p>触发RDB的方式有两种：手动触发和自动触发</p><blockquote><p>优点：</p><ul><li>只有一个文件 dump.rdb，方便持久化。</li><li>容灾性好，一个文件可以保存到安全的磁盘。</li><li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li><li>相对于数据集大时，比 AOF 的启动效率更高。</li></ul><p>缺点：</p><ul><li>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候。如果redis要故障时要尽可能少的丢失数据，RDB没有AOF好，例如1:00进行的快照，在1:10又要进行快照的时候宕机了，这个时候就会丢失10分钟的数据。</li><li>RDB每次fork出子进程来执行RDB快照生成文件时，如果文件特别大，可能会导致客户端提供服务暂停数毫秒或者几秒</li></ul></blockquote><h3 id="aof" tabindex="-1"><a class="header-anchor" href="#aof" aria-hidden="true">#</a> AOF：</h3><blockquote><p>AOF 是 以日志的形式来记录每个写操作，将每一次对数据进行修改，都把新建、修改数据的命令保存到指 定文件中。Redis 重新启</p><p>动时读取这个文件，重新执行新建、修改数据的命令恢复数据。</p><p>当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复</p><p>优点：</p><ul><li><p>数据安全，AOF持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 AOF文件中一次。</p></li><li><p>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</p></li><li><p>AOF日志文件的命令通过非常可读的方式进行记录，这个非常适合做灾难性的误删除紧急恢复，如果某人不小心用flushall命令</p><p>清空了所有数据，只要这个时候还没有执行rewrite，那么就可以将日志文件中的flushall删除，进行恢复</p></li></ul><p>缺点：</p><ul><li>对于同一份文件AOF文件比RDB数据快照要大。</li><li>AOF开启后支持写的QPS会比RDB支持的写的QPS低，因为AOF一般会配置成每秒fsync操作，每秒的fsync操作还是很高的、</li><li>数据恢复比较慢，不适合做冷备。</li></ul></blockquote><h1 id="十一、中间件相关面试题" tabindex="-1"><a class="header-anchor" href="#十一、中间件相关面试题" aria-hidden="true">#</a> 十一、中间件相关面试题</h1><h2 id="rabbitmq" tabindex="-1"><a class="header-anchor" href="#rabbitmq" aria-hidden="true">#</a> RabbitMQ</h2><h3 id="_1、mq的优势" tabindex="-1"><a class="header-anchor" href="#_1、mq的优势" aria-hidden="true">#</a> 1、MQ的优势</h3><ol><li><strong>应用解耦 ：</strong> 服务与服务之间不再约定协议而对接接口，而是通过生产者/消费者的模式让中间件的MQ来对接两边的数据通信实现解耦合（扩展性更强）。</li><li><strong>一步提速：</strong> 常见的服务通信：需要阻塞成功获取到响应状态在写入数据到数据库，阻塞同步往下执行。加入MQ后：提升用户体验和系统吞吐量。</li><li><strong>削峰填谷 ：</strong><ol><li>常见的服务通信：当一瞬间有5000个请求给到服务器时，服务器最大能处理1000请求，受不了了当场去世。</li><li>加入MQ后：先把请求丢到队列中等待处理，系统每秒从mq中拉取1000个请求进行处理（刚好卡在能处理的1000个，真实压榨案例），这样就变成了从1秒钟处理5000个请求的高峰期，拆分成了5秒钟，每秒钟处理1000请求的平缓处理器，哦不，是满载处理器。</li></ol></li></ol><h3 id="_2、你们项目中用到过-mq-吗-谈谈你对-mq-的理解" tabindex="-1"><a class="header-anchor" href="#_2、你们项目中用到过-mq-吗-谈谈你对-mq-的理解" aria-hidden="true">#</a> 2、你们项目中用到过 MQ 吗？谈谈你对 MQ 的理解？</h3><blockquote><p>我们项目中使用 MQ 主要是做一些异步的操作，比如说我们的接口是属于http协议接口，它是同步调用，如果说接口响应比较慢的情况下，会导致客户端同步阻塞等待，客户端同步阻塞等待的情况下，会引发客户端超时，客户端一旦发生超时，就会导致客户端触发一些重试的策略，而在触发重试的策略过程中会导致业务可能会发生重复执行，所以我们就需要注意一些幂等性问题，而接口因为它执行比较耗时，所以呢，我们会将一些执行比较耗时的业务逻辑代码把他直接改成使用 mq 异步去实现，能够提高就是我们的 http 协议接口的响应速度，比如说异步的去扣库存呢，异步的去发短信呢这些场景下我们都是使用到 MQ来进行实现落地的。</p></blockquote><h3 id="_3、常用的mq" tabindex="-1"><a class="header-anchor" href="#_3、常用的mq" aria-hidden="true">#</a> 3、常用的MQ</h3><p>（1）ActiveMQ：支持万级的吞吐量，较成熟完善；</p><p>（2）RabbitMQ：延时低，微妙级延时，</p><p>（3）RocketMQ：阿里维护的消息中间件，可以达到十万级的吞吐量，支持分布式事务。</p><p>（4）Kafka：阿里维护的消息中间件，可以达到十万级的吞吐量，支持分布式事务。</p><h3 id="_4、mq消费者消费消息的顺序一致性问题" tabindex="-1"><a class="header-anchor" href="#_4、mq消费者消费消息的顺序一致性问题" aria-hidden="true">#</a> 4、MQ消费者消费消息的顺序一致性问题？</h3><blockquote><p>生产者投递消息过程当中可以设定一个消息 key，相同的业务逻辑呢可以设定一个相同的消息 key 在做 hash 的时候最终都会落地到同一个分区来就行存放，最终就被同一个消费者进行消费，所以想解决消息顺序这些问题，它的核心思想就是，让我们的这个消息投递存放到同一个分区里面，最终被同一个消费者消费。</p></blockquote><h3 id="_5、rabbitmq如何保证数据一致性" tabindex="-1"><a class="header-anchor" href="#_5、rabbitmq如何保证数据一致性" aria-hidden="true">#</a> 5、RabbitMQ如何保证数据⼀致性？</h3><ol><li>⽣产者确认机制：消息持久化后异步回调通知⽣产者，保证消息已经发出去；</li><li>消息持久化：设置消息持久化；</li><li>消费者确认机制：消费者成功消费消息之后，⼿动确认，保证消息已经消费。</li></ol><h3 id="_6、如何确保消息正确地发送至rabbitmq" tabindex="-1"><a class="header-anchor" href="#_6、如何确保消息正确地发送至rabbitmq" aria-hidden="true">#</a> 6、如何确保消息正确地发送⾄RabbitMQ？</h3><blockquote><p>RabbitMQ使⽤发送⽅确认模式，确保消息正确地发送到RabbitMQ。<br> 发送⽅确认模式：将信道设置成confirm模式（发送⽅确认模式），则所有在信道上发布的消息都会被指派⼀个唯⼀的ID。⼀旦消息被投递到⽬的队列后，或者消息被写⼊磁盘后（可持久化的消息），信道会发送⼀个确认给⽣产者（包含消息唯⼀ID）。如果RabbitMQ发⽣内部错误从⽽导致消息丢失，会发送⼀条nack（not acknowledged，未确认）消息。发送⽅确认模式是异步的，⽣产者应⽤程序在等待确认的同时，可以继续发送消息。当确认消息到达⽣产者应⽤程序，⽣产者应⽤程序的回调⽅法就会被触发来处理确认消息。</p></blockquote><h3 id="_7、如何避免消息重复投递或重复消费" tabindex="-1"><a class="header-anchor" href="#_7、如何避免消息重复投递或重复消费" aria-hidden="true">#</a> 7、如何避免消息重复投递或重复消费？</h3><blockquote><p>在消息⽣产时，MQ内部针对每条⽣产者发送的消息⽣成⼀个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进⼊队列；在消息消费时，要求消息体中必须要有⼀个bizId（对于同⼀业务全局唯⼀，如⽀付ID、订单ID、帖⼦ID等）作为去重和幂等的依据，避免同⼀条消息被重复消费。</p></blockquote><h3 id="_8、rabbitmq的工作模式" tabindex="-1"><a class="header-anchor" href="#_8、rabbitmq的工作模式" aria-hidden="true">#</a> 8、RabbitMQ的工作模式</h3><p><strong>一.simple模式（即最简单的收发模式）</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230213113843710.png" alt="image-20230213113843710" tabindex="0" loading="lazy"><figcaption>image-20230213113843710</figcaption></figure><p><strong>二.work工作模式(资源的竞争)</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230213113858209.png" alt="image-20230213113858209" tabindex="0" loading="lazy"><figcaption>image-20230213113858209</figcaption></figure><p><strong>三.publish/subscribe发布订阅(共享资源)</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230213113921225.png" alt="image-20230213113921225" tabindex="0" loading="lazy"><figcaption>image-20230213113921225</figcaption></figure><p><strong>四.routing路由模式</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230213113949489.png" alt="image-20230213113949489" tabindex="0" loading="lazy"><figcaption>image-20230213113949489</figcaption></figure><p><strong>五.topic 主题模式(路由模式的一种)</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230213114007036.png" alt="image-20230213114007036" tabindex="0" loading="lazy"><figcaption>image-20230213114007036</figcaption></figure><h2 id="elasticsearch" tabindex="-1"><a class="header-anchor" href="#elasticsearch" aria-hidden="true">#</a> ElasticSearch</h2><h3 id="_1、elasticsearch-了解多少-说说你们公司-es-的集群架构-索引数据大小-分片有多少-以及一些调优手段" tabindex="-1"><a class="header-anchor" href="#_1、elasticsearch-了解多少-说说你们公司-es-的集群架构-索引数据大小-分片有多少-以及一些调优手段" aria-hidden="true">#</a> 1、elasticsearch 了解多少，说说你们公司 es 的集群架构，索引数据大小，分片有多少，以及一些调优手段</h3><ul><li>面试官：想了解应聘者之前公司接触的 ES 使用场景、规模，有没有做过比较大规模的索引设计、规划、调优。</li><li>解答：如实结合自己的实践场景回答即可。</li><li>比如：ES 集群架构 13 个节点，索引根据通道不同共 20+索引，根据日期，每日递增 20+，索引：10分片，每日递增 1 亿+数据，每个通道每天索引大小控制：150GB 之内。</li><li>仅索引层面调优手段： <ul><li>根据业务增量需求，采取基于日期模板创建索引，通过 roll over API 滚动索引；</li><li>使用别名进行索引管理；</li><li>每天凌晨定时对索引做 force_merge 操作，以释放空间；</li><li>采取冷热分离机制，热数据存储到 SSD，提高检索效率；冷数据定期进行 shrink操作，以缩减存储；</li><li>采取 curator 进行索引的生命周期管理；</li><li>仅针对需要分词的字段，合理的设置分词器；</li><li>Mapping 阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。</li></ul></li></ul><h3 id="_2、为什么要使用elasticsearch" tabindex="-1"><a class="header-anchor" href="#_2、为什么要使用elasticsearch" aria-hidden="true">#</a> 2、为什么要使用elasticsearch</h3><blockquote><p>因为在我们课程中的数据，将来会非常多，所以采用以往的模糊查询，模糊查询前置配置，会放弃索引，导致课程查询是全表扫面，在百万级别的数据库中，效率非常低下，而我们使用ES做一个全文索引，我们将经常查询的课程的某些字段，比如说课程名，描述、价格还有id这些字段我们放入我们索引库里，可以提高查询速度。</p></blockquote><h3 id="_3、项目中如何使用elasticsearch" tabindex="-1"><a class="header-anchor" href="#_3、项目中如何使用elasticsearch" aria-hidden="true">#</a> 3、项目中如何使用elasticsearch</h3><blockquote><p>在服务启动时将课程数据从数据库查询出来压入es中，在用户进行课程搜索时，可以通过课程关键词、讲师名称和价格区间进行数据搜索，通过关键词进行搜索时，使用了es 的高亮和分页的工具类，对查询出来的数据与查询字段相同的进行高亮处理并通过匹配度的高低进行排序。</p></blockquote><h3 id="_4、谈谈分词与倒排索引的原理" tabindex="-1"><a class="header-anchor" href="#_4、谈谈分词与倒排索引的原理" aria-hidden="true">#</a> 4、谈谈分词与倒排索引的原理</h3><p>首先说分词是给检索用的。</p><ul><li>英文：一个单词一个词，很简单。I am a student，词与词之间空格分隔。</li><li>中文：我是学生，就不能一个字一个字地分，我-是-学生。这是好分的。还有歧义的，使用户放心，使用-户，使-用户。人很容易看出，机器就难多了。所以市面上有各种各样的分词器，一个强调的效率一个强调的准确率。</li></ul><p><strong>倒排索引：倒排针对的是正排。</strong></p><ol><li>正排就是我记得我电脑有个文档，讲了 ES 的常见问题总结。那么我就找到文档，从上往下翻页，找到ES的部分。通过文档找文档内容。</li><li>倒排：一个txt文件ES的常见问题 -&gt; D:/分布式问题总结.doc。</li></ol><blockquote><p>所以倒排就是文档内容找文档。当然内容不是全部的，否则也不需要找文档了，内容就是几个分词而已。这里的txt就是搜索引擎。</p></blockquote><h2 id="sharing-jdbc" tabindex="-1"><a class="header-anchor" href="#sharing-jdbc" aria-hidden="true">#</a> Sharing-JDBC</h2><h3 id="_1、shards-replicas分片和复制" tabindex="-1"><a class="header-anchor" href="#_1、shards-replicas分片和复制" aria-hidden="true">#</a> 1、Shards&amp;Replicas分片和复制：</h3><p>****分片：****将索引划分成多份，可以放置在集群任何节点上。1、允许水平分割/扩展内容数量；2、允许在分片上进行分布式、并行。</p><p>****复制：****创建分片的一份或多份拷贝。1、在分片/节点失败的情况下，提高了高可用性；2、搜索可以在所有复制上运行；3、分片和复制的数量可以在索引创建的时候指定。4、复制数量可以在之后动态改变，分片数量事后不能再改变。</p><h3 id="_2、、分库分表" tabindex="-1"><a class="header-anchor" href="#_2、、分库分表" aria-hidden="true">#</a> 2、、分库分表</h3><p><em><strong>*作用：缓解单机和单库带来的性能瓶颈和压力，突破网络IO、硬件资源、连接数的瓶颈。*</strong></em></p><p>****方式：****垂直分库、水平分库、垂直分表、水平分表。</p><p><em><strong>*垂直拆分原则：*</strong></em>（1）不常用的字段单独放一张表。</p><p>​ （2）text、blob等大字段拆分放在附表。</p><p>​ （3）经常组合查询的列放在同一张表中。</p><h3 id="_3、垂直分库" tabindex="-1"><a class="header-anchor" href="#_3、垂直分库" aria-hidden="true">#</a> 3、垂直分库</h3><p>按照业务进行分类，分不到不同的数据库上，每个库可以放在不同的数据库上（专库专用）。</p><p><em><strong>*好处：*</strong></em>（1）业务层面解耦</p><p>（2）对不同的业务数据进行分级管理、维护、监控、扩展。</p><p>（3）高并发场景下，提升IO、数据库连接数、降低单机硬件资源的瓶颈。</p><h3 id="_4、水平分库" tabindex="-1"><a class="header-anchor" href="#_4、水平分库" aria-hidden="true">#</a> 4、水平分库</h3><p>把同一张表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上。</p><p>****好处：****解决了单库大数据，高并发的性能瓶颈，提高了系统的稳定性和可用性。</p><h3 id="_5、垂直分表" tabindex="-1"><a class="header-anchor" href="#_5、垂直分表" aria-hidden="true">#</a> 5、垂直分表</h3><p>将一个表按照字段分成多表，每个表存储一部分字段。</p><p>****好处：（****1）避免IO争抢，减少锁表的几率。</p><p>（2）充分发挥热门数据的操作效率。</p><h3 id="_6、水平分表" tabindex="-1"><a class="header-anchor" href="#_6、水平分表" aria-hidden="true">#</a> 6、水平分表</h3><p>在同一个数据库内，把同一个表的数据按一定规则拆到多个表中。</p><p>****好处：****优化单一表数据量过大而产生的性能问题，避免IO争抢，减少锁表的几率。</p><h3 id="_7、sharing-jdbc定义" tabindex="-1"><a class="header-anchor" href="#_7、sharing-jdbc定义" aria-hidden="true">#</a> 7、Sharing-JDBC定义</h3><figure><img src="https://edu--learn.oss-cn-beijing.aliyuncs.com/weixin/图片7.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p><em><strong>*当当网研发的开源分布式数据库中间件。*</strong></em></p><h2 id="docker" tabindex="-1"><a class="header-anchor" href="#docker" aria-hidden="true">#</a> Docker</h2><h3 id="_1、简介" tabindex="-1"><a class="header-anchor" href="#_1、简介" aria-hidden="true">#</a> 1、简介</h3><p>Docker是一个开源的应用容器引擎，开发者可以打包自己的应用到容器里面，然后迁移到其他机器的docker应用中，可以实现快速部署。</p><h3 id="_2、docker基本概念" tabindex="-1"><a class="header-anchor" href="#_2、docker基本概念" aria-hidden="true">#</a> 2、Docker基本概念</h3><p><strong>Client（客户端）：</strong> 是Docker的用户端，可以接受用户命令和配置标识，并与Docker daemon通信。</p><p><strong>Images（镜像）：</strong> 是一个只读模板，含创建Docker容器的说明，它与操作系统的安装光盘有点像。</p><p><strong>Containers（容器）：</strong> 镜像的运行实例，镜像与容器的关系类比面向对象中的类和对象。</p><p><strong>Registry（仓库）：</strong> 是一个集中存储与分发镜像的服务。最常用的Registry是官方的Docker Hub 。</p><h1 id="十二、数据结构与算法面试题" tabindex="-1"><a class="header-anchor" href="#十二、数据结构与算法面试题" aria-hidden="true">#</a> 十二、数据结构与算法面试题</h1><h2 id="_1-1-概述" tabindex="-1"><a class="header-anchor" href="#_1-1-概述" aria-hidden="true">#</a> 1.1 概述</h2><p>​ 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</p><p>​ JAVA中常见的数据结构有</p><ul><li>数组</li><li>栈（Stack）</li><li>队列（Queue）</li><li>链表（LinkedList）</li><li>树（Tree）</li><li>哈希表（Hash）</li></ul><h2 id="_1-2-数组" tabindex="-1"><a class="header-anchor" href="#_1-2-数组" aria-hidden="true">#</a> 1.2 数组</h2><p>​ 数组是内存中连续保存的多个相同类型的元素的数据结构。通过下标索引访问数组中的元素，索引从0开始。根据维度可以分为1维数组、2维数组……N维数组。</p><ul><li><p>优点</p><p>通过下标直接定位元素位置，查找效率高。</p></li><li><p>缺点</p><ul><li>长度固定</li><li>数据类型都必须相同</li><li>插入跟删除元素时效率比较低。</li></ul></li></ul><p>适合场景：大量查询，很少删除和插入。</p><h2 id="_1-3-栈" tabindex="-1"><a class="header-anchor" href="#_1-3-栈" aria-hidden="true">#</a> 1.3 栈</h2><h3 id="_1-3-1-概述" tabindex="-1"><a class="header-anchor" href="#_1-3-1-概述" aria-hidden="true">#</a> 1.3.1 概述</h3><p>​ 栈结构只能在一端操作，该操作端叫做栈顶，另一端叫做栈底。栈结构按照“后进先出”（Last In First Out, LIFO）的方式处理结点数据。</p><h2 id="_1-4-队列" tabindex="-1"><a class="header-anchor" href="#_1-4-队列" aria-hidden="true">#</a> 1.4 队列</h2><p>​ 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p><h2 id="_1-5-链表" tabindex="-1"><a class="header-anchor" href="#_1-5-链表" aria-hidden="true">#</a> 1.5 链表</h2><p>​ 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针连接次序实现的。每一个链表都包含多个节点，节点又包含两个部分，一个是数据域（储存节点含有的信息），一个是引用域（储存下一个节点或者上一个节点的地址）。</p><p><strong>链表的特点</strong>：</p><ul><li>获取数据麻烦，需要遍历查找，比数组慢</li><li>插入、删除的效率比较高</li></ul><p>链表从结构上分为<strong>单向链表</strong>跟<strong>双向链表</strong>。</p><h2 id="_1-6-树" tabindex="-1"><a class="header-anchor" href="#_1-6-树" aria-hidden="true">#</a> 1.6 树</h2><h3 id="_1-6-1-树" tabindex="-1"><a class="header-anchor" href="#_1-6-1-树" aria-hidden="true">#</a> 1.6.1 树</h3><p>​ 树(Tree)是n(n≥0)个结点的有限集T，并且当n＞0时满足下列条件：<br> ​ （1）有且仅有一个特定的称为根(Root)的结点；<br> ​ （2）当n＞1时，其余结点可以划分为m(m＞0)个互不相交的有限集T1、T2 、…、Tm，每个集Ti(1≤i≤m)均为树，且称为树T的子树(SubTree)。<br> ​ 特别地，不含任何结点(即n＝0)的树，称为空树。</p><h3 id="_1-6-2-二叉树" tabindex="-1"><a class="header-anchor" href="#_1-6-2-二叉树" aria-hidden="true">#</a> 1.6.2 二叉树</h3><p>​ 二叉树（Binary Tree）是有限个节点的集合，这个集合可以是空集，也可以是一个根节点和<strong>两</strong>颗不相交的子二叉树组成的集合，其中一颗树叫根的左子树，另一颗树叫右子树。所以二叉树是一个递归地概念。</p><h3 id="_1-6-3-满二叉树" tabindex="-1"><a class="header-anchor" href="#_1-6-3-满二叉树" aria-hidden="true">#</a> 1.6.3 满二叉树</h3><p>​ 一棵满二叉树就是高度为k，且拥有(2^k)-1个节点的二叉树，一棵满二叉树每个节点，要么都有两棵子树，要么都没有子树；而且每一层所有的节点之间必须要么都有两棵子树，要么都没子树。</p><h3 id="_1-6-4-完全二叉树" tabindex="-1"><a class="header-anchor" href="#_1-6-4-完全二叉树" aria-hidden="true">#</a> 1.6.4 完全二叉树</h3><p>完全二叉树是一颗特殊的二叉树，它遵循以下规则：</p><p>假设完全二叉树高度为k，则完全二叉树需要符合以下两点：</p><ul><li>所有叶子节点都出现在k层或k-1层，并且从1~k-1层必须达到最大节点数。</li><li>第k层可以是不满的，但是第k层的所有节点必须集中在最左边。</li></ul><h3 id="_1-6-5-二叉查找树" tabindex="-1"><a class="header-anchor" href="#_1-6-5-二叉查找树" aria-hidden="true">#</a> 1.6.5 二叉查找树</h3><p>​ 二叉查找树(BinarySearch Tree，也叫二叉搜索树，或二叉排序树BinarySort Tree)或者是一棵空树，或者是具有下列性质的二叉树：</p><p>​ 1、若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p><p>​ 2、若任意结点的右子树不空，则右子树上所有节点的值均大于它的根结点的值；</p><p>​ 3、任意结点的左右子树也分别为二叉查找树；</p><p>​ 4、没有键值相等的结点。</p><p>在实际应用中，二叉查找树的使用比较多。</p><h3 id="_1-6-6-平衡二叉树" tabindex="-1"><a class="header-anchor" href="#_1-6-6-平衡二叉树" aria-hidden="true">#</a> 1.6.6 平衡二叉树</h3><p>​ 平衡二叉树（AVL）是一种特殊的二叉查找树，其中每一个节点的左子树和右子树的高度差至多等于1。从平衡二叉树的名字中可以看出来，它是一种高度平衡的二叉排序树。那么什么叫做高度平衡呢？意思就是要么它是一颗空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度只差的绝对值绝对不超过1。</p><h3 id="_1-6-7-红黑树" tabindex="-1"><a class="header-anchor" href="#_1-6-7-红黑树" aria-hidden="true">#</a> 1.6.7 红黑树</h3><p>​ 红黑树（Red Black Tree） 是一种自平衡二叉查找树。</p><p><strong>红黑树的特性</strong><br> （1）每个节点或者是黑色，或者是红色。<br> （2）根节点是黑色。<br> （3）每个叶子节点（NIL）是黑色。<br> （4）如果一个节点是红色的，则它的子节点必须是黑色的。<strong>[注意：这里叶子节点，是指为空(NIL)的虚节点！]</strong><br> （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p><p><strong>红黑树跟平衡二叉树的区别</strong></p><ol><li><p>红黑树放弃了追求完全平衡，追求大致平衡，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。</p></li><li><p>平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。</p></li></ol><h2 id="_1-7-哈希表" tabindex="-1"><a class="header-anchor" href="#_1-7-哈希表" aria-hidden="true">#</a> 1.7 哈希表</h2><p>​ 哈希表（Hash table，也叫散列表），是根据关键码值(Key)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列（哈希）函数，存放记录的数组叫做散列表。</p><h3 id="_1-7-2-哈希冲突" tabindex="-1"><a class="header-anchor" href="#_1-7-2-哈希冲突" aria-hidden="true">#</a> 1.7.2 哈希冲突</h3><p>​ 对应不同的关键字可能获得相同的hash地址，即 key1≠key2，但是f(key1)=f(key2)。这种现象就是冲突，而且这种冲突只能尽可能的减少，不能完全避免。</p><p>常用的冲突解决办法：</p><ul><li><p>开放地址法（线性探测法）</p><p>当冲突法生时，继续往后查找数组的下一个空位，并将数据填入。比如1和101,1占据了一个位置，101进入时候就向下查找，找到下面的一个空位插入， 如果没有继续查找空位，直到找到为止并进行插入。</p></li><li><p>链地址法（拉链法）</p><p>将产生冲突的值以链表的形式连起来。</p></li></ul><h2 id="_1-8-对比" tabindex="-1"><a class="header-anchor" href="#_1-8-对比" aria-hidden="true">#</a> 1.8 对比</h2><p>每种数据结构有自己的特点跟优缺点，见如下表</p><table><thead><tr><th style="text-align:center;">数据结构</th><th style="text-align:center;">优 点</th><th style="text-align:center;">缺 点</th></tr></thead><tbody><tr><td style="text-align:center;">数组</td><td style="text-align:center;">插入快</td><td style="text-align:center;">查找慢，删除慢，大小固定，只能存储单一元素</td></tr><tr><td style="text-align:center;">栈</td><td style="text-align:center;">提供后进先出的存取方式</td><td style="text-align:center;">存取其他项很慢</td></tr><tr><td style="text-align:center;">队列</td><td style="text-align:center;">提供先进先出的存取方式</td><td style="text-align:center;">存取其他项很慢</td></tr><tr><td style="text-align:center;">链表</td><td style="text-align:center;">插入快，删除快</td><td style="text-align:center;">查找慢</td></tr><tr><td style="text-align:center;">二叉树</td><td style="text-align:center;">如果树是平衡的，则查找、插入、删除都快</td><td style="text-align:center;">删除算法复杂</td></tr><tr><td style="text-align:center;">红黑树</td><td style="text-align:center;">查找、删除、插入都快。树总是平衡</td><td style="text-align:center;">算法复杂</td></tr><tr><td style="text-align:center;">哈希表</td><td style="text-align:center;">如果关键字已知则存取极快</td><td style="text-align:center;">删除慢，如果不知道关键字存取慢，对存储空间使用不充分</td></tr></tbody></table><h2 id="_2、简单算法" tabindex="-1"><a class="header-anchor" href="#_2、简单算法" aria-hidden="true">#</a> 2、简单算法</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token doc-comment comment">/**
     * 冒泡排序
     * <span class="token keyword">@param</span> <span class="token parameter">arr</span>
     * <span class="token keyword">@return</span>
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">MaoPao</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&gt;</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 选择排序
     * <span class="token keyword">@param</span> <span class="token parameter">arr</span>
     * <span class="token keyword">@return</span>
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">XuanZe</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token operator">&gt;</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    index <span class="token operator">=</span> j<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
            arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 二分查找
     * <span class="token keyword">@param</span> <span class="token parameter">arr</span>
     * <span class="token keyword">@param</span> <span class="token parameter">value</span>
     * <span class="token keyword">@return</span>
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">ErFen</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> high <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>
                low <span class="token operator">=</span> mid <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
                high <span class="token operator">=</span> mid <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3、懒汉和饿汉" tabindex="-1"><a class="header-anchor" href="#_3、懒汉和饿汉" aria-hidden="true">#</a> 3、懒汉和饿汉</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 饿汉
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EHan</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">EHan</span> eHan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EHan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">EHan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">EHan</span> <span class="token function">getEHan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> eHan<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token doc-comment comment">/**
 * 懒汉
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LanHan</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">LanHan</span> lanHan <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">LanHan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">LanHan</span> <span class="token function">getLanHan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>lanHan <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            lanHan <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LanHan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> lanHan<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="冒泡排序" tabindex="-1"><a class="header-anchor" href="#冒泡排序" aria-hidden="true">#</a> 冒泡排序</h2><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 优化后的冒泡排序</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> k <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//初始化第一次排序的遍历范围</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// 循环次数</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&gt;</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 比较次数</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 交换位置</span>
                    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">^</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                        arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">^</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">^</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                        k <span class="token operator">=</span> j<span class="token punctuation">;</span>
                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;j = &quot;</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;arr = &quot;</span> <span class="token operator">+</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="选择排序" tabindex="-1"><a class="header-anchor" href="#选择排序" aria-hidden="true">#</a> 选择排序</h2><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>int[] arr = {3,5,2,6,1,8,9,1,2,4,0};
        int count = 0;
        // 循环次数
        for (int i = 0; i &lt;arr.length-1; i++) {
            count++;
            // 第二层循环 i正好是 第二层比较的数中最小的下标int
            int min = i ;
            for (int j = i+1; j &lt; arr.length; j++) {
                if (arr[j] &lt; arr[min]){
                    min = j;
                }
            }
            if (i != min){
                int temp = arr[min];
                arr[min] = arr[i];
                arr[i] = temp;
            }
        }
        System.out.println(&quot;比较次数 = &quot; + count);
        System.out.println(&quot;arr = &quot; + Arrays.toString(arr));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="二分法查找" tabindex="-1"><a class="header-anchor" href="#二分法查找" aria-hidden="true">#</a> 二分法查找</h2><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>public static void main(String[] args) {
        int[ ] arr = { 30,20,50,10,80,9,7,12,100,40,8};
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请输入你要查找的数 : &quot;);
        int searchWord = sc.nextInt();
        Arrays.sort(arr); //二分法查找之前，一定要对数组元素排序
        System.out.println(Arrays.toString(arr));
        System.out.println(searchWord+&quot;元素的索引：&quot;+binarySearch(arr,searchWord));
        System.out.println(&quot;========================&quot;);

    }

    public static int binarySearch(int[] arr, int value) {

        // 开始位置
        int begin = 0;
        // 结束 位置
        int end = arr.length - 1;

        while(begin &lt;= end) {
            int middle = (begin + end) / 2;

            //返回查询到的索引位置
            if (value == arr[middle]) {
                return middle;
            }

            if (arr[middle] &lt; value) {
                begin = middle + 1;
            }

            if (arr[middle] &gt; value) {
                end = middle - 1;
            }
        }
        //上面循环完毕，说明未找到，返回-1
        return -1;
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="十三、项目相关" tabindex="-1"><a class="header-anchor" href="#十三、项目相关" aria-hidden="true">#</a> 十三、项目相关</h1><h2 id="_1、oa工作流activiti" tabindex="-1"><a class="header-anchor" href="#_1、oa工作流activiti" aria-hidden="true">#</a> 1、OA工作流Activiti</h2><h3 id="定义-业务过程部分或整体-在计算机应用环境下的自动化" tabindex="-1"><a class="header-anchor" href="#定义-业务过程部分或整体-在计算机应用环境下的自动化" aria-hidden="true">#</a> 定义：业务过程部分或整体，在计算机应用环境下的自动化</h3><p>主要解决：使在多个参与者之间，按照某种预定义的规则传递文档、信息或任务的过程”自动进行“，从而实现某个预期的业务目标，或者促使此目标的实现。</p><h3 id="工作流管理系统" tabindex="-1"><a class="header-anchor" href="#工作流管理系统" aria-hidden="true">#</a> 工作流管理系统：</h3><p>一个完成工作量的定义和管理的软件系统。按照在系统中预先定义好的工作流规则进行工作流实例的执行。</p><p>（工作流管理系统不是企业的业务系统，而是为企业的业务系统的运行提供了一个软件的支撑环境）。</p><h3 id="主要作用" tabindex="-1"><a class="header-anchor" href="#主要作用" aria-hidden="true">#</a> 主要作用：</h3><p>1、定义工作流：包括具体的活动、规则等。</p><p>2、执行工作流：按照流程定义的规则执行，并由多个参与者进行控制。</p><h2 id="_2、微信登录" tabindex="-1"><a class="header-anchor" href="#_2、微信登录" aria-hidden="true">#</a> 2、微信登录</h2><h4 id="_1-appid" tabindex="-1"><a class="header-anchor" href="#_1-appid" aria-hidden="true">#</a> 1.AppID</h4><ul><li>应用ID，唯一标识（身份证号）</li></ul><h4 id="_2-appsecret" tabindex="-1"><a class="header-anchor" href="#_2-appsecret" aria-hidden="true">#</a> 2.AppSecret</h4><ul><li>应用的密钥（密码）</li></ul><h4 id="_3-code" tabindex="-1"><a class="header-anchor" href="#_3-code" aria-hidden="true">#</a> 3.code</h4><ul><li>授权的临时凭证（例如：临时身份证）</li></ul><h4 id="_4-access-token" tabindex="-1"><a class="header-anchor" href="#_4-access-token" aria-hidden="true">#</a> 4. access_token</h4><ul><li>接口调用凭证（例如：真正的身份证，虎符，令牌）</li></ul><figure><img src="https://edu--learn.oss-cn-beijing.aliyuncs.com/weixin/55278a478e7c4e349f75b2fd2db1884a.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="_3、微信支付" tabindex="-1"><a class="header-anchor" href="#_3、微信支付" aria-hidden="true">#</a> 3、微信支付</h2><figure><img src="https://edu--learn.oss-cn-beijing.aliyuncs.com/weixin/e8defdc54d9b480f9da1b6c9cf485d5d.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="_4、单点登录" tabindex="-1"><a class="header-anchor" href="#_4、单点登录" aria-hidden="true">#</a> 4、单点登录</h2><figure><img src="https://edu--learn.oss-cn-beijing.aliyuncs.com/weixin/bd808c7b5abc4c42a447572b422ff3a3.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="_5、并发量大的话如何处理" tabindex="-1"><a class="header-anchor" href="#_5、并发量大的话如何处理" aria-hidden="true">#</a> 5、并发量大的话如何处理？</h2><p>1、数据库优化、分库分表、读写分离、消息队列肖锋</p><p>2、单体式架构：多线程</p><p>分布式微服务、集群、负载均衡熔断、反向代理</p><h2 id="_6、预计吞吐量" tabindex="-1"><a class="header-anchor" href="#_6、预计吞吐量" aria-hidden="true">#</a> 6、预计吞吐量</h2><p>吞入量TPS：单位时间内处理请求的数量上线</p><p>QPS：秒为单位</p><p>RT：响应时间（一般为1-2秒）</p><h2 id="_7、文件上传如何处理断点续传" tabindex="-1"><a class="header-anchor" href="#_7、文件上传如何处理断点续传" aria-hidden="true">#</a> 7、文件上传如何处理断点续传？</h2><p>断点续传：断点续传指的是在下载或上传时，将下载或上传任务人为的划分为几个部分。</p><h4 id="整体思路" tabindex="-1"><a class="header-anchor" href="#整体思路" aria-hidden="true">#</a> 整体思路：</h4><p>拿到文件，保存文件唯一性标识，切割文件，分段上传，每次上传一段，根据唯一性标识判断文件上传进度，直到文件的全部片段上传完毕</p><h2 id="_8、redis分布式锁怎么实现的-当同时有多个······他是怎么处理的" tabindex="-1"><a class="header-anchor" href="#_8、redis分布式锁怎么实现的-当同时有多个······他是怎么处理的" aria-hidden="true">#</a> 8、redis分布式锁怎么实现的，当同时有多个······他是怎么处理的</h2><h4 id="_1、秒杀案例需要达到的预期特性" tabindex="-1"><a class="header-anchor" href="#_1、秒杀案例需要达到的预期特性" aria-hidden="true">#</a> 1、秒杀案例需要达到的预期特性</h4><table><thead><tr><th>稳</th><th>即流量符合预期时整体架构要满足高可用，就算超出预期也不能掉链子</th></tr></thead><tbody><tr><td>准</td><td>要保证数据的一致性，不能超卖</td></tr><tr><td>快</td><td>系统性能要足够高，尽可能做好系统优化</td></tr></tbody></table><h4 id="版本一" tabindex="-1"><a class="header-anchor" href="#版本一" aria-hidden="true">#</a> 版本一：</h4><pre><code> 快速搭建一个简单的秒杀系统，只需要把你的商品购买页面增加一个“定时上架”功能，仅在秒杀开始时才让用户看到购买按钮，当商品的库存卖完了也就结束了。
</code></pre><h4 id="版本二" tabindex="-1"><a class="header-anchor" href="#版本二" aria-hidden="true">#</a> 版本二：</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>随着请求量的加大（比如从 1w/s 到了 10w/s 的量级），版本一的架构很快就遇到了瓶颈，因此需要做架构改造来提升系统性能。这些架构改造包括：

 1）把秒杀系统独立出来打造一个单独的系统，这样可以有针对性的优化，例如减少淘宝店铺装修的功能，减少页面复杂度。

 2）系统独立部署一个集群，这样秒杀的大流量不会影响到正常的商品购买集群的机器负载。

 3）将热点数据单独放到一个缓存系统中，以提高读性能。

 4）增加秒杀答题，防止有秒杀器。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://edu--learn.oss-cn-beijing.aliyuncs.com/weixin/20191112155012346.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h4 id="版本三" tabindex="-1"><a class="header-anchor" href="#版本三" aria-hidden="true">#</a> 版本三：</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>这个架构仍然支持不了超过 100w/s 的请求量，所以为了进一步提升秒杀系统的性能，我们又对架构做进一步升级。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><pre><code>   1）对页面进行彻底的动静分离，使得用户秒杀时，不需要刷新整个页面，只需要点击抢宝按钮，借此把页面刷新的数据降到最少。

   2）在服务端对秒杀商品进行本地缓存，不需要再调用依赖系统的后台服务获取数据，甚至不需要去公共的缓存集群中查询数据，这样不仅可以减少系统调用，而且能够避免压垮公共缓存集群。

   3）增加系统限流保护，防止最坏情况发生。

 经过这些优化，系统架构变成了下图中的样子。在这里，我们对页面进行了进一步的静态化，秒杀过程中不需要刷新整个页面，而只需要向服务端请求很少的动态数据。而且，最关键的详情和交易系统都增加了本地缓存，来提前缓存秒杀商品的信息，热点数据库也做了独立部署等。
</code></pre><figure><img src="https://edu--learn.oss-cn-beijing.aliyuncs.com/weixin/20191112155733646.jpg" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>一个人进去，其他人阻塞进入等待，redis持久化数据-1，传递到消息队列到数据库。</p><h3 id="_1、实现分布式锁的思路" tabindex="-1"><a class="header-anchor" href="#_1、实现分布式锁的思路" aria-hidden="true">#</a> 1、实现分布式锁的思路</h3><ol><li>因为<strong>redis是单线程</strong>的，所以命令也就具备原子性，使用setnx命令实现锁，保存k-v <ul><li>如果k不存在，保存（当前线程加锁），执行完成后，删除k表示释放锁</li><li>如果k已存在，阻塞线程执行，表示有锁</li></ul></li><li>如果加锁成功，在执行业务代码的过程中出现异常，导致没有删除k（释放锁失败），那么就会造成死锁（后面的所有线程都无法执行）！ <ul><li>设置过期时间，例如10秒后，redis自动删除</li></ul></li><li>高并发下，由于时间段等因素导致服务器压力过大或过小，每个线程执行的时间不同 <ul><li>第一个线程，执行需要13秒，执行到第10秒时，redis自动过期了k（释放锁）</li><li>第二个线程，执行需要7秒，加锁，执行第3秒（锁 被释放了，为什么，是被第一个线程的finally主动deleteKey释放掉了）</li><li>。。。连锁反应，当前线程刚加的锁，就被其他线程释放掉了，周而复始，导致锁会永久失效</li></ul></li><li>给每个线程加上唯一的标识UUID随机生成，释放的时候判断是否是当前的标识即可</li></ol><h3 id="_2、redisson" tabindex="-1"><a class="header-anchor" href="#_2、redisson" aria-hidden="true">#</a> 2、Redisson</h3><ul><li>Redis 是最流行的 NoSQL 数据库解决方案之一，而 Java 是世界上最流行（注意，我没有说“最好”）的编程语言之一。</li><li>虽然两者看起来很自然地在一起“工作”，但是要知道，Redis 其实并没有对 Java 提供原生支持。</li><li>相反，作为 Java 开发人员，我们若想在程序中集成 Redis，必须使用 Redis 的第三方库。</li><li>而 Redisson 就是用于在 Java 程序中操作 Redis 的库，它使得我们可以在程序中轻松地使用 Redis。</li><li>Redisson 在 java.util 中常用接口的基础上，为我们提供了一系列具有<strong>分布式特性</strong>的工具类。</li></ul><h1 id="十四、linux常用命令" tabindex="-1"><a class="header-anchor" href="#十四、linux常用命令" aria-hidden="true">#</a> 十四、Linux常用命令</h1><p><strong>文件与目录操作</strong></p><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>cd /home</td><td>进入 ‘/home’ 目录</td></tr><tr><td>cd ..</td><td>返回上一级目录</td></tr><tr><td>cd ../..</td><td>返回上两级目录</td></tr><tr><td>cd -</td><td>返回上次所在目录</td></tr><tr><td>cp file1 file2</td><td>将file1复制为file2</td></tr><tr><td>cp -a dir1 dir2</td><td>复制一个目录</td></tr><tr><td>cp -a /tmp/dir1 .</td><td>复制一个目录到当前工作目录（.代表当前目录）</td></tr><tr><td>ls</td><td>查看目录中的文件</td></tr><tr><td>ls -a</td><td>显示隐藏文件</td></tr><tr><td>ls -l</td><td>显示详细信息</td></tr><tr><td>ls -lrt</td><td>按时间显示文件（l表示详细列表，r表示反向排序，t表示按时间排序）</td></tr><tr><td>pwd</td><td>显示工作路径</td></tr><tr><td>mkdir dir1</td><td>创建 ‘dir1’ 目录</td></tr><tr><td>mkdir dir1 dir2</td><td>同时创建两个目录</td></tr><tr><td>mkdir -p /tmp/dir1/dir2</td><td>创建一个目录树</td></tr><tr><td>mv dir1 dir2</td><td>移动/重命名一个目录</td></tr><tr><td>rm -f file1</td><td>删除 ‘file1’</td></tr><tr><td>rm -rf dir1</td><td>删除 ‘dir1’ 目录及其子目录内容</td></tr></tbody></table><p><strong>查看文件内容</strong></p><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>cat file1</td><td>从第一个字节开始正向查看文件的内容</td></tr><tr><td>head -2 file1</td><td>查看一个文件的前两行</td></tr><tr><td>more file1</td><td>查看一个长文件的内容</td></tr><tr><td>tac file1</td><td>从最后一行开始反向查看一个文件的内容</td></tr><tr><td>tail -3 file1</td><td>查看一个文件的最后三行</td></tr><tr><td>vi file</td><td>打开并浏览文件</td></tr></tbody></table><p><strong>文本内容处理</strong></p><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>grep str /tmp/test</td><td>在文件 ‘/tmp/test’ 中查找 “str”</td></tr><tr><td>grep ^str /tmp/test</td><td>在文件 ‘/tmp/test’ 中查找以 “str” 开始的行</td></tr><tr><td>grep [0-9] /tmp/test</td><td>查找 ‘/tmp/test’ 文件中所有包含数字的行</td></tr><tr><td>grep str -r /tmp/*</td><td>在目录 ‘/tmp’ 及其子目录中查找 “str”</td></tr><tr><td>diff file1 file2</td><td>找出两个文件的不同处</td></tr><tr><td>sdiff file1 file2</td><td>以对比的方式显示两个文件的不同</td></tr><tr><td>vi file</td><td></td></tr><tr><td>操作</td><td>解析</td></tr><tr><td>i</td><td>进入编辑文本模式</td></tr><tr><td>Esc</td><td>退出编辑文本模式</td></tr><tr><td>:w</td><td>保存当前修改</td></tr><tr><td>:q</td><td>不保存退出vi</td></tr><tr><td>:wq</td><td>保存当前修改并退出vi</td></tr></tbody></table><p><strong>查询操作</strong></p><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>find / -name file1</td><td>从 ‘/’ 开始进入根文件系统查找文件和目录</td></tr><tr><td>find / -user user1</td><td>查找属于用户 ‘user1’ 的文件和目录</td></tr><tr><td>find /home/user1 -name *.bin</td><td>在目录 ‘/ home/user1’ 中查找以 ‘.bin’ 结尾的文件</td></tr><tr><td>find /usr/bin -type f -atime +100</td><td>查找在过去100天内未被使用过的执行文件</td></tr><tr><td>find /usr/bin -type f -mtime -10</td><td>查找在10天内被创建或者修改过的文件</td></tr><tr><td>locate *.ps</td><td>寻找以 ‘.ps’ 结尾的文件，先运行 ‘updatedb’ 命令</td></tr><tr><td>find -name ‘*.[ch]’ | xargs grep -E ‘expr’</td><td>在当前目录及其子目录所有.c和.h文件中查找 ‘expr’</td></tr><tr><td>find -type f -print0 | xargs -r0 grep -F ‘expr’</td><td>在当前目录及其子目录的常规文件中查找 ‘expr’</td></tr><tr><td>find -maxdepth 1 -type f | xargs grep -F ‘expr’</td><td>在当前目录中查找 ‘expr’</td></tr></tbody></table><p><strong>压缩、解压</strong></p><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>bzip2 file1</td><td>压缩 file1</td></tr><tr><td>bunzip2 file1.bz2</td><td>解压 file1.bz2</td></tr><tr><td>gzip file1</td><td>压缩 file1</td></tr><tr><td>gzip -9 file1</td><td>最大程度压缩 file1</td></tr><tr><td>gunzip file1.gz</td><td>解压 file1.gz</td></tr><tr><td>tar -cvf archive.tar file1</td><td>把file1打包成 archive.tar（-c: 建立压缩档案；-v: 显示所有过程；-f: 使用档案名字，是必须的，是最后一个参数）</td></tr><tr><td>tar -cvf archive.tar file1 dir1</td><td>把 file1，dir1 打包成 archive.tar</td></tr><tr><td>tar -tf archive.tar</td><td>显示一个包中的内容</td></tr><tr><td>tar -xvf archive.tar</td><td>释放一个包</td></tr><tr><td>tar -xvf archive.tar -C /tmp</td><td>把压缩包释放到 /tmp目录下</td></tr><tr><td>zip file1.zip file1</td><td>创建一个zip格式的压缩包</td></tr><tr><td>zip -r file1.zip file1 dir1</td><td>把文件和目录压缩成一个zip格式的压缩包</td></tr><tr><td>unzip file1.zip</td><td>解压一个zip格式的压缩包到当前目录</td></tr><tr><td>unzip test.zip -d /tmp/</td><td>解压一个zip格式的压缩包到 /tmp 目录</td></tr></tbody></table><p><strong>yum安装器</strong></p><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>yum -y install [package]</td><td>下载并安装一个rpm包</td></tr><tr><td>yum localinstall [package.rpm]</td><td>安装一个rpm包，使用你自己的软件仓库解决所有依赖关系</td></tr><tr><td>yum -y update</td><td>更新当前系统中安装的所有rpm包</td></tr><tr><td>yum update [package]</td><td>更新一个rpm包</td></tr><tr><td>yum remove [package]</td><td>删除一个rpm包</td></tr><tr><td>yum list</td><td>列出当前系统中安装的所有包</td></tr><tr><td>yum search [package]</td><td>在rpm仓库中搜寻软件包</td></tr><tr><td>yum clean [package]</td><td>清除缓存目录（/var/cache/yum）下的软件包</td></tr><tr><td>yum clean headers</td><td>删除所有头文件</td></tr><tr><td>yum clean all</td><td>删除所有缓存的包和头文件</td></tr></tbody></table><p><strong>网络相关</strong></p><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>ifconfig eth0</td><td>显示一个以太网卡的配置</td></tr><tr><td>ifconfig eth0 192.168.1.1 netmask 255.255.255.0</td><td>配置网卡的IP地址</td></tr><tr><td>ifdown eth0</td><td>禁用 ‘eth0’ 网络设备</td></tr><tr><td>ifup eth0</td><td>启用 ‘eth0’ 网络设备</td></tr><tr><td>iwconfig eth1</td><td>显示一个无线网卡的配置</td></tr><tr><td>iwlist scan</td><td>显示无线网络</td></tr><tr><td>ip addr show</td><td>显示网卡的IP地址</td></tr></tbody></table><p><strong>系统相关</strong></p><table><thead><tr><th>命令</th><th>解析</th></tr></thead><tbody><tr><td>su -</td><td>切换到root权限（与su有区别）</td></tr><tr><td>shutdown -h now</td><td>关机</td></tr><tr><td>shutdown -r now</td><td>重启</td></tr><tr><td>top</td><td>罗列使用CPU资源最多的linux任务 （输入q退出）</td></tr><tr><td>pstree</td><td>以树状图显示程序</td></tr><tr><td>man ping</td><td>查看参考手册（例如ping 命令）</td></tr><tr><td>passwd</td><td>修改密码</td></tr><tr><td>df -h</td><td>显示磁盘的使用情况</td></tr><tr><td>cal -3</td><td>显示前一个月，当前月以及下一个月的月历</td></tr><tr><td>cal 10 1988</td><td>显示指定月，年的月历</td></tr><tr><td>date –date ‘1970-01-01 UTC 1427888888 seconds’</td><td>把一相对于1970-01-01 00:00的秒数转换成时间</td></tr></tbody></table><h1 id="十五、javaweb面试题" tabindex="-1"><a class="header-anchor" href="#十五、javaweb面试题" aria-hidden="true">#</a> 十五、JavaWeb面试题</h1><h2 id="_1、什么是servlet" tabindex="-1"><a class="header-anchor" href="#_1、什么是servlet" aria-hidden="true">#</a> 1、什么是Servlet</h2><p>Servlet是一门用于开发动态web资源的技术，它是运行在服务器端的小程序。</p><p>Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。</p><p>作用：Servlet主要用于处理客户端传来的HTTP请求，并返回一个响应，它能够处理的请求有doGet()和doPost()等方法。</p><p>用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤：</p><ol><li>编写一个Java类，实现Servlet接口。</li><li>把开发好的Java类部署到web服务器中。</li></ol><h2 id="_2、什么是servlet对象的生命周期" tabindex="-1"><a class="header-anchor" href="#_2、什么是servlet对象的生命周期" aria-hidden="true">#</a> 2、什么是Servlet对象的生命周期</h2><ul><li>Servlet对象什么时候被创建。</li><li>Servlet对象什么时候被销毁。</li><li>Servlet对象创建了几个？</li><li>Servlet对象的生命周期表示：一个Servlet对象从出生在最后的死亡，整个过程是怎样的。</li></ul><p>我们不需要在程序创建Servlet的对象，也没有去调用对象上的方法。Servlet对象的生命周期由web服务器负责</p><h2 id="_3、jsp九大内置对象" tabindex="-1"><a class="header-anchor" href="#_3、jsp九大内置对象" aria-hidden="true">#</a> 3、JSP九大内置对象</h2><ol><li>pageContext，页面上下文对象，相当于页面中所有功能的集合，通过它可以获取JSP页面的out、request、response、session、application对象。</li><li>request</li><li>response</li><li>session</li><li>application，应用程序对象，application实现了用户间数据的共享，可存放全局变量，它开始于服务器启动，知道服务器关闭。</li><li>page，就是JSP本身。</li><li>exception</li><li>out，out用于在web浏览器内输出信息，并且管理应用服务器上的输出缓冲区，作用域page。</li><li>config，取得服务器的配置信息。</li></ol><h2 id="_4、jsp和servlet的区别" tabindex="-1"><a class="header-anchor" href="#_4、jsp和servlet的区别" aria-hidden="true">#</a> 4、JSP和Servlet的区别</h2><p>（1）servlet是服务器端的Java程序，它担当客户端和服务端的中间层。</p><p>（2）JSP全名为Java server pages，中文名叫Java服务器页面，其本质是一个简化的servlet设计。JSP是一种动态页面设计，它的主要目的是将表示逻辑从servlet中分离出来。</p><p>（3）JVM只能识别Java代码，不能识别JSP，JSP编译后变成了servlet，web容器将JSP的代码编译成JVM能够识别的Java类（servlet）。</p><p>（4）JSP有内置对象、servlet没有内置对象。</p><h2 id="_5、转发和重定向的区别" tabindex="-1"><a class="header-anchor" href="#_5、转发和重定向的区别" aria-hidden="true">#</a> 5、转发和重定向的区别</h2><ol><li>重定向访问服务器两次，转发只访问服务器一次。</li><li>转发页面的URL不会改变，而重定向地址会改变</li><li>转发只能转发到自己的web应用内，重定向可以重定义到任意资源路径。</li><li>转发相当于服务器跳转，相当于方法调用，在执行当前文件的过程中转向执行目标文件，两个文件(当前文件和目标文件)属于同一次请求，前后页 共用一个request，可以通过此来传递一些数据或者session信息，request.setAttribute()和 request.getAttribute()。而重定向会产生一个新的request，不能共享request域信息与请求参数</li><li>由于转发相当于服务器内部方法调用，所以转发后面的代码仍然会执行(转发之后记得return)；重定向代码执行之后是方法执行完成之后进行重定向操作，也就是访问第二个请求，如果是方法的最后一行进行重定向那就会马上进行重定向(重定向也需要return)。</li><li>无论是RequestDispatcher.forward方法，还是HttpServletResponse.sendRedirect方法，在调用它们之前，都不能有内容已经被实际输出到了客户端。如果缓冲区中已经有了一些内容，这些内容将被从缓冲区中移除。</li></ol><h2 id="_6、session-和-cookie-有什么区别" tabindex="-1"><a class="header-anchor" href="#_6、session-和-cookie-有什么区别" aria-hidden="true">#</a> 6、session 和 cookie 有什么区别？</h2><p>（1）存储位置不同</p><ul><li>cookie在客户端浏览器；</li><li>session在服务器；</li></ul><p>（2）存储容量不同</p><ul><li>cookie&lt;=4K，一个站点最多保留20个cookie；</li><li>session没有上线，出于对服务器的保护，session内不可存过多东西，并且要设置session删除机制；</li></ul><p>（3）存储方式不同</p><ul><li>cookie只能保存ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据；</li><li>session中能存储任何类型的数据，包括并不局限于String、integer、list、map等；</li></ul><p>（4）隐私策略不同</p><ul><li>cookie对客户端是可见的，不安全；</li><li>session存储在服务器上，安全；</li></ul><p>（5）有效期不同</p><ul><li>开发可以通过设置cookie的属性，达到使cookie长期有效的效果；</li><li>session依赖于名为JESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session达不到长期有效的效果；</li></ul><p>（6）跨域支持上不同</p><ul><li>cookie支持跨域；</li><li>session不支持跨域；</li></ul><h2 id="_7、get和post的区别" tabindex="-1"><a class="header-anchor" href="#_7、get和post的区别" aria-hidden="true">#</a> 7、get和post的区别</h2><ol><li>get请求参数是连接在url后面的,而post请求参数是存放在requestbody内的；</li><li>get请求因为浏览器对url长度有限制，所以参数个数有限制，而post请求参数个数没有限制；</li><li>因为get请求参数暴露在url上,所以安全方面post比get更加安全；</li><li>get请求只能进行url编码,而post请求可以支持多种编码方式；</li><li>get请求参数会保存在浏览器历史记录内,post请求并不会；</li><li>get请求浏览器会主动cache,post并不会,除非主动设置；</li><li>get请求产生1个tcp数据包,post请求产生2个tcp数据包；</li><li>在浏览器进行回退操作时,get请求是无害的,而post请求则会重新请求一次；</li><li>浏览器在发送get请求时会将header和data一起发送给服务器,服务器返回200状态码,而在发送post请求时,会先将header发送给服务器,服务器返回100,之后再将data发送给服务器,服务器返回200 OK；</li></ol><h2 id="_8、说一下-session-的工作原理" tabindex="-1"><a class="header-anchor" href="#_8、说一下-session-的工作原理" aria-hidden="true">#</a> 8、说一下 session 的工作原理？</h2><p>当客户端登录完成后，会在服务端产生一个session，此时服务端会将sessionid返回给客户端浏览器。客户端将sessionid储存在浏览器的cookie中，当用户再次登录时，会获得对应的sessionid，然后将sessionid发送到服务端请求登录，服务端在内存中找到对应的sessionid，完成登录，如果找不到，返回登录页面。</p><h2 id="_9、简述-tcp-和-udp的区别" tabindex="-1"><a class="header-anchor" href="#_9、简述-tcp-和-udp的区别" aria-hidden="true">#</a> 9、简述 TCP 和 UDP的区别？</h2><ol><li>TCP是传输控制协议，UDP是用户数据表协议；</li><li>TCP长连接，UDP无连接；</li><li>UDP程序结构较简单，只需发送，无须接收；</li><li>TCP可靠，保证数据正确性、顺序性；UDP不可靠，可能丢数据；</li><li>TCP适用于少量数据，UDP适用于大量数据传输；</li><li>TCP速度慢，UDP速度快；</li></ol><h2 id="_10、什么是三次握手-四次挥手" tabindex="-1"><a class="header-anchor" href="#_10、什么是三次握手-四次挥手" aria-hidden="true">#</a> 10、什么是三次握手，四次挥手 ？</h2><table><thead><tr><th style="text-align:left;">消息类型</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:left;">SYN</td><td style="text-align:left;">这个消息是用来初始化和建立连接的 Synchronize Sequence Numbers</td></tr><tr><td style="text-align:left;">ACK</td><td style="text-align:left;">帮助对方确认收到的SYN信息 Acknowledge character</td></tr><tr><td style="text-align:left;">SYN-ACK</td><td style="text-align:left;">本地的SYN信息和较早的ACK数据包</td></tr><tr><td style="text-align:left;">FIN</td><td style="text-align:left;">用来断开连接的</td></tr></tbody></table><ol><li><p>在客户机和服务器之间建立TCP连接时，首先会发送的一个信号。客户端在接受到SYN消息时，就会在自己的段内生成一个随机值X。</p></li><li><p>服务器收到SYN后，打开客户端连接，发送一个SYN-ACK作为答复。确认后设置为比接收到的序列号多一个，即X+1，服务器为数据包选择的序列号是另一个随机数Y。</p></li><li><p>确认字符，表示发来的数据已确认接收无误。最后，客户端将ACK发送给服务器。序列号被设置为所接收的确认值即Y+1。</p></li></ol><p><strong>举例</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230202164718805.png" alt="image-20230202164718805" tabindex="0" loading="lazy"><figcaption>image-20230202164718805</figcaption></figure><h2 id="四次挥手" tabindex="-1"><a class="header-anchor" href="#四次挥手" aria-hidden="true">#</a> 四次挥手</h2><ol><li>首先，客户端应用程序决定要终止连接(这里服务端也可以选择断开连接)。这会使客户端将FIN发送到服务器，并进入FIN_WAIT_1状态。当客户端处于FIN_WAIT_1状态时，它会等待来自服务器的ACK响应。</li><li>第二步，当服务器收到FIN消息时，服务器会立刻向客户端发送ACK确认消息。</li><li>当客户端收到服务器发送的ACK响应后，客户端就进入FIN_WAIT_2状态，然后等待来自服务器的FIN 消息</li><li>服务器发送ACK确认消息后，一段时间(可以进行关闭后)会发送FIN消息给客户端，告知客户端可以进行关闭。</li><li>当客户端收到从服务端发送的FIN消息时，客户端就会由FIN_WAIT_2状态变为TIME_WAIT状态。处于TIME_ WAIT 状态的客户端允许重新发送ACK到服务器为了防止信息丢失。客户端在TIME_ WAIT 状态下花费的时间取决于它的实现，在等待一段时间后,连接关闭，客户端上所有的资源. (包括端口号和缓冲区数据)都被释放。</li></ol><p><strong>举例</strong></p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230202164744429.png" alt="image-20230202164744429" tabindex="0" loading="lazy"><figcaption>image-20230202164744429</figcaption></figure><h2 id="_11、tcp-为什么要三次握手-两次不行吗-为什么" tabindex="-1"><a class="header-anchor" href="#_11、tcp-为什么要三次握手-两次不行吗-为什么" aria-hidden="true">#</a> 11、tcp 为什么要三次握手，两次不行吗？为什么？</h2><p>因为客户端和服务端都要确认连接，①客户端请求连接服务端；②针对客户端的请求确认应答，并请求建立连接；③针对服务端的请求确认应答，建立连接；</p><p>两次无法确保A能收到B的数据；</p><h1 id="十六、git面试题" tabindex="-1"><a class="header-anchor" href="#十六、git面试题" aria-hidden="true">#</a> 十六、Git面试题</h1><h2 id="_1、git和svn的区别" tabindex="-1"><a class="header-anchor" href="#_1、git和svn的区别" aria-hidden="true">#</a> 1、Git和SVN的区别</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230207203405254.png" alt="image-20230207203405254" tabindex="0" loading="lazy"><figcaption>image-20230207203405254</figcaption></figure><h2 id="_2、什么是git" tabindex="-1"><a class="header-anchor" href="#_2、什么是git" aria-hidden="true">#</a> 2、什么是Git</h2><ul><li>Git 是分布式版本控制系统（DVCS）。它可以跟踪文件的更改，并允许你恢复到任何特定版本的更改。</li><li>与 SVN 等其他版本控制系统（VCS）相比，其分布式架构具有许多优势，一个主要优点是它不依赖于中央服务器来存储项目文件的所有版本。</li><li>每个开发人员都可以“克隆”我在图中用“Local repository”标注的存储库的副本，并且在他的硬盘驱动器上具有项目的完整历史记录，因此当服务器中断时，你需要的所有恢复数据都在你队友的本地 Git 存储库中。</li><li>还有一个中央云存储库，开发人员可以向其提交更改，并与其他团队成员进行共享，如图所示，所有协作者都在提交更改“远程存储库”。</li></ul><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230207203436038.png" alt="image-20230207203436038" tabindex="0" loading="lazy"><figcaption>image-20230207203436038</figcaption></figure><h2 id="_3、git的工作流程" tabindex="-1"><a class="header-anchor" href="#_3、git的工作流程" aria-hidden="true">#</a> 3、Git的工作流程</h2><h1 id="十七、maven面试题" tabindex="-1"><a class="header-anchor" href="#十七、maven面试题" aria-hidden="true">#</a> 十七、Maven面试题</h1><h2 id="_1、什么是maven" tabindex="-1"><a class="header-anchor" href="#_1、什么是maven" aria-hidden="true">#</a> 1、什么是maven？</h2><blockquote><p>Maven主要服务于基于java平台的项目构建，依赖管理和项目信息管理。maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。它包含了一个项目对象模型，一组标准集合，一个项目生命周期，一个依赖管理系统和用来运行定义在生命周期阶段中插件目标的逻辑。当使用Maven的时候，你用一个明确定义的项目对象模型来描述你的项目，然后Maven可以应用横切的逻辑，这些逻辑来自于一组共享的（或自定义的）插件。</p></blockquote><h2 id="_2、说说maven有什么优缺点" tabindex="-1"><a class="header-anchor" href="#_2、说说maven有什么优缺点" aria-hidden="true">#</a> 2、说说maven有什么优缺点？</h2><p><strong>优点</strong></p><ul><li>简化了项目依赖管理</li><li>易于上手，对于新手来说了解几个常用命令即可满足日常工作</li><li>便于与持续集成工具（jenkins）整合便于项目升级，无论是项目本身还是项目使用的依赖</li><li>maven有很多插件，便于功能扩展，比如生产站点，自动发布版本等为什么使用Maven中的各点</li></ul><p><strong>缺点</strong></p><ul><li>Maven是一个庞大的构建系统，学习难度大。（很多都可以这样说，入门容易[优点]但是精通难[缺点]）</li><li>Maven采用约定约定优于配置的策略，虽然上手容易但是一旦出现问题，难于调试中网络环境较差，很多repository无法访问</li></ul><h2 id="_3、讲一下maven的生命周期" tabindex="-1"><a class="header-anchor" href="#_3、讲一下maven的生命周期" aria-hidden="true">#</a> 3、讲一下maven的生命周期</h2><p>Maven的 生命周期：从我们的项目构建，一直到项目发布的这个过程。</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230213160027538.png" alt="image-20230213160027538" tabindex="0" loading="lazy"><figcaption>image-20230213160027538</figcaption></figure><h2 id="_4、说说你熟悉哪些maven命令" tabindex="-1"><a class="header-anchor" href="#_4、说说你熟悉哪些maven命令" aria-hidden="true">#</a> 4、说说你熟悉哪些maven命令？</h2><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/img/image-20230213160052003.png" alt="image-20230213160052003" tabindex="0" loading="lazy"><figcaption>image-20230213160052003</figcaption></figure><h2 id="_5、" tabindex="-1"><a class="header-anchor" href="#_5、" aria-hidden="true">#</a> 5、</h2><h1 id="十八、人事面试题" tabindex="-1"><a class="header-anchor" href="#十八、人事面试题" aria-hidden="true">#</a> 十八、人事面试题</h1><h2 id="_1、为什么从上家公司离职" tabindex="-1"><a class="header-anchor" href="#_1、为什么从上家公司离职" aria-hidden="true">#</a> 1、为什么从上家公司离职？</h2><blockquote><p>首先，切记不要诋毁你的老东家。你应该把你的离职原因集中表述在“寻找新机会或新的平台”以及尝试在新的岗位上提升自己。</p></blockquote><ul><li>在体现忠诚度的时候，你可以试着谈谈你离开上一家公司时有多么痛苦依依不舍(即使并没有)，聊聊如果有办法使你能在原来的岗位上持续得到提升或者如果不是因为股东之间的权利斗争(可适当显得痛心疾首些)，你肯定不会离开。</li><li>首先，你从上家公司离职时已经为继任者做了充分的交接。你需要清楚地表明：你在上家公司也很认真尽职，并且同事之间一直保持互助互利的工作氛围。也许你可以说说你也想过要早些辞职，但是考虑某个未完成的重要项目、或是继任者短期内还不能胜任角色所以晚了一些。</li><li>你需要清楚地表明：你在上家公司也很认真尽职，并且同事之间一直保持互助互利的工作氛围。也许你可以说说你也想过要早些辞职，但是考虑某个未完成的重要项目、或是继任者短期内还不能胜任角色所以晚了一些。</li></ul><h2 id="_2、你对加班怎么看待" tabindex="-1"><a class="header-anchor" href="#_2、你对加班怎么看待" aria-hidden="true">#</a> 2、你对加班怎么看待？</h2><p>刚进公司，需要对环境、业务、代码短期内提高熟悉度，会选择适量加班，公司和项目需要加班时，会和大家一起拼命，这是保证项目进度和质量的自我要求。平时都能高效完成任务，一般不需要加班。</p><h2 id="_3、如果公司录用你-你会在公司工作多久" tabindex="-1"><a class="header-anchor" href="#_3、如果公司录用你-你会在公司工作多久" aria-hidden="true">#</a> 3、如果公司录用你,你会在公司工作多久?</h2><p>结合对方公司，表示会长时间做下去 不要直接回答会呆多久,或者呆半年这种正面回答:来公司之前,我已经大致了解过公司以及公司的项目,现在在这里面试,对公司又有了进一步的了解,公司就是符合我个人期望,项目我也很感兴趣.我希望有荣幸加入公司,在技术方面得到新启发和沉淀,我会长时间做下去.</p><h2 id="_4、你最大的优缺点" tabindex="-1"><a class="header-anchor" href="#_4、你最大的优缺点" aria-hidden="true">#</a> 4、你最大的优缺点？</h2><p>优点就可以提关于技术与学习能力,以及沟通能力方面.缺点可以稍微思考一下,可能我管理的能力还需要进一步加强,</p><p>缺点别太暴露自己</p><h2 id="_5、希望去怎么样的公司" tabindex="-1"><a class="header-anchor" href="#_5、希望去怎么样的公司" aria-hidden="true">#</a> 5、希望去怎么样的公司?</h2><p>福利好,工作轻松的公司当然是我心中第一首选.但是现实还是有些差距,现在对我做了这么多年工作经验来讲,一般有两个选择,一种是有钱途,另一种是有前途.个人来讲我是会选择有前途, 我来贵公司面试前,查过公司的资料,初步了解过,贵公司就是我渴望加入的团队.</p><h2 id="_6、你工作中遇到哪些bug-怎么解决的" tabindex="-1"><a class="header-anchor" href="#_6、你工作中遇到哪些bug-怎么解决的" aria-hidden="true">#</a> 6、你工作中遇到哪些bug,怎么解决的?</h2><ol><li>刚入行的时候，对业务不太熟悉，加上给的业务文档不清晰，导致加班很多。</li><li>项目中第一次做微信登录模块，微信支付模块，不太熟悉，导致吃了不少苦头。</li><li>微服务bug。</li></ol><h2 id="_7、和同事或经理起冲突怎么办" tabindex="-1"><a class="header-anchor" href="#_7、和同事或经理起冲突怎么办" aria-hidden="true">#</a> 7、和同事或经理起冲突怎么办?</h2><p>首先要说你之前工作没有跟同事或经理起冲突,表明你是一个很好沟通,很好相处的人.然后再正面回答他的问题,假设真正在这个场景下,如果冲突来自于工作,非常好解决,大家都有共同目的,就是把工作搞好,既然目标一致,冲突的根源就没有了.根源没有,在处理上大家各退一步,大家都是同事没有什么大不了.</p><h2 id="_8、三到五年的规划" tabindex="-1"><a class="header-anchor" href="#_8、三到五年的规划" aria-hidden="true">#</a> 8、三到五年的规划?</h2><p>可以回答五年太长,未来充满变化,计划赶不上变化,我说说我近两年的计划，我们作为技术人员，最好的说法就是:自己比较喜欢专研技术,这两年想好好沉淀技术.想一直在技术这条路上 走下去，学习前端、后台的技术成为一名全栈式开发工程师或者往层研究,或者在沉淀自己的技术同时也加强自己的管理能力,让自己成为一个有竞争力的人.</p><h2 id="_9、上家公司的人员组成" tabindex="-1"><a class="header-anchor" href="#_9、上家公司的人员组成" aria-hidden="true">#</a> 9、上家公司的人员组成?</h2><p>我上家公司技术团队有14人左右,6个后端,3个前端，2个运维,2个测试,一个项目经理和一个产品经理。我刚进去的时候,负责一个稳定成型的项目的维护和迭代.后面熟悉业务之后,参与XX新项目开发.新项目稳定后，负责版本迭代工作，以及公司业务需求。</p><h2 id="_10、项目经理给了一个超出你能力的需求-你怎么办" tabindex="-1"><a class="header-anchor" href="#_10、项目经理给了一个超出你能力的需求-你怎么办" aria-hidden="true">#</a> 10、项目经理给了一个超出你能力的需求，你怎么办？</h2><p>其实我之前的工作中的确有过几次,有一次项目经理分配我一个功能模块,我看到原型图和需求文档,大概有10个界面,业务逻辑有些复杂.但是项目经理给的周期只有一周时间.我当时估算一下时间有些短,当时我拿到之后,我根据每个小功能模块实现时间来估算全部的时间,写在纸上,找了项目经理,,根据我列出来的时间聊一下具体情况.项目经理和我商量后,采取了我的意见,周期延长，我个人觉得,如果需求周期这个估算如有问题,应该要及时提出来,如果时间过去一大半再提出延长周期,这样很不好。</p><h2 id="_11、你和别人比-你觉得他们强的地方在哪里" tabindex="-1"><a class="header-anchor" href="#_11、你和别人比-你觉得他们强的地方在哪里" aria-hidden="true">#</a> 11、你和别人比,你觉得他们强的地方在哪里?</h2><p>不要一上来就说,比别人强,通过贬低别人来衬托自己.最好说说自己长处,把这道题变成说自己的优点.可以这样回答:每个人的优缺点不一,但是别人厉害的地方我都会学习,取长补短.毕竟每个人的优势不一样.我的优点在于我的沟通和学习能力.我刚刚工作的时候,其实还是比较腼腆,但是几年的公司,让我的沟通和学习能力大幅增长,刚进公司的时候,基本不敢跟同事说话,有时候跟经理说话很紧张，后面我成为部门活动组织者和公司年度优秀员工</p><h2 id="_12、你对自己评价如何" tabindex="-1"><a class="header-anchor" href="#_12、你对自己评价如何" aria-hidden="true">#</a> 12、你对自己评价如何?</h2><p>尽量打高分一点,并主动说出打这个的理由.可以这样回答:对于今天的面试,如果满分是十分的话,我会给自己7~8分之间.为什么呢,首先在技术回答,我回答比较流畅,也是我比较熟悉的部分,基本表达出我之前工作累计的东西.,另外在表达上我的表达还是完整和清晰,整个人比较轻松,另外有点不足就是,我之前会的还有一些方面还没有来得及跟面试官探讨,希望有机会加入公司,日后探讨。</p><h2 id="_13、你还有什么问题要问" tabindex="-1"><a class="header-anchor" href="#_13、你还有什么问题要问" aria-hidden="true">#</a> 13、你还有什么问题要问?</h2><p>这一道90%会问的问题.千万别说没有问题.也不要问福利之类,福利放在谈薪资的时候去问.可以问公司的一些项目情况，晋升制度，员工职业规划，培训机制，或者面试个人表现。</p><h2 id="_14、你能为我们公司带来什么" tabindex="-1"><a class="header-anchor" href="#_14、你能为我们公司带来什么" aria-hidden="true">#</a> 14、你能为我们公司带来什么?</h2><p>我从事Java这么长时间,我相信我的技术和丰富的项目经验可以胜任我们公司的工作,高效的完成公司任务,公司对我已经进行过技术面试,对我技术有一定了解.通过和你聊天,相信你对我沟通和表达能力也有初步了解.另外我个人性格比较开朗,爱好很多.可以快速融入公司中.可以积极提升部门的工作氛围.如果有机会,我可以做一些自己工作经验分享.</p><h2 id="_15、能不能接受出差-有没有打算做项目经理" tabindex="-1"><a class="header-anchor" href="#_15、能不能接受出差-有没有打算做项目经理" aria-hidden="true">#</a> 15、能不能接受出差?有没有打算做项目经理?</h2><p>对于出差,我是能接受,但是不知道公司出差频率怎么样,大概去哪些城市.项目经理这个我是想过了,这是我职业规划中的,我做这一行业3年了,有很丰富的项目经验和技术,对整个项目流程也非常了解.但是缺少一些管理经验和能力.之后我完成本职工作之外,私下自己也会锻炼一下自己的管理能力.</p><h2 id="_16、如果你刚入职-将会如何开展工作" tabindex="-1"><a class="header-anchor" href="#_16、如果你刚入职-将会如何开展工作" aria-hidden="true">#</a> 16、如果你刚入职,将会如何开展工作?</h2><p>1、接手新项目，刚接手的新项目，那肯定还在需求阶段。产品（或者给你需求的上司）要和你说明白需求。正规的公司会召开“需求评审会议”，参会人员，有开发，设计或美工，产品等，目标就是给你说清楚我的需求是什么，我要开发一款怎样的产品？不那么正规的，可能就是口头跟你说一下需求，给你一些文档。最终的目的还是要告诉你我要开发什么产品，具体的功能都有哪些。</p><p>2、接手旧项目。刚进来，也要看需求啊，旧项目你会多一样东西：代码。程序设计、开发进度规划阶段。</p><p>这时候需求已经了解清楚了。新项目你要做程序设计，做开发规划（UML等做初步的程序设计，程序设计好了，每个功能点需要花的大概时间也确定了，这时候就有开发规划了，说白了就是给自己的上班时间和开发内容排个时表）。</p><p>旧项目你需要一点时间看代码（因个人能力而定一般都是几天到一周内），然后写下一个功能的程序设计和排班规划。</p><ul><li>刚上班，第一件事：从代码仓库更新下自己的代码，有冲突马上解决。</li><li>搞敏捷开发的团队，可能有每日小例会。说的就是昨天的问题，和今天的计划。简单说一下，不要针对bug或者问题一直讨论，比如我发现前端好像有问题。开会时说一下，下来再和前端哥们沟通调试。</li><li>根据设计和规划，完成今天的代码工作。遇到细节问题马上找产品、前端、美工去单独问。不要闷头干。</li><li>代码写好了，给产品、测试去玩玩，看看符不符合需求。</li><li>测试提交的bug找时间解决一下。</li><li>下班前把关键代码打个patch,和同事一起codereview，减少错误和冲突。</li><li>把你的代码提交上去。有冲突及时解决。</li></ul><p>开发好功能后，测试就要使劲测了。这时候你的主要工作就是解bug，和产品、设计、测试一起多沟通。把bug数量降低，达到产品发布的合格水平。</p><p>交给公司运营/运维/项目经理上线，当天可能会有新的bug，尽快解决，保证上线发布稳定成功。</p><h2 id="_17、谈谈你对跳槽的看法" tabindex="-1"><a class="header-anchor" href="#_17、谈谈你对跳槽的看法" aria-hidden="true">#</a> 17、谈谈你对跳槽的看法?</h2><p>跳槽很多种,处理不好同事关系等原因在公司待不下去跳槽,这个我是不看好,属于个人问题,如果不改正,到了下一家公司也很呆下去.如果是在一个公司两三年以上,技术和个人发展很长一段时间没有增长,可以适当的转换环境,可以在新环境可以有新的思路.这种我是不反对的.这次我选择跳槽也正是这个原因.</p><h2 id="_18、你的朋友对你评价" tabindex="-1"><a class="header-anchor" href="#_18、你的朋友对你评价" aria-hidden="true">#</a> 18、你的朋友对你评价?</h2><p>对于今天的面试,如果满分是十分的话,我会给自己7~8分之间.为什么呢,首先在技术回答,我回答比较流畅,也是我比较熟悉的部分,基本表达出我之前工作累计的东西.,另外在表达上我的表达还是完整和清晰,整个人比较轻松,另外有点不足就是,我之前会的还有一些方面还没有来得及跟面试官探讨,希望有机会加入公司,日后探讨。</p><h2 id="_19、说说开发中-你的性格、经验、视野、基础如何" tabindex="-1"><a class="header-anchor" href="#_19、说说开发中-你的性格、经验、视野、基础如何" aria-hidden="true">#</a> 19、说说开发中，你的性格、经验、视野、基础如何?</h2><p>在工作中,我的基础还是比较扎实,我入职上家公司时候,我的老大对我的面试评价,就是基础比较扎实.之前在这一行摸爬滚打2年,经验比较丰富,有自己通过跳坑的总结出来经验,也有跟优秀同事学习的经验,这个跟我个人性格有关,我喜欢跟优秀的人一起工作,经常可以和他们探讨一些技术,转化成自己的东西.至于视野也是我现在努力方向,好像我刚进入行业时候,就想着以实现功能为主,做了一段时间后,考虑代码质量,代码封装,后面考虑性能优化,到现在开始慢慢学习从架构的层次去看待一个项目.不过还有待学习.</p><figure><img src="https://gaoziman.oss-cn-hangzhou.aliyuncs.com/LeoPic202312031906036.png" alt="公众号封面" tabindex="0" loading="lazy"><figcaption>公众号封面</figcaption></figure></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/gaoziman/toLeoJavaer/edit/master/src/interview/interview-question-organization.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: “2942894660@qq.com”">“gaoziman”</span>,<!--]--><!--[--><span class="contributor" title="email: 2942894660@qq.com">gaoziman</span><!--]--><!--]--></div></div></footer><!----><!----><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer"><a href="http://beian.miit.gov.cn/" target="_blank">粤ICP备2022015190号-2</a></div><div class="vp-copyright">Copyright © 2024 Leo</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/toLeoJavaer/assets/app-2feb0630.js" defer></script>
  </body>
</html>
